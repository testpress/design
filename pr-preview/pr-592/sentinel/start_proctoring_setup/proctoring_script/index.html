<script>
function proctoring_test() {
  return {
    consent: false, 
    current_state: 'Proctoring Consent',
    steps: [
      { key: 'browser', name: 'Browser Support', description: 'Checks if your browser supports camera, screen share, and WebRTC.', status: 'pending', error: '', run: async function() {
        const supported = !!navigator.mediaDevices?.getUserMedia && !!navigator.mediaDevices?.getDisplayMedia && !!window.RTCPeerConnection;
        if (!supported) throw new Error("Browser doesn’t support required APIs. Use Chrome/Edge.");
      }},
      { key: 'webcam', name: 'Webcam', description: 'Checks if camera permissions are enabled.', status: 'pending', error: '', run: async function() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: true });
          stream.getTracks().forEach(t => t.stop());
        } catch {
          throw new Error("Camera access denied or not available.");
        }
      }},
      { key: 'microphone', name: 'Microphone', description: 'Checks if microphone permissions are enabled.', status: 'pending', error: '', run: async function() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          stream.getTracks().forEach(t => t.stop());
        } catch {
          throw new Error("Microphone access denied or not available.");
        }
      }},
      {
        key: 'network',
        name: 'Network',
        description: 'Checks network stability.',
        status: 'pending',
        error: '',
        run: async function() {
          if (!navigator.onLine) {
            throw new Error("No internet connection.");
          }

          const start = Date.now();

          await new Promise((resolve, reject) => {
            const img = new Image();
            img.src = "https://www.google.com/favicon.ico?" + Date.now();

            const timeout = setTimeout(() => reject(new Error("Network timeout (>5s).")), 5000);

            img.onload = () => {
              clearTimeout(timeout);
              resolve();
            };

            img.onerror = () => {
              clearTimeout(timeout);
              reject(new Error("Network check failed (resource blocked)."));
            };
          });

          const latency = Date.now() - start;
          if (latency > 3000) {
            throw new Error(`High latency detected (${latency}ms).`);
          }
        }
      }
    ],

    get allPassed() {
      return this.steps.every(s => s.status === 'success');
    },

    async runStep(step) {
      step.status = 'checking';
      step.error = '';
      try {
        // simulate 2s delay so UI updates
        await new Promise(resolve => setTimeout(resolve, 2000));
        await step.run();
        step.status = 'success';
      } catch (err) {
        step.status = 'error';
        step.error = err.message;
      }
    },

    async runAll() {
      for (let step of this.steps) {
        await this.runStep(step);
      }
    },

    async handleAction(step) {
      alert('called')
      alert(step.key)
  if (step.key === 'network') {
    // just re-run the test
    await this.runStep(step);
  } else if (step.key === 'webcam') {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      stream.getTracks().forEach(t => t.stop());
      step.status = 'success';
      step.error = '';
    } catch {
      step.status = 'error';
      step.error = 'Camera access denied or not available.';
    }
  } else if (step.key === 'microphone') {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      stream.getTracks().forEach(t => t.stop());
      step.status = 'success';
      step.error = '';
    } catch {
      step.status = 'error';
      step.error = 'Microphone access denied or not available.';
    }
  } else if (step.key === 'browser') {
    // Re-check browser features — no real "permission" to ask here
    await this.runStep(step);
  }
}

  }
}
</script>
