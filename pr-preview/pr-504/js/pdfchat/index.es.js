var Go = Object.defineProperty;
var Xi = (e) => {
  throw TypeError(e);
};
var Ko = (e, L, p) => L in e ? Go(e, L, { enumerable: !0, configurable: !0, writable: !0, value: p }) : e[L] = p;
var Tn = (e, L, p) => Ko(e, typeof L != "symbol" ? L + "" : L, p), ni = (e, L, p) => L.has(e) || Xi("Cannot " + p);
var x = (e, L, p) => (ni(e, L, "read from private field"), p ? p.call(e) : L.get(e)), Ne = (e, L, p) => L.has(e) ? Xi("Cannot add the same private member more than once") : L instanceof WeakSet ? L.add(e) : L.set(e, p), je = (e, L, p, n) => (ni(e, L, "write to private field"), n ? n.call(e, p) : L.set(e, p), p), Te = (e, L, p) => (ni(e, L, "access private method"), p);
var Zr = (e, L, p, n) => ({
  set _(t) {
    je(e, L, t, p);
  },
  get _() {
    return x(e, L, n);
  }
});
import { g as getAugmentedNamespace, r as requireReact, a as requireReactDom, j as jsxRuntimeExports, R as ReactDOM, b as React } from "../shared/jsx-runtime-SzVGEVAg.js";
var lib$h = { exports: {} }, core_min = {};
function commonjsRequire(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pdf = { exports: {} };
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$5 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredPdf;
function requirePdf() {
  return hasRequiredPdf || (hasRequiredPdf = 1, function(module, exports) {
    (function(L, p) {
      module.exports = L.pdfjsLib = p();
    })(globalThis, () => (
      /******/
      (() => {
        var __webpack_modules__ = [
          ,
          /* 1 */
          /***/
          (e, L) => {
            var xt;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.VerbosityLevel = L.Util = L.UnknownErrorException = L.UnexpectedResponseException = L.TextRenderingMode = L.RenderingIntentFlag = L.PromiseCapability = L.PermissionFlag = L.PasswordResponses = L.PasswordException = L.PageActionEventType = L.OPS = L.MissingPDFException = L.MAX_IMAGE_SIZE_TO_CACHE = L.LINE_FACTOR = L.LINE_DESCENT_FACTOR = L.InvalidPDFException = L.ImageKind = L.IDENTITY_MATRIX = L.FormatError = L.FeatureTest = L.FONT_IDENTITY_MATRIX = L.DocumentActionEventType = L.CMapCompressionType = L.BaseException = L.BASELINE_FACTOR = L.AnnotationType = L.AnnotationReplyType = L.AnnotationPrefix = L.AnnotationMode = L.AnnotationFlag = L.AnnotationFieldFlag = L.AnnotationEditorType = L.AnnotationEditorPrefix = L.AnnotationEditorParamsType = L.AnnotationBorderStyleType = L.AnnotationActionEventType = L.AbortException = void 0, L.assert = y, L.bytesToString = be, L.createValidAbsoluteUrl = j, L.getModificationDate = Ge, L.getUuid = Xe, L.getVerbosityLevel = M, L.info = I, L.isArrayBuffer = de, L.isArrayEqual = $e, L.isNodeJS = void 0, L.normalizeUnicode = tt, L.objectFromMap = qe, L.objectSize = Ae, L.setVerbosityLevel = R, L.shadow = A, L.string32 = fe, L.stringToBytes = le, L.stringToPDFString = _e, L.stringToUTF8String = Be, L.unreachable = T, L.utf8StringToString = ke, L.warn = E;
            const p = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
            L.isNodeJS = p;
            const n = [1, 0, 0, 1, 0, 0];
            L.IDENTITY_MATRIX = n;
            const t = [1e-3, 0, 0, 1e-3, 0, 0];
            L.FONT_IDENTITY_MATRIX = t;
            const l = 1e7;
            L.MAX_IMAGE_SIZE_TO_CACHE = l;
            const W = 1.35;
            L.LINE_FACTOR = W;
            const Q = 0.35;
            L.LINE_DESCENT_FACTOR = Q;
            const G = Q / W;
            L.BASELINE_FACTOR = G;
            const X = {
              ANY: 1,
              DISPLAY: 2,
              PRINT: 4,
              SAVE: 8,
              ANNOTATIONS_FORMS: 16,
              ANNOTATIONS_STORAGE: 32,
              ANNOTATIONS_DISABLE: 64,
              OPLIST: 256
            };
            L.RenderingIntentFlag = X;
            const N = {
              DISABLE: 0,
              ENABLE: 1,
              ENABLE_FORMS: 2,
              ENABLE_STORAGE: 3
            };
            L.AnnotationMode = N;
            const H = "pdfjs_internal_editor_";
            L.AnnotationEditorPrefix = H;
            const B = {
              DISABLE: -1,
              NONE: 0,
              FREETEXT: 3,
              STAMP: 13,
              INK: 15
            };
            L.AnnotationEditorType = B;
            const P = {
              RESIZE: 1,
              CREATE: 2,
              FREETEXT_SIZE: 11,
              FREETEXT_COLOR: 12,
              FREETEXT_OPACITY: 13,
              INK_COLOR: 21,
              INK_THICKNESS: 22,
              INK_OPACITY: 23
            };
            L.AnnotationEditorParamsType = P;
            const S = {
              PRINT: 4,
              MODIFY_CONTENTS: 8,
              COPY: 16,
              MODIFY_ANNOTATIONS: 32,
              FILL_INTERACTIVE_FORMS: 256,
              COPY_FOR_ACCESSIBILITY: 512,
              ASSEMBLE: 1024,
              PRINT_HIGH_QUALITY: 2048
            };
            L.PermissionFlag = S;
            const r = {
              FILL: 0,
              STROKE: 1,
              FILL_STROKE: 2,
              INVISIBLE: 3,
              FILL_ADD_TO_PATH: 4,
              STROKE_ADD_TO_PATH: 5,
              FILL_STROKE_ADD_TO_PATH: 6,
              ADD_TO_PATH: 7,
              FILL_STROKE_MASK: 3,
              ADD_TO_PATH_FLAG: 4
            };
            L.TextRenderingMode = r;
            const u = {
              GRAYSCALE_1BPP: 1,
              RGB_24BPP: 2,
              RGBA_32BPP: 3
            };
            L.ImageKind = u;
            const m = {
              TEXT: 1,
              LINK: 2,
              FREETEXT: 3,
              LINE: 4,
              SQUARE: 5,
              CIRCLE: 6,
              POLYGON: 7,
              POLYLINE: 8,
              HIGHLIGHT: 9,
              UNDERLINE: 10,
              SQUIGGLY: 11,
              STRIKEOUT: 12,
              STAMP: 13,
              CARET: 14,
              INK: 15,
              POPUP: 16,
              FILEATTACHMENT: 17,
              SOUND: 18,
              MOVIE: 19,
              WIDGET: 20,
              SCREEN: 21,
              PRINTERMARK: 22,
              TRAPNET: 23,
              WATERMARK: 24,
              THREED: 25,
              REDACT: 26
            };
            L.AnnotationType = m;
            const s = {
              GROUP: "Group",
              REPLY: "R"
            };
            L.AnnotationReplyType = s;
            const w = {
              INVISIBLE: 1,
              HIDDEN: 2,
              PRINT: 4,
              NOZOOM: 8,
              NOROTATE: 16,
              NOVIEW: 32,
              READONLY: 64,
              LOCKED: 128,
              TOGGLENOVIEW: 256,
              LOCKEDCONTENTS: 512
            };
            L.AnnotationFlag = w;
            const i = {
              READONLY: 1,
              REQUIRED: 2,
              NOEXPORT: 4,
              MULTILINE: 4096,
              PASSWORD: 8192,
              NOTOGGLETOOFF: 16384,
              RADIO: 32768,
              PUSHBUTTON: 65536,
              COMBO: 131072,
              EDIT: 262144,
              SORT: 524288,
              FILESELECT: 1048576,
              MULTISELECT: 2097152,
              DONOTSPELLCHECK: 4194304,
              DONOTSCROLL: 8388608,
              COMB: 16777216,
              RICHTEXT: 33554432,
              RADIOSINUNISON: 33554432,
              COMMITONSELCHANGE: 67108864
            };
            L.AnnotationFieldFlag = i;
            const o = {
              SOLID: 1,
              DASHED: 2,
              BEVELED: 3,
              INSET: 4,
              UNDERLINE: 5
            };
            L.AnnotationBorderStyleType = o;
            const b = {
              E: "Mouse Enter",
              X: "Mouse Exit",
              D: "Mouse Down",
              U: "Mouse Up",
              Fo: "Focus",
              Bl: "Blur",
              PO: "PageOpen",
              PC: "PageClose",
              PV: "PageVisible",
              PI: "PageInvisible",
              K: "Keystroke",
              F: "Format",
              V: "Validate",
              C: "Calculate"
            };
            L.AnnotationActionEventType = b;
            const g = {
              WC: "WillClose",
              WS: "WillSave",
              DS: "DidSave",
              WP: "WillPrint",
              DP: "DidPrint"
            };
            L.DocumentActionEventType = g;
            const c = {
              O: "PageOpen",
              C: "PageClose"
            };
            L.PageActionEventType = c;
            const v = {
              ERRORS: 0,
              WARNINGS: 1,
              INFOS: 5
            };
            L.VerbosityLevel = v;
            const k = {
              NONE: 0,
              BINARY: 1
            };
            L.CMapCompressionType = k;
            const a = {
              dependency: 1,
              setLineWidth: 2,
              setLineCap: 3,
              setLineJoin: 4,
              setMiterLimit: 5,
              setDash: 6,
              setRenderingIntent: 7,
              setFlatness: 8,
              setGState: 9,
              save: 10,
              restore: 11,
              transform: 12,
              moveTo: 13,
              lineTo: 14,
              curveTo: 15,
              curveTo2: 16,
              curveTo3: 17,
              closePath: 18,
              rectangle: 19,
              stroke: 20,
              closeStroke: 21,
              fill: 22,
              eoFill: 23,
              fillStroke: 24,
              eoFillStroke: 25,
              closeFillStroke: 26,
              closeEOFillStroke: 27,
              endPath: 28,
              clip: 29,
              eoClip: 30,
              beginText: 31,
              endText: 32,
              setCharSpacing: 33,
              setWordSpacing: 34,
              setHScale: 35,
              setLeading: 36,
              setFont: 37,
              setTextRenderingMode: 38,
              setTextRise: 39,
              moveText: 40,
              setLeadingMoveText: 41,
              setTextMatrix: 42,
              nextLine: 43,
              showText: 44,
              showSpacedText: 45,
              nextLineShowText: 46,
              nextLineSetSpacingShowText: 47,
              setCharWidth: 48,
              setCharWidthAndBounds: 49,
              setStrokeColorSpace: 50,
              setFillColorSpace: 51,
              setStrokeColor: 52,
              setStrokeColorN: 53,
              setFillColor: 54,
              setFillColorN: 55,
              setStrokeGray: 56,
              setFillGray: 57,
              setStrokeRGBColor: 58,
              setFillRGBColor: 59,
              setStrokeCMYKColor: 60,
              setFillCMYKColor: 61,
              shadingFill: 62,
              beginInlineImage: 63,
              beginImageData: 64,
              endInlineImage: 65,
              paintXObject: 66,
              markPoint: 67,
              markPointProps: 68,
              beginMarkedContent: 69,
              beginMarkedContentProps: 70,
              endMarkedContent: 71,
              beginCompat: 72,
              endCompat: 73,
              paintFormXObjectBegin: 74,
              paintFormXObjectEnd: 75,
              beginGroup: 76,
              endGroup: 77,
              beginAnnotation: 80,
              endAnnotation: 81,
              paintImageMaskXObject: 83,
              paintImageMaskXObjectGroup: 84,
              paintImageXObject: 85,
              paintInlineImageXObject: 86,
              paintInlineImageXObjectGroup: 87,
              paintImageXObjectRepeat: 88,
              paintImageMaskXObjectRepeat: 89,
              paintSolidColorImageMask: 90,
              constructPath: 91
            };
            L.OPS = a;
            const f = {
              NEED_PASSWORD: 1,
              INCORRECT_PASSWORD: 2
            };
            L.PasswordResponses = f;
            let C = v.WARNINGS;
            function R(We) {
              Number.isInteger(We) && (C = We);
            }
            function M() {
              return C;
            }
            function I(We) {
              C >= v.INFOS && console.log(`Info: ${We}`);
            }
            function E(We) {
              C >= v.WARNINGS && console.log(`Warning: ${We}`);
            }
            function T(We) {
              throw new Error(We);
            }
            function y(We, Ce) {
              We || T(Ce);
            }
            function D(We) {
              switch (We == null ? void 0 : We.protocol) {
                case "http:":
                case "https:":
                case "ftp:":
                case "mailto:":
                case "tel:":
                  return !0;
                default:
                  return !1;
              }
            }
            function j(We, Ce = null, Re = null) {
              if (!We)
                return null;
              try {
                if (Re && typeof We == "string") {
                  if (Re.addDefaultProtocol && We.startsWith("www.")) {
                    const bt = We.match(/\./g);
                    (bt == null ? void 0 : bt.length) >= 2 && (We = `http://${We}`);
                  }
                  if (Re.tryConvertEncoding)
                    try {
                      We = Be(We);
                    } catch {
                    }
                }
                const lt = Ce ? new URL(We, Ce) : new URL(We);
                if (D(lt))
                  return lt;
              } catch {
              }
              return null;
            }
            function A(We, Ce, Re, lt = !1) {
              return Object.defineProperty(We, Ce, {
                value: Re,
                enumerable: !lt,
                configurable: !0,
                writable: !1
              }), Re;
            }
            const d = function() {
              function Ce(Re, lt) {
                this.constructor === Ce && T("Cannot initialize BaseException."), this.message = Re, this.name = lt;
              }
              return Ce.prototype = new Error(), Ce.constructor = Ce, Ce;
            }();
            L.BaseException = d;
            class _ extends d {
              constructor(Ce, Re) {
                super(Ce, "PasswordException"), this.code = Re;
              }
            }
            L.PasswordException = _;
            class F extends d {
              constructor(Ce, Re) {
                super(Ce, "UnknownErrorException"), this.details = Re;
              }
            }
            L.UnknownErrorException = F;
            class U extends d {
              constructor(Ce) {
                super(Ce, "InvalidPDFException");
              }
            }
            L.InvalidPDFException = U;
            class V extends d {
              constructor(Ce) {
                super(Ce, "MissingPDFException");
              }
            }
            L.MissingPDFException = V;
            class $ extends d {
              constructor(Ce, Re) {
                super(Ce, "UnexpectedResponseException"), this.status = Re;
              }
            }
            L.UnexpectedResponseException = $;
            class re extends d {
              constructor(Ce) {
                super(Ce, "FormatError");
              }
            }
            L.FormatError = re;
            class ge extends d {
              constructor(Ce) {
                super(Ce, "AbortException");
              }
            }
            L.AbortException = ge;
            function be(We) {
              (typeof We != "object" || (We == null ? void 0 : We.length) === void 0) && T("Invalid argument for bytesToString");
              const Ce = We.length, Re = 8192;
              if (Ce < Re)
                return String.fromCharCode.apply(null, We);
              const lt = [];
              for (let bt = 0; bt < Ce; bt += Re) {
                const Et = Math.min(bt + Re, Ce), oe = We.subarray(bt, Et);
                lt.push(String.fromCharCode.apply(null, oe));
              }
              return lt.join("");
            }
            function le(We) {
              typeof We != "string" && T("Invalid argument for stringToBytes");
              const Ce = We.length, Re = new Uint8Array(Ce);
              for (let lt = 0; lt < Ce; ++lt)
                Re[lt] = We.charCodeAt(lt) & 255;
              return Re;
            }
            function fe(We) {
              return String.fromCharCode(We >> 24 & 255, We >> 16 & 255, We >> 8 & 255, We & 255);
            }
            function Ae(We) {
              return Object.keys(We).length;
            }
            function qe(We) {
              const Ce = /* @__PURE__ */ Object.create(null);
              for (const [Re, lt] of We)
                Ce[Re] = lt;
              return Ce;
            }
            function ye() {
              const We = new Uint8Array(4);
              return We[0] = 1, new Uint32Array(We.buffer, 0, 1)[0] === 1;
            }
            function ce() {
              try {
                return new Function(""), !0;
              } catch {
                return !1;
              }
            }
            class q {
              static get isLittleEndian() {
                return A(this, "isLittleEndian", ye());
              }
              static get isEvalSupported() {
                return A(this, "isEvalSupported", ce());
              }
              static get isOffscreenCanvasSupported() {
                return A(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
              }
              static get platform() {
                return typeof navigator > "u" ? A(this, "platform", {
                  isWin: !1,
                  isMac: !1
                }) : A(this, "platform", {
                  isWin: navigator.platform.includes("Win"),
                  isMac: navigator.platform.includes("Mac")
                });
              }
              static get isCSSRoundSupported() {
                var Ce, Re;
                return A(this, "isCSSRoundSupported", (Re = (Ce = globalThis.CSS) == null ? void 0 : Ce.supports) == null ? void 0 : Re.call(Ce, "width: round(1.5px, 1px)"));
              }
            }
            L.FeatureTest = q;
            const Z = [...Array(256).keys()].map((We) => We.toString(16).padStart(2, "0"));
            class pe {
              static makeHexColor(Ce, Re, lt) {
                return `#${Z[Ce]}${Z[Re]}${Z[lt]}`;
              }
              static scaleMinMax(Ce, Re) {
                let lt;
                Ce[0] ? (Ce[0] < 0 && (lt = Re[0], Re[0] = Re[1], Re[1] = lt), Re[0] *= Ce[0], Re[1] *= Ce[0], Ce[3] < 0 && (lt = Re[2], Re[2] = Re[3], Re[3] = lt), Re[2] *= Ce[3], Re[3] *= Ce[3]) : (lt = Re[0], Re[0] = Re[2], Re[2] = lt, lt = Re[1], Re[1] = Re[3], Re[3] = lt, Ce[1] < 0 && (lt = Re[2], Re[2] = Re[3], Re[3] = lt), Re[2] *= Ce[1], Re[3] *= Ce[1], Ce[2] < 0 && (lt = Re[0], Re[0] = Re[1], Re[1] = lt), Re[0] *= Ce[2], Re[1] *= Ce[2]), Re[0] += Ce[4], Re[1] += Ce[4], Re[2] += Ce[5], Re[3] += Ce[5];
              }
              static transform(Ce, Re) {
                return [Ce[0] * Re[0] + Ce[2] * Re[1], Ce[1] * Re[0] + Ce[3] * Re[1], Ce[0] * Re[2] + Ce[2] * Re[3], Ce[1] * Re[2] + Ce[3] * Re[3], Ce[0] * Re[4] + Ce[2] * Re[5] + Ce[4], Ce[1] * Re[4] + Ce[3] * Re[5] + Ce[5]];
              }
              static applyTransform(Ce, Re) {
                const lt = Ce[0] * Re[0] + Ce[1] * Re[2] + Re[4], bt = Ce[0] * Re[1] + Ce[1] * Re[3] + Re[5];
                return [lt, bt];
              }
              static applyInverseTransform(Ce, Re) {
                const lt = Re[0] * Re[3] - Re[1] * Re[2], bt = (Ce[0] * Re[3] - Ce[1] * Re[2] + Re[2] * Re[5] - Re[4] * Re[3]) / lt, Et = (-Ce[0] * Re[1] + Ce[1] * Re[0] + Re[4] * Re[1] - Re[5] * Re[0]) / lt;
                return [bt, Et];
              }
              static getAxialAlignedBoundingBox(Ce, Re) {
                const lt = this.applyTransform(Ce, Re), bt = this.applyTransform(Ce.slice(2, 4), Re), Et = this.applyTransform([Ce[0], Ce[3]], Re), oe = this.applyTransform([Ce[2], Ce[1]], Re);
                return [Math.min(lt[0], bt[0], Et[0], oe[0]), Math.min(lt[1], bt[1], Et[1], oe[1]), Math.max(lt[0], bt[0], Et[0], oe[0]), Math.max(lt[1], bt[1], Et[1], oe[1])];
              }
              static inverseTransform(Ce) {
                const Re = Ce[0] * Ce[3] - Ce[1] * Ce[2];
                return [Ce[3] / Re, -Ce[1] / Re, -Ce[2] / Re, Ce[0] / Re, (Ce[2] * Ce[5] - Ce[4] * Ce[3]) / Re, (Ce[4] * Ce[1] - Ce[5] * Ce[0]) / Re];
              }
              static singularValueDecompose2dScale(Ce) {
                const Re = [Ce[0], Ce[2], Ce[1], Ce[3]], lt = Ce[0] * Re[0] + Ce[1] * Re[2], bt = Ce[0] * Re[1] + Ce[1] * Re[3], Et = Ce[2] * Re[0] + Ce[3] * Re[2], oe = Ce[2] * Re[1] + Ce[3] * Re[3], He = (lt + oe) / 2, at = Math.sqrt((lt + oe) ** 2 - 4 * (lt * oe - Et * bt)) / 2, St = He + at || 1, yt = He - at || 1;
                return [Math.sqrt(St), Math.sqrt(yt)];
              }
              static normalizeRect(Ce) {
                const Re = Ce.slice(0);
                return Ce[0] > Ce[2] && (Re[0] = Ce[2], Re[2] = Ce[0]), Ce[1] > Ce[3] && (Re[1] = Ce[3], Re[3] = Ce[1]), Re;
              }
              static intersect(Ce, Re) {
                const lt = Math.max(Math.min(Ce[0], Ce[2]), Math.min(Re[0], Re[2])), bt = Math.min(Math.max(Ce[0], Ce[2]), Math.max(Re[0], Re[2]));
                if (lt > bt)
                  return null;
                const Et = Math.max(Math.min(Ce[1], Ce[3]), Math.min(Re[1], Re[3])), oe = Math.min(Math.max(Ce[1], Ce[3]), Math.max(Re[1], Re[3]));
                return Et > oe ? null : [lt, Et, bt, oe];
              }
              static bezierBoundingBox(Ce, Re, lt, bt, Et, oe, He, at) {
                const St = [], yt = [[], []];
                let dt, ie, te, we, De, Ve, Ye, Je;
                for (let Ut = 0; Ut < 2; ++Ut) {
                  if (Ut === 0 ? (ie = 6 * Ce - 12 * lt + 6 * Et, dt = -3 * Ce + 9 * lt - 9 * Et + 3 * He, te = 3 * lt - 3 * Ce) : (ie = 6 * Re - 12 * bt + 6 * oe, dt = -3 * Re + 9 * bt - 9 * oe + 3 * at, te = 3 * bt - 3 * Re), Math.abs(dt) < 1e-12) {
                    if (Math.abs(ie) < 1e-12)
                      continue;
                    we = -te / ie, 0 < we && we < 1 && St.push(we);
                    continue;
                  }
                  Ye = ie * ie - 4 * te * dt, Je = Math.sqrt(Ye), !(Ye < 0) && (De = (-ie + Je) / (2 * dt), 0 < De && De < 1 && St.push(De), Ve = (-ie - Je) / (2 * dt), 0 < Ve && Ve < 1 && St.push(Ve));
                }
                let Pt = St.length, mt;
                const pt = Pt;
                for (; Pt--; )
                  we = St[Pt], mt = 1 - we, yt[0][Pt] = mt * mt * mt * Ce + 3 * mt * mt * we * lt + 3 * mt * we * we * Et + we * we * we * He, yt[1][Pt] = mt * mt * mt * Re + 3 * mt * mt * we * bt + 3 * mt * we * we * oe + we * we * we * at;
                return yt[0][pt] = Ce, yt[1][pt] = Re, yt[0][pt + 1] = He, yt[1][pt + 1] = at, yt[0].length = yt[1].length = pt + 2, [Math.min(...yt[0]), Math.min(...yt[1]), Math.max(...yt[0]), Math.max(...yt[1])];
              }
            }
            L.Util = pe;
            const me = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
            function _e(We) {
              if (We[0] >= "ï") {
                let Re;
                if (We[0] === "þ" && We[1] === "ÿ" ? Re = "utf-16be" : We[0] === "ÿ" && We[1] === "þ" ? Re = "utf-16le" : We[0] === "ï" && We[1] === "»" && We[2] === "¿" && (Re = "utf-8"), Re)
                  try {
                    const lt = new TextDecoder(Re, {
                      fatal: !0
                    }), bt = le(We);
                    return lt.decode(bt);
                  } catch (lt) {
                    E(`stringToPDFString: "${lt}".`);
                  }
              }
              const Ce = [];
              for (let Re = 0, lt = We.length; Re < lt; Re++) {
                const bt = me[We.charCodeAt(Re)];
                Ce.push(bt ? String.fromCharCode(bt) : We.charAt(Re));
              }
              return Ce.join("");
            }
            function Be(We) {
              return decodeURIComponent(escape(We));
            }
            function ke(We) {
              return unescape(encodeURIComponent(We));
            }
            function de(We) {
              return typeof We == "object" && (We == null ? void 0 : We.byteLength) !== void 0;
            }
            function $e(We, Ce) {
              if (We.length !== Ce.length)
                return !1;
              for (let Re = 0, lt = We.length; Re < lt; Re++)
                if (We[Re] !== Ce[Re])
                  return !1;
              return !0;
            }
            function Ge(We = /* @__PURE__ */ new Date()) {
              return [We.getUTCFullYear().toString(), (We.getUTCMonth() + 1).toString().padStart(2, "0"), We.getUTCDate().toString().padStart(2, "0"), We.getUTCHours().toString().padStart(2, "0"), We.getUTCMinutes().toString().padStart(2, "0"), We.getUTCSeconds().toString().padStart(2, "0")].join("");
            }
            class st {
              constructor() {
                Ne(this, xt, !1);
                this.promise = new Promise((Ce, Re) => {
                  this.resolve = (lt) => {
                    je(this, xt, !0), Ce(lt);
                  }, this.reject = (lt) => {
                    je(this, xt, !0), Re(lt);
                  };
                });
              }
              get settled() {
                return x(this, xt);
              }
            }
            xt = new WeakMap(), L.PromiseCapability = st;
            let it = null, _t = null;
            function tt(We) {
              return it || (it = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, _t = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), We.replaceAll(it, (Ce, Re, lt) => Re ? Re.normalize("NFKC") : _t.get(lt));
            }
            function Xe() {
              if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.randomUUID) == "function")
                return crypto.randomUUID();
              const We = new Uint8Array(32);
              if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.getRandomValues) == "function")
                crypto.getRandomValues(We);
              else
                for (let Ce = 0; Ce < 32; Ce++)
                  We[Ce] = Math.floor(Math.random() * 255);
              return be(We);
            }
            const ct = "pdfjs_internal_id_";
            L.AnnotationPrefix = ct;
          },
          /* 2 */
          /***/
          (__unused_webpack_module, exports, __w_pdfjs_require__) => {
            var e, p, n, t, jr, pa, Q, G, X, N, H, B, P, S, r, ga, m, s, ri, i, o;
            Object.defineProperty(exports, "__esModule", {
              value: !0
            }), exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0, Object.defineProperty(exports, "SVGGraphics", {
              enumerable: !0,
              get: function() {
                return _displaySvg.SVGGraphics;
              }
            }), exports.build = void 0, exports.getDocument = getDocument, exports.version = void 0;
            var _util = __w_pdfjs_require__(1), _annotation_storage = __w_pdfjs_require__(3), _display_utils = __w_pdfjs_require__(6), _font_loader = __w_pdfjs_require__(9), _displayNode_utils = __w_pdfjs_require__(10), _canvas = __w_pdfjs_require__(11), _worker_options = __w_pdfjs_require__(14), _message_handler = __w_pdfjs_require__(15), _metadata = __w_pdfjs_require__(16), _optional_content_config = __w_pdfjs_require__(17), _transport_stream = __w_pdfjs_require__(18), _displayFetch_stream = __w_pdfjs_require__(19), _displayNetwork = __w_pdfjs_require__(22), _displayNode_stream = __w_pdfjs_require__(23), _displaySvg = __w_pdfjs_require__(24), _xfa_text = __w_pdfjs_require__(25);
            const DEFAULT_RANGE_CHUNK_SIZE = 65536, RENDERING_CANCELLED_TIMEOUT = 100, DELAYED_CLEANUP_TIMEOUT = 5e3, DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
            exports.DefaultCanvasFactory = DefaultCanvasFactory;
            const DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
            exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
            const DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;
            exports.DefaultFilterFactory = DefaultFilterFactory;
            const DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;
            exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
            function getDocument(g) {
              if (typeof g == "string" || g instanceof URL ? g = {
                url: g
              } : (0, _util.isArrayBuffer)(g) && (g = {
                data: g
              }), typeof g != "object")
                throw new Error("Invalid parameter in getDocument, need parameter object.");
              if (!g.url && !g.data && !g.range)
                throw new Error("Invalid parameter object: need either .data, .range or .url");
              const c = new PDFDocumentLoadingTask(), {
                docId: v
              } = c, k = g.url ? getUrlProp(g.url) : null, a = g.data ? getDataProp(g.data) : null, f = g.httpHeaders || null, C = g.withCredentials === !0, R = g.password ?? null, M = g.range instanceof PDFDataRangeTransport ? g.range : null, I = Number.isInteger(g.rangeChunkSize) && g.rangeChunkSize > 0 ? g.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
              let E = g.worker instanceof PDFWorker ? g.worker : null;
              const T = g.verbosity, y = typeof g.docBaseUrl == "string" && !(0, _display_utils.isDataScheme)(g.docBaseUrl) ? g.docBaseUrl : null, D = typeof g.cMapUrl == "string" ? g.cMapUrl : null, j = g.cMapPacked !== !1, A = g.CMapReaderFactory || DefaultCMapReaderFactory, d = typeof g.standardFontDataUrl == "string" ? g.standardFontDataUrl : null, _ = g.StandardFontDataFactory || DefaultStandardFontDataFactory, F = g.stopAtErrors !== !0, U = Number.isInteger(g.maxImageSize) && g.maxImageSize > -1 ? g.maxImageSize : -1, V = g.isEvalSupported !== !1, $ = typeof g.isOffscreenCanvasSupported == "boolean" ? g.isOffscreenCanvasSupported : !_util.isNodeJS, re = Number.isInteger(g.canvasMaxAreaInBytes) ? g.canvasMaxAreaInBytes : -1, ge = typeof g.disableFontFace == "boolean" ? g.disableFontFace : _util.isNodeJS, be = g.fontExtraProperties === !0, le = g.enableXfa === !0, fe = g.ownerDocument || globalThis.document, Ae = g.disableRange === !0, qe = g.disableStream === !0, ye = g.disableAutoFetch === !0, ce = g.pdfBug === !0, q = M ? M.length : g.length ?? NaN, Z = typeof g.useSystemFonts == "boolean" ? g.useSystemFonts : !_util.isNodeJS && !ge, pe = typeof g.useWorkerFetch == "boolean" ? g.useWorkerFetch : A === _display_utils.DOMCMapReaderFactory && _ === _display_utils.DOMStandardFontDataFactory && D && d && (0, _display_utils.isValidFetchUrl)(D, document.baseURI) && (0, _display_utils.isValidFetchUrl)(d, document.baseURI), me = g.canvasFactory || new DefaultCanvasFactory({
                ownerDocument: fe
              }), _e = g.filterFactory || new DefaultFilterFactory({
                docId: v,
                ownerDocument: fe
              }), Be = null;
              (0, _util.setVerbosityLevel)(T);
              const ke = {
                canvasFactory: me,
                filterFactory: _e
              };
              if (pe || (ke.cMapReaderFactory = new A({
                baseUrl: D,
                isCompressed: j
              }), ke.standardFontDataFactory = new _({
                baseUrl: d
              })), !E) {
                const Ge = {
                  verbosity: T,
                  port: _worker_options.GlobalWorkerOptions.workerPort
                };
                E = Ge.port ? PDFWorker.fromPort(Ge) : new PDFWorker(Ge), c._worker = E;
              }
              const de = {
                docId: v,
                apiVersion: "3.11.174",
                data: a,
                password: R,
                disableAutoFetch: ye,
                rangeChunkSize: I,
                length: q,
                docBaseUrl: y,
                enableXfa: le,
                evaluatorOptions: {
                  maxImageSize: U,
                  disableFontFace: ge,
                  ignoreErrors: F,
                  isEvalSupported: V,
                  isOffscreenCanvasSupported: $,
                  canvasMaxAreaInBytes: re,
                  fontExtraProperties: be,
                  useSystemFonts: Z,
                  cMapUrl: pe ? D : null,
                  standardFontDataUrl: pe ? d : null
                }
              }, $e = {
                ignoreErrors: F,
                isEvalSupported: V,
                disableFontFace: ge,
                fontExtraProperties: be,
                enableXfa: le,
                ownerDocument: fe,
                disableAutoFetch: ye,
                pdfBug: ce,
                styleElement: Be
              };
              return E.promise.then(function() {
                if (c.destroyed)
                  throw new Error("Loading aborted");
                const Ge = _fetchDocument(E, de), st = new Promise(function(it) {
                  let _t;
                  M ? _t = new _transport_stream.PDFDataTransportStream({
                    length: q,
                    initialData: M.initialData,
                    progressiveDone: M.progressiveDone,
                    contentDispositionFilename: M.contentDispositionFilename,
                    disableRange: Ae,
                    disableStream: qe
                  }, M) : a || (_t = ((Xe) => _util.isNodeJS ? new _displayNode_stream.PDFNodeStream(Xe) : (0, _display_utils.isValidFetchUrl)(Xe.url) ? new _displayFetch_stream.PDFFetchStream(Xe) : new _displayNetwork.PDFNetworkStream(Xe))({
                    url: k,
                    length: q,
                    httpHeaders: f,
                    withCredentials: C,
                    rangeChunkSize: I,
                    disableRange: Ae,
                    disableStream: qe
                  })), it(_t);
                });
                return Promise.all([Ge, st]).then(function([it, _t]) {
                  if (c.destroyed)
                    throw new Error("Loading aborted");
                  const tt = new _message_handler.MessageHandler(v, it, E.port), Xe = new WorkerTransport(tt, c, _t, $e, ke);
                  c._transport = Xe, tt.send("Ready", null);
                });
              }).catch(c._capability.reject), c;
            }
            async function _fetchDocument(g, c) {
              if (g.destroyed)
                throw new Error("Worker was destroyed");
              const v = await g.messageHandler.sendWithPromise("GetDocRequest", c, c.data ? [c.data.buffer] : null);
              if (g.destroyed)
                throw new Error("Worker was destroyed");
              return v;
            }
            function getUrlProp(g) {
              if (g instanceof URL)
                return g.href;
              try {
                return new URL(g, window.location).href;
              } catch {
                if (_util.isNodeJS && typeof g == "string")
                  return g;
              }
              throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
            }
            function getDataProp(g) {
              if (_util.isNodeJS && typeof Buffer < "u" && g instanceof Buffer)
                throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
              if (g instanceof Uint8Array && g.byteLength === g.buffer.byteLength)
                return g;
              if (typeof g == "string")
                return (0, _util.stringToBytes)(g);
              if (typeof g == "object" && !isNaN(g == null ? void 0 : g.length) || (0, _util.isArrayBuffer)(g))
                return new Uint8Array(g);
              throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
            }
            const L = class L {
              constructor() {
                this._capability = new _util.PromiseCapability(), this._transport = null, this._worker = null, this.docId = `d${Zr(L, e)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
              }
              get promise() {
                return this._capability.promise;
              }
              async destroy() {
                var c, v, k;
                this.destroyed = !0;
                try {
                  (c = this._worker) != null && c.port && (this._worker._pendingDestroy = !0), await ((v = this._transport) == null ? void 0 : v.destroy());
                } catch (a) {
                  throw (k = this._worker) != null && k.port && delete this._worker._pendingDestroy, a;
                }
                this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
              }
            };
            e = new WeakMap(), Ne(L, e, 0);
            let PDFDocumentLoadingTask = L;
            exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
            class PDFDataRangeTransport {
              constructor(c, v, k = !1, a = null) {
                this.length = c, this.initialData = v, this.progressiveDone = k, this.contentDispositionFilename = a, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = new _util.PromiseCapability();
              }
              addRangeListener(c) {
                this._rangeListeners.push(c);
              }
              addProgressListener(c) {
                this._progressListeners.push(c);
              }
              addProgressiveReadListener(c) {
                this._progressiveReadListeners.push(c);
              }
              addProgressiveDoneListener(c) {
                this._progressiveDoneListeners.push(c);
              }
              onDataRange(c, v) {
                for (const k of this._rangeListeners)
                  k(c, v);
              }
              onDataProgress(c, v) {
                this._readyCapability.promise.then(() => {
                  for (const k of this._progressListeners)
                    k(c, v);
                });
              }
              onDataProgressiveRead(c) {
                this._readyCapability.promise.then(() => {
                  for (const v of this._progressiveReadListeners)
                    v(c);
                });
              }
              onDataProgressiveDone() {
                this._readyCapability.promise.then(() => {
                  for (const c of this._progressiveDoneListeners)
                    c();
                });
              }
              transportReady() {
                this._readyCapability.resolve();
              }
              requestDataRange(c, v) {
                (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
              }
              abort() {
              }
            }
            exports.PDFDataRangeTransport = PDFDataRangeTransport;
            class PDFDocumentProxy {
              constructor(c, v) {
                this._pdfInfo = c, this._transport = v, Object.defineProperty(this, "getJavaScript", {
                  value: () => ((0, _display_utils.deprecated)("`PDFDocumentProxy.getJavaScript`, please use `PDFDocumentProxy.getJSActions` instead."), this.getJSActions().then((k) => {
                    if (!k)
                      return k;
                    const a = [];
                    for (const f in k)
                      a.push(...k[f]);
                    return a;
                  }))
                });
              }
              get annotationStorage() {
                return this._transport.annotationStorage;
              }
              get filterFactory() {
                return this._transport.filterFactory;
              }
              get numPages() {
                return this._pdfInfo.numPages;
              }
              get fingerprints() {
                return this._pdfInfo.fingerprints;
              }
              get isPureXfa() {
                return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
              }
              get allXfaHtml() {
                return this._transport._htmlForXfa;
              }
              getPage(c) {
                return this._transport.getPage(c);
              }
              getPageIndex(c) {
                return this._transport.getPageIndex(c);
              }
              getDestinations() {
                return this._transport.getDestinations();
              }
              getDestination(c) {
                return this._transport.getDestination(c);
              }
              getPageLabels() {
                return this._transport.getPageLabels();
              }
              getPageLayout() {
                return this._transport.getPageLayout();
              }
              getPageMode() {
                return this._transport.getPageMode();
              }
              getViewerPreferences() {
                return this._transport.getViewerPreferences();
              }
              getOpenAction() {
                return this._transport.getOpenAction();
              }
              getAttachments() {
                return this._transport.getAttachments();
              }
              getJSActions() {
                return this._transport.getDocJSActions();
              }
              getOutline() {
                return this._transport.getOutline();
              }
              getOptionalContentConfig() {
                return this._transport.getOptionalContentConfig();
              }
              getPermissions() {
                return this._transport.getPermissions();
              }
              getMetadata() {
                return this._transport.getMetadata();
              }
              getMarkInfo() {
                return this._transport.getMarkInfo();
              }
              getData() {
                return this._transport.getData();
              }
              saveDocument() {
                return this._transport.saveDocument();
              }
              getDownloadInfo() {
                return this._transport.downloadInfoCapability.promise;
              }
              cleanup(c = !1) {
                return this._transport.startCleanup(c || this.isPureXfa);
              }
              destroy() {
                return this.loadingTask.destroy();
              }
              get loadingParams() {
                return this._transport.loadingParams;
              }
              get loadingTask() {
                return this._transport.loadingTask;
              }
              getFieldObjects() {
                return this._transport.getFieldObjects();
              }
              hasJSActions() {
                return this._transport.hasJSActions();
              }
              getCalculationOrderIds() {
                return this._transport.getCalculationOrderIds();
              }
            }
            exports.PDFDocumentProxy = PDFDocumentProxy;
            class PDFPageProxy {
              constructor(c, v, k, a = !1) {
                Ne(this, t);
                Ne(this, p, null);
                Ne(this, n, !1);
                this._pageIndex = c, this._pageInfo = v, this._transport = k, this._stats = a ? new _display_utils.StatTimer() : null, this._pdfBug = a, this.commonObjs = k.commonObjs, this.objs = new PDFObjects(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
              }
              get pageNumber() {
                return this._pageIndex + 1;
              }
              get rotate() {
                return this._pageInfo.rotate;
              }
              get ref() {
                return this._pageInfo.ref;
              }
              get userUnit() {
                return this._pageInfo.userUnit;
              }
              get view() {
                return this._pageInfo.view;
              }
              getViewport({
                scale: c,
                rotation: v = this.rotate,
                offsetX: k = 0,
                offsetY: a = 0,
                dontFlip: f = !1
              } = {}) {
                return new _display_utils.PageViewport({
                  viewBox: this.view,
                  scale: c,
                  rotation: v,
                  offsetX: k,
                  offsetY: a,
                  dontFlip: f
                });
              }
              getAnnotations({
                intent: c = "display"
              } = {}) {
                const v = this._transport.getRenderingIntent(c);
                return this._transport.getAnnotations(this._pageIndex, v.renderingIntent);
              }
              getJSActions() {
                return this._transport.getPageJSActions(this._pageIndex);
              }
              get filterFactory() {
                return this._transport.filterFactory;
              }
              get isPureXfa() {
                return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
              }
              async getXfa() {
                var c;
                return ((c = this._transport._htmlForXfa) == null ? void 0 : c.children[this._pageIndex]) || null;
              }
              render({
                canvasContext: c,
                viewport: v,
                intent: k = "display",
                annotationMode: a = _util.AnnotationMode.ENABLE,
                transform: f = null,
                background: C = null,
                optionalContentConfigPromise: R = null,
                annotationCanvasMap: M = null,
                pageColors: I = null,
                printAnnotationStorage: E = null
              }) {
                var _, F;
                (_ = this._stats) == null || _.time("Overall");
                const T = this._transport.getRenderingIntent(k, a, E);
                je(this, n, !1), Te(this, t, pa).call(this), R || (R = this._transport.getOptionalContentConfig());
                let y = this._intentStates.get(T.cacheKey);
                y || (y = /* @__PURE__ */ Object.create(null), this._intentStates.set(T.cacheKey, y)), y.streamReaderCancelTimeout && (clearTimeout(y.streamReaderCancelTimeout), y.streamReaderCancelTimeout = null);
                const D = !!(T.renderingIntent & _util.RenderingIntentFlag.PRINT);
                y.displayReadyCapability || (y.displayReadyCapability = new _util.PromiseCapability(), y.operatorList = {
                  fnArray: [],
                  argsArray: [],
                  lastChunk: !1,
                  separateAnnots: null
                }, (F = this._stats) == null || F.time("Page Request"), this._pumpOperatorList(T));
                const j = (U) => {
                  var V, $;
                  y.renderTasks.delete(A), (this._maybeCleanupAfterRender || D) && je(this, n, !0), Te(this, t, jr).call(this, !D), U ? (A.capability.reject(U), this._abortOperatorList({
                    intentState: y,
                    reason: U instanceof Error ? U : new Error(U)
                  })) : A.capability.resolve(), (V = this._stats) == null || V.timeEnd("Rendering"), ($ = this._stats) == null || $.timeEnd("Overall");
                }, A = new InternalRenderTask({
                  callback: j,
                  params: {
                    canvasContext: c,
                    viewport: v,
                    transform: f,
                    background: C
                  },
                  objs: this.objs,
                  commonObjs: this.commonObjs,
                  annotationCanvasMap: M,
                  operatorList: y.operatorList,
                  pageIndex: this._pageIndex,
                  canvasFactory: this._transport.canvasFactory,
                  filterFactory: this._transport.filterFactory,
                  useRequestAnimationFrame: !D,
                  pdfBug: this._pdfBug,
                  pageColors: I
                });
                (y.renderTasks || (y.renderTasks = /* @__PURE__ */ new Set())).add(A);
                const d = A.task;
                return Promise.all([y.displayReadyCapability.promise, R]).then(([U, V]) => {
                  var $;
                  if (this.destroyed) {
                    j();
                    return;
                  }
                  ($ = this._stats) == null || $.time("Rendering"), A.initializeGraphics({
                    transparency: U,
                    optionalContentConfig: V
                  }), A.operatorListChanged();
                }).catch(j), d;
              }
              getOperatorList({
                intent: c = "display",
                annotationMode: v = _util.AnnotationMode.ENABLE,
                printAnnotationStorage: k = null
              } = {}) {
                var M;
                function a() {
                  C.operatorList.lastChunk && (C.opListReadCapability.resolve(C.operatorList), C.renderTasks.delete(R));
                }
                const f = this._transport.getRenderingIntent(c, v, k, !0);
                let C = this._intentStates.get(f.cacheKey);
                C || (C = /* @__PURE__ */ Object.create(null), this._intentStates.set(f.cacheKey, C));
                let R;
                return C.opListReadCapability || (R = /* @__PURE__ */ Object.create(null), R.operatorListChanged = a, C.opListReadCapability = new _util.PromiseCapability(), (C.renderTasks || (C.renderTasks = /* @__PURE__ */ new Set())).add(R), C.operatorList = {
                  fnArray: [],
                  argsArray: [],
                  lastChunk: !1,
                  separateAnnots: null
                }, (M = this._stats) == null || M.time("Page Request"), this._pumpOperatorList(f)), C.opListReadCapability.promise;
              }
              streamTextContent({
                includeMarkedContent: c = !1,
                disableNormalization: v = !1
              } = {}) {
                return this._transport.messageHandler.sendWithStream("GetTextContent", {
                  pageIndex: this._pageIndex,
                  includeMarkedContent: c === !0,
                  disableNormalization: v === !0
                }, {
                  highWaterMark: 100,
                  size(a) {
                    return a.items.length;
                  }
                });
              }
              getTextContent(c = {}) {
                if (this._transport._htmlForXfa)
                  return this.getXfa().then((k) => _xfa_text.XfaText.textContent(k));
                const v = this.streamTextContent(c);
                return new Promise(function(k, a) {
                  function f() {
                    C.read().then(function({
                      value: M,
                      done: I
                    }) {
                      if (I) {
                        k(R);
                        return;
                      }
                      Object.assign(R.styles, M.styles), R.items.push(...M.items), f();
                    }, a);
                  }
                  const C = v.getReader(), R = {
                    items: [],
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  f();
                });
              }
              getStructTree() {
                return this._transport.getStructTree(this._pageIndex);
              }
              _destroy() {
                this.destroyed = !0;
                const c = [];
                for (const v of this._intentStates.values())
                  if (this._abortOperatorList({
                    intentState: v,
                    reason: new Error("Page was destroyed."),
                    force: !0
                  }), !v.opListReadCapability)
                    for (const k of v.renderTasks)
                      c.push(k.completed), k.cancel();
                return this.objs.clear(), je(this, n, !1), Te(this, t, pa).call(this), Promise.all(c);
              }
              cleanup(c = !1) {
                je(this, n, !0);
                const v = Te(this, t, jr).call(this, !1);
                return c && v && this._stats && (this._stats = new _display_utils.StatTimer()), v;
              }
              _startRenderPage(c, v) {
                var a, f;
                const k = this._intentStates.get(v);
                k && ((a = this._stats) == null || a.timeEnd("Page Request"), (f = k.displayReadyCapability) == null || f.resolve(c));
              }
              _renderPageChunk(c, v) {
                for (let k = 0, a = c.length; k < a; k++)
                  v.operatorList.fnArray.push(c.fnArray[k]), v.operatorList.argsArray.push(c.argsArray[k]);
                v.operatorList.lastChunk = c.lastChunk, v.operatorList.separateAnnots = c.separateAnnots;
                for (const k of v.renderTasks)
                  k.operatorListChanged();
                c.lastChunk && Te(this, t, jr).call(this, !0);
              }
              _pumpOperatorList({
                renderingIntent: c,
                cacheKey: v,
                annotationStorageSerializable: k
              }) {
                const {
                  map: a,
                  transfers: f
                } = k, R = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                  pageIndex: this._pageIndex,
                  intent: c,
                  cacheKey: v,
                  annotationStorage: a
                }, f).getReader(), M = this._intentStates.get(v);
                M.streamReader = R;
                const I = () => {
                  R.read().then(({
                    value: E,
                    done: T
                  }) => {
                    if (T) {
                      M.streamReader = null;
                      return;
                    }
                    this._transport.destroyed || (this._renderPageChunk(E, M), I());
                  }, (E) => {
                    if (M.streamReader = null, !this._transport.destroyed) {
                      if (M.operatorList) {
                        M.operatorList.lastChunk = !0;
                        for (const T of M.renderTasks)
                          T.operatorListChanged();
                        Te(this, t, jr).call(this, !0);
                      }
                      if (M.displayReadyCapability)
                        M.displayReadyCapability.reject(E);
                      else if (M.opListReadCapability)
                        M.opListReadCapability.reject(E);
                      else
                        throw E;
                    }
                  });
                };
                I();
              }
              _abortOperatorList({
                intentState: c,
                reason: v,
                force: k = !1
              }) {
                if (c.streamReader) {
                  if (c.streamReaderCancelTimeout && (clearTimeout(c.streamReaderCancelTimeout), c.streamReaderCancelTimeout = null), !k) {
                    if (c.renderTasks.size > 0)
                      return;
                    if (v instanceof _display_utils.RenderingCancelledException) {
                      let a = RENDERING_CANCELLED_TIMEOUT;
                      v.extraDelay > 0 && v.extraDelay < 1e3 && (a += v.extraDelay), c.streamReaderCancelTimeout = setTimeout(() => {
                        c.streamReaderCancelTimeout = null, this._abortOperatorList({
                          intentState: c,
                          reason: v,
                          force: !0
                        });
                      }, a);
                      return;
                    }
                  }
                  if (c.streamReader.cancel(new _util.AbortException(v.message)).catch(() => {
                  }), c.streamReader = null, !this._transport.destroyed) {
                    for (const [a, f] of this._intentStates)
                      if (f === c) {
                        this._intentStates.delete(a);
                        break;
                      }
                    this.cleanup();
                  }
                }
              }
              get stats() {
                return this._stats;
              }
            }
            p = new WeakMap(), n = new WeakMap(), t = new WeakSet(), jr = function(c = !1) {
              if (Te(this, t, pa).call(this), !x(this, n) || this.destroyed)
                return !1;
              if (c)
                return je(this, p, setTimeout(() => {
                  je(this, p, null), Te(this, t, jr).call(this, !1);
                }, DELAYED_CLEANUP_TIMEOUT)), !1;
              for (const {
                renderTasks: v,
                operatorList: k
              } of this._intentStates.values())
                if (v.size > 0 || !k.lastChunk)
                  return !1;
              return this._intentStates.clear(), this.objs.clear(), je(this, n, !1), !0;
            }, pa = function() {
              x(this, p) && (clearTimeout(x(this, p)), je(this, p, null));
            }, exports.PDFPageProxy = PDFPageProxy;
            class LoopbackPort {
              constructor() {
                Ne(this, Q, /* @__PURE__ */ new Set());
                Ne(this, G, Promise.resolve());
              }
              postMessage(c, v) {
                const k = {
                  data: structuredClone(c, v ? {
                    transfer: v
                  } : null)
                };
                x(this, G).then(() => {
                  for (const a of x(this, Q))
                    a.call(this, k);
                });
              }
              addEventListener(c, v) {
                x(this, Q).add(v);
              }
              removeEventListener(c, v) {
                x(this, Q).delete(v);
              }
              terminate() {
                x(this, Q).clear();
              }
            }
            Q = new WeakMap(), G = new WeakMap(), exports.LoopbackPort = LoopbackPort;
            const PDFWorkerUtil = {
              isWorkerDisabled: !1,
              fallbackWorkerSrc: null,
              fakeWorkerId: 0
            };
            exports.PDFWorkerUtil = PDFWorkerUtil;
            {
              if (_util.isNodeJS && typeof commonjsRequire == "function")
                PDFWorkerUtil.isWorkerDisabled = !0, PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
              else if (typeof document == "object") {
                const g = (X = document == null ? void 0 : document.currentScript) == null ? void 0 : X.src;
                g && (PDFWorkerUtil.fallbackWorkerSrc = g.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"));
              }
              PDFWorkerUtil.isSameOrigin = function(g, c) {
                let v;
                try {
                  if (v = new URL(g), !v.origin || v.origin === "null")
                    return !1;
                } catch {
                  return !1;
                }
                const k = new URL(c, v);
                return v.origin === k.origin;
              }, PDFWorkerUtil.createCDNWrapper = function(g) {
                const c = `importScripts("${g}");`;
                return URL.createObjectURL(new Blob([c]));
              };
            }
            const _PDFWorker = class _PDFWorker {
              constructor({
                name: g = null,
                port: c = null,
                verbosity: v = (0, _util.getVerbosityLevel)()
              } = {}) {
                var k;
                if (this.name = g, this.destroyed = !1, this.verbosity = v, this._readyCapability = new _util.PromiseCapability(), this._port = null, this._webWorker = null, this._messageHandler = null, c) {
                  if ((k = x(_PDFWorker, N)) != null && k.has(c))
                    throw new Error("Cannot use more than one PDFWorker per port.");
                  (x(_PDFWorker, N) || je(_PDFWorker, N, /* @__PURE__ */ new WeakMap())).set(c, this), this._initializeFromPort(c);
                  return;
                }
                this._initialize();
              }
              get promise() {
                return this._readyCapability.promise;
              }
              get port() {
                return this._port;
              }
              get messageHandler() {
                return this._messageHandler;
              }
              _initializeFromPort(g) {
                this._port = g, this._messageHandler = new _message_handler.MessageHandler("main", "worker", g), this._messageHandler.on("ready", function() {
                }), this._readyCapability.resolve(), this._messageHandler.send("configure", {
                  verbosity: this.verbosity
                });
              }
              _initialize() {
                if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                  let {
                    workerSrc: g
                  } = _PDFWorker;
                  try {
                    PDFWorkerUtil.isSameOrigin(window.location.href, g) || (g = PDFWorkerUtil.createCDNWrapper(new URL(g, window.location).href));
                    const c = new Worker(g), v = new _message_handler.MessageHandler("main", "worker", c), k = () => {
                      c.removeEventListener("error", a), v.destroy(), c.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
                    }, a = () => {
                      this._webWorker || k();
                    };
                    c.addEventListener("error", a), v.on("test", (C) => {
                      if (c.removeEventListener("error", a), this.destroyed) {
                        k();
                        return;
                      }
                      C ? (this._messageHandler = v, this._port = c, this._webWorker = c, this._readyCapability.resolve(), v.send("configure", {
                        verbosity: this.verbosity
                      })) : (this._setupFakeWorker(), v.destroy(), c.terminate());
                    }), v.on("ready", (C) => {
                      if (c.removeEventListener("error", a), this.destroyed) {
                        k();
                        return;
                      }
                      try {
                        f();
                      } catch {
                        this._setupFakeWorker();
                      }
                    });
                    const f = () => {
                      const C = new Uint8Array();
                      v.send("test", C, [C.buffer]);
                    };
                    f();
                    return;
                  } catch {
                    (0, _util.info)("The worker has been disabled.");
                  }
                }
                this._setupFakeWorker();
              }
              _setupFakeWorker() {
                PDFWorkerUtil.isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), PDFWorkerUtil.isWorkerDisabled = !0), _PDFWorker._setupFakeWorkerGlobal.then((g) => {
                  if (this.destroyed) {
                    this._readyCapability.reject(new Error("Worker was destroyed"));
                    return;
                  }
                  const c = new LoopbackPort();
                  this._port = c;
                  const v = `fake${PDFWorkerUtil.fakeWorkerId++}`, k = new _message_handler.MessageHandler(v + "_worker", v, c);
                  g.setup(k, c);
                  const a = new _message_handler.MessageHandler(v, v + "_worker", c);
                  this._messageHandler = a, this._readyCapability.resolve(), a.send("configure", {
                    verbosity: this.verbosity
                  });
                }).catch((g) => {
                  this._readyCapability.reject(new Error(`Setting up fake worker failed: "${g.message}".`));
                });
              }
              destroy() {
                var g;
                this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (g = x(_PDFWorker, N)) == null || g.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
              }
              static fromPort(g) {
                var v;
                if (!(g != null && g.port))
                  throw new Error("PDFWorker.fromPort - invalid method signature.");
                const c = (v = x(this, N)) == null ? void 0 : v.get(g.port);
                if (c) {
                  if (c._pendingDestroy)
                    throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
                  return c;
                }
                return new _PDFWorker(g);
              }
              static get workerSrc() {
                if (_worker_options.GlobalWorkerOptions.workerSrc)
                  return _worker_options.GlobalWorkerOptions.workerSrc;
                if (PDFWorkerUtil.fallbackWorkerSrc !== null)
                  return _util.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'), PDFWorkerUtil.fallbackWorkerSrc;
                throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
              }
              static get _mainThreadWorkerMessageHandler() {
                var g;
                try {
                  return ((g = globalThis.pdfjsWorker) == null ? void 0 : g.WorkerMessageHandler) || null;
                } catch {
                  return null;
                }
              }
              static get _setupFakeWorkerGlobal() {
                const loader = async () => {
                  const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                  if (mainWorkerMessageHandler)
                    return mainWorkerMessageHandler;
                  if (_util.isNodeJS && typeof commonjsRequire == "function") {
                    const worker = eval("require")(this.workerSrc);
                    return worker.WorkerMessageHandler;
                  }
                  return await (0, _display_utils.loadScript)(this.workerSrc), window.pdfjsWorker.WorkerMessageHandler;
                };
                return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
              }
            };
            N = new WeakMap(), Ne(_PDFWorker, N);
            let PDFWorker = _PDFWorker;
            exports.PDFWorker = PDFWorker;
            class WorkerTransport {
              constructor(c, v, k, a, f) {
                Ne(this, r);
                Ne(this, H, /* @__PURE__ */ new Map());
                Ne(this, B, /* @__PURE__ */ new Map());
                Ne(this, P, /* @__PURE__ */ new Map());
                Ne(this, S, null);
                this.messageHandler = c, this.loadingTask = v, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({
                  ownerDocument: a.ownerDocument,
                  styleElement: a.styleElement
                }), this._params = a, this.canvasFactory = f.canvasFactory, this.filterFactory = f.filterFactory, this.cMapReaderFactory = f.cMapReaderFactory, this.standardFontDataFactory = f.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = k, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = new _util.PromiseCapability(), this.setupMessageHandler();
              }
              get annotationStorage() {
                return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
              }
              getRenderingIntent(c, v = _util.AnnotationMode.ENABLE, k = null, a = !1) {
                let f = _util.RenderingIntentFlag.DISPLAY, C = _annotation_storage.SerializableEmpty;
                switch (c) {
                  case "any":
                    f = _util.RenderingIntentFlag.ANY;
                    break;
                  case "display":
                    break;
                  case "print":
                    f = _util.RenderingIntentFlag.PRINT;
                    break;
                  default:
                    (0, _util.warn)(`getRenderingIntent - invalid intent: ${c}`);
                }
                switch (v) {
                  case _util.AnnotationMode.DISABLE:
                    f += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                    break;
                  case _util.AnnotationMode.ENABLE:
                    break;
                  case _util.AnnotationMode.ENABLE_FORMS:
                    f += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                    break;
                  case _util.AnnotationMode.ENABLE_STORAGE:
                    f += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, C = (f & _util.RenderingIntentFlag.PRINT && k instanceof _annotation_storage.PrintAnnotationStorage ? k : this.annotationStorage).serializable;
                    break;
                  default:
                    (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${v}`);
                }
                return a && (f += _util.RenderingIntentFlag.OPLIST), {
                  renderingIntent: f,
                  cacheKey: `${f}_${C.hash}`,
                  annotationStorageSerializable: C
                };
              }
              destroy() {
                var k;
                if (this.destroyCapability)
                  return this.destroyCapability.promise;
                this.destroyed = !0, this.destroyCapability = new _util.PromiseCapability(), (k = x(this, S)) == null || k.reject(new Error("Worker was destroyed during onPassword callback"));
                const c = [];
                for (const a of x(this, B).values())
                  c.push(a._destroy());
                x(this, B).clear(), x(this, P).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
                const v = this.messageHandler.sendWithPromise("Terminate", null);
                return c.push(v), Promise.all(c).then(() => {
                  var a;
                  this.commonObjs.clear(), this.fontLoader.clear(), x(this, H).clear(), this.filterFactory.destroy(), (a = this._networkStream) == null || a.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
                }, this.destroyCapability.reject), this.destroyCapability.promise;
              }
              setupMessageHandler() {
                const {
                  messageHandler: c,
                  loadingTask: v
                } = this;
                c.on("GetReader", (k, a) => {
                  (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (f) => {
                    this._lastProgress = {
                      loaded: f.loaded,
                      total: f.total
                    };
                  }, a.onPull = () => {
                    this._fullReader.read().then(function({
                      value: f,
                      done: C
                    }) {
                      if (C) {
                        a.close();
                        return;
                      }
                      (0, _util.assert)(f instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), a.enqueue(new Uint8Array(f), 1, [f]);
                    }).catch((f) => {
                      a.error(f);
                    });
                  }, a.onCancel = (f) => {
                    this._fullReader.cancel(f), a.ready.catch((C) => {
                      if (!this.destroyed)
                        throw C;
                    });
                  };
                }), c.on("ReaderHeadersReady", (k) => {
                  const a = new _util.PromiseCapability(), f = this._fullReader;
                  return f.headersReady.then(() => {
                    var C;
                    (!f.isStreamingSupported || !f.isRangeSupported) && (this._lastProgress && ((C = v.onProgress) == null || C.call(v, this._lastProgress)), f.onProgress = (R) => {
                      var M;
                      (M = v.onProgress) == null || M.call(v, {
                        loaded: R.loaded,
                        total: R.total
                      });
                    }), a.resolve({
                      isStreamingSupported: f.isStreamingSupported,
                      isRangeSupported: f.isRangeSupported,
                      contentLength: f.contentLength
                    });
                  }, a.reject), a.promise;
                }), c.on("GetRangeReader", (k, a) => {
                  (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                  const f = this._networkStream.getRangeReader(k.begin, k.end);
                  if (!f) {
                    a.close();
                    return;
                  }
                  a.onPull = () => {
                    f.read().then(function({
                      value: C,
                      done: R
                    }) {
                      if (R) {
                        a.close();
                        return;
                      }
                      (0, _util.assert)(C instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), a.enqueue(new Uint8Array(C), 1, [C]);
                    }).catch((C) => {
                      a.error(C);
                    });
                  }, a.onCancel = (C) => {
                    f.cancel(C), a.ready.catch((R) => {
                      if (!this.destroyed)
                        throw R;
                    });
                  };
                }), c.on("GetDoc", ({
                  pdfInfo: k
                }) => {
                  this._numPages = k.numPages, this._htmlForXfa = k.htmlForXfa, delete k.htmlForXfa, v._capability.resolve(new PDFDocumentProxy(k, this));
                }), c.on("DocException", function(k) {
                  let a;
                  switch (k.name) {
                    case "PasswordException":
                      a = new _util.PasswordException(k.message, k.code);
                      break;
                    case "InvalidPDFException":
                      a = new _util.InvalidPDFException(k.message);
                      break;
                    case "MissingPDFException":
                      a = new _util.MissingPDFException(k.message);
                      break;
                    case "UnexpectedResponseException":
                      a = new _util.UnexpectedResponseException(k.message, k.status);
                      break;
                    case "UnknownErrorException":
                      a = new _util.UnknownErrorException(k.message, k.details);
                      break;
                    default:
                      (0, _util.unreachable)("DocException - expected a valid Error.");
                  }
                  v._capability.reject(a);
                }), c.on("PasswordRequest", (k) => {
                  if (je(this, S, new _util.PromiseCapability()), v.onPassword) {
                    const a = (f) => {
                      f instanceof Error ? x(this, S).reject(f) : x(this, S).resolve({
                        password: f
                      });
                    };
                    try {
                      v.onPassword(a, k.code);
                    } catch (f) {
                      x(this, S).reject(f);
                    }
                  } else
                    x(this, S).reject(new _util.PasswordException(k.message, k.code));
                  return x(this, S).promise;
                }), c.on("DataLoaded", (k) => {
                  var a;
                  (a = v.onProgress) == null || a.call(v, {
                    loaded: k.length,
                    total: k.length
                  }), this.downloadInfoCapability.resolve(k);
                }), c.on("StartRenderPage", (k) => {
                  if (this.destroyed)
                    return;
                  x(this, B).get(k.pageIndex)._startRenderPage(k.transparency, k.cacheKey);
                }), c.on("commonobj", ([k, a, f]) => {
                  var C;
                  if (!this.destroyed && !this.commonObjs.has(k))
                    switch (a) {
                      case "Font":
                        const R = this._params;
                        if ("error" in f) {
                          const E = f.error;
                          (0, _util.warn)(`Error during font loading: ${E}`), this.commonObjs.resolve(k, E);
                          break;
                        }
                        const M = R.pdfBug && ((C = globalThis.FontInspector) != null && C.enabled) ? (E, T) => globalThis.FontInspector.fontAdded(E, T) : null, I = new _font_loader.FontFaceObject(f, {
                          isEvalSupported: R.isEvalSupported,
                          disableFontFace: R.disableFontFace,
                          ignoreErrors: R.ignoreErrors,
                          inspectFont: M
                        });
                        this.fontLoader.bind(I).catch((E) => c.sendWithPromise("FontFallback", {
                          id: k
                        })).finally(() => {
                          !R.fontExtraProperties && I.data && (I.data = null), this.commonObjs.resolve(k, I);
                        });
                        break;
                      case "FontPath":
                      case "Image":
                      case "Pattern":
                        this.commonObjs.resolve(k, f);
                        break;
                      default:
                        throw new Error(`Got unknown common object type ${a}`);
                    }
                }), c.on("obj", ([k, a, f, C]) => {
                  var M;
                  if (this.destroyed)
                    return;
                  const R = x(this, B).get(a);
                  if (!R.objs.has(k))
                    switch (f) {
                      case "Image":
                        if (R.objs.resolve(k, C), C) {
                          let I;
                          if (C.bitmap) {
                            const {
                              width: E,
                              height: T
                            } = C;
                            I = E * T * 4;
                          } else
                            I = ((M = C.data) == null ? void 0 : M.length) || 0;
                          I > _util.MAX_IMAGE_SIZE_TO_CACHE && (R._maybeCleanupAfterRender = !0);
                        }
                        break;
                      case "Pattern":
                        R.objs.resolve(k, C);
                        break;
                      default:
                        throw new Error(`Got unknown object type ${f}`);
                    }
                }), c.on("DocProgress", (k) => {
                  var a;
                  this.destroyed || (a = v.onProgress) == null || a.call(v, {
                    loaded: k.loaded,
                    total: k.total
                  });
                }), c.on("FetchBuiltInCMap", (k) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(k) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), c.on("FetchStandardFontData", (k) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(k) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
              }
              getData() {
                return this.messageHandler.sendWithPromise("GetData", null);
              }
              saveDocument() {
                var k;
                this.annotationStorage.size <= 0 && (0, _util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
                const {
                  map: c,
                  transfers: v
                } = this.annotationStorage.serializable;
                return this.messageHandler.sendWithPromise("SaveDocument", {
                  isPureXfa: !!this._htmlForXfa,
                  numPages: this._numPages,
                  annotationStorage: c,
                  filename: ((k = this._fullReader) == null ? void 0 : k.filename) ?? null
                }, v).finally(() => {
                  this.annotationStorage.resetModified();
                });
              }
              getPage(c) {
                if (!Number.isInteger(c) || c <= 0 || c > this._numPages)
                  return Promise.reject(new Error("Invalid page request."));
                const v = c - 1, k = x(this, P).get(v);
                if (k)
                  return k;
                const a = this.messageHandler.sendWithPromise("GetPage", {
                  pageIndex: v
                }).then((f) => {
                  if (this.destroyed)
                    throw new Error("Transport destroyed");
                  const C = new PDFPageProxy(v, f, this, this._params.pdfBug);
                  return x(this, B).set(v, C), C;
                });
                return x(this, P).set(v, a), a;
              }
              getPageIndex(c) {
                return typeof c != "object" || c === null || !Number.isInteger(c.num) || c.num < 0 || !Number.isInteger(c.gen) || c.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", {
                  num: c.num,
                  gen: c.gen
                });
              }
              getAnnotations(c, v) {
                return this.messageHandler.sendWithPromise("GetAnnotations", {
                  pageIndex: c,
                  intent: v
                });
              }
              getFieldObjects() {
                return Te(this, r, ga).call(this, "GetFieldObjects");
              }
              hasJSActions() {
                return Te(this, r, ga).call(this, "HasJSActions");
              }
              getCalculationOrderIds() {
                return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
              }
              getDestinations() {
                return this.messageHandler.sendWithPromise("GetDestinations", null);
              }
              getDestination(c) {
                return typeof c != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
                  id: c
                });
              }
              getPageLabels() {
                return this.messageHandler.sendWithPromise("GetPageLabels", null);
              }
              getPageLayout() {
                return this.messageHandler.sendWithPromise("GetPageLayout", null);
              }
              getPageMode() {
                return this.messageHandler.sendWithPromise("GetPageMode", null);
              }
              getViewerPreferences() {
                return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
              }
              getOpenAction() {
                return this.messageHandler.sendWithPromise("GetOpenAction", null);
              }
              getAttachments() {
                return this.messageHandler.sendWithPromise("GetAttachments", null);
              }
              getDocJSActions() {
                return Te(this, r, ga).call(this, "GetDocJSActions");
              }
              getPageJSActions(c) {
                return this.messageHandler.sendWithPromise("GetPageJSActions", {
                  pageIndex: c
                });
              }
              getStructTree(c) {
                return this.messageHandler.sendWithPromise("GetStructTree", {
                  pageIndex: c
                });
              }
              getOutline() {
                return this.messageHandler.sendWithPromise("GetOutline", null);
              }
              getOptionalContentConfig() {
                return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((c) => new _optional_content_config.OptionalContentConfig(c));
              }
              getPermissions() {
                return this.messageHandler.sendWithPromise("GetPermissions", null);
              }
              getMetadata() {
                const c = "GetMetadata", v = x(this, H).get(c);
                if (v)
                  return v;
                const k = this.messageHandler.sendWithPromise(c, null).then((a) => {
                  var f, C;
                  return {
                    info: a[0],
                    metadata: a[1] ? new _metadata.Metadata(a[1]) : null,
                    contentDispositionFilename: ((f = this._fullReader) == null ? void 0 : f.filename) ?? null,
                    contentLength: ((C = this._fullReader) == null ? void 0 : C.contentLength) ?? null
                  };
                });
                return x(this, H).set(c, k), k;
              }
              getMarkInfo() {
                return this.messageHandler.sendWithPromise("GetMarkInfo", null);
              }
              async startCleanup(c = !1) {
                if (!this.destroyed) {
                  await this.messageHandler.sendWithPromise("Cleanup", null);
                  for (const v of x(this, B).values())
                    if (!v.cleanup())
                      throw new Error(`startCleanup: Page ${v.pageNumber} is currently rendering.`);
                  this.commonObjs.clear(), c || this.fontLoader.clear(), x(this, H).clear(), this.filterFactory.destroy(!0);
                }
              }
              get loadingParams() {
                const {
                  disableAutoFetch: c,
                  enableXfa: v
                } = this._params;
                return (0, _util.shadow)(this, "loadingParams", {
                  disableAutoFetch: c,
                  enableXfa: v
                });
              }
            }
            H = new WeakMap(), B = new WeakMap(), P = new WeakMap(), S = new WeakMap(), r = new WeakSet(), ga = function(c, v = null) {
              const k = x(this, H).get(c);
              if (k)
                return k;
              const a = this.messageHandler.sendWithPromise(c, v);
              return x(this, H).set(c, a), a;
            };
            class PDFObjects {
              constructor() {
                Ne(this, s);
                Ne(this, m, /* @__PURE__ */ Object.create(null));
              }
              get(c, v = null) {
                if (v) {
                  const a = Te(this, s, ri).call(this, c);
                  return a.capability.promise.then(() => v(a.data)), null;
                }
                const k = x(this, m)[c];
                if (!(k != null && k.capability.settled))
                  throw new Error(`Requesting object that isn't resolved yet ${c}.`);
                return k.data;
              }
              has(c) {
                const v = x(this, m)[c];
                return (v == null ? void 0 : v.capability.settled) || !1;
              }
              resolve(c, v = null) {
                const k = Te(this, s, ri).call(this, c);
                k.data = v, k.capability.resolve();
              }
              clear() {
                var c;
                for (const v in x(this, m)) {
                  const {
                    data: k
                  } = x(this, m)[v];
                  (c = k == null ? void 0 : k.bitmap) == null || c.close();
                }
                je(this, m, /* @__PURE__ */ Object.create(null));
              }
            }
            m = new WeakMap(), s = new WeakSet(), ri = function(c) {
              var v;
              return (v = x(this, m))[c] || (v[c] = {
                capability: new _util.PromiseCapability(),
                data: null
              });
            };
            class RenderTask {
              constructor(c) {
                Ne(this, i, null);
                je(this, i, c), this.onContinue = null;
              }
              get promise() {
                return x(this, i).capability.promise;
              }
              cancel(c = 0) {
                x(this, i).cancel(null, c);
              }
              get separateAnnots() {
                const {
                  separateAnnots: c
                } = x(this, i).operatorList;
                if (!c)
                  return !1;
                const {
                  annotationCanvasMap: v
                } = x(this, i);
                return c.form || c.canvas && (v == null ? void 0 : v.size) > 0;
              }
            }
            i = new WeakMap(), exports.RenderTask = RenderTask;
            const b = class b {
              constructor({
                callback: c,
                params: v,
                objs: k,
                commonObjs: a,
                annotationCanvasMap: f,
                operatorList: C,
                pageIndex: R,
                canvasFactory: M,
                filterFactory: I,
                useRequestAnimationFrame: E = !1,
                pdfBug: T = !1,
                pageColors: y = null
              }) {
                this.callback = c, this.params = v, this.objs = k, this.commonObjs = a, this.annotationCanvasMap = f, this.operatorListIdx = null, this.operatorList = C, this._pageIndex = R, this.canvasFactory = M, this.filterFactory = I, this._pdfBug = T, this.pageColors = y, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = E === !0 && typeof window < "u", this.cancelled = !1, this.capability = new _util.PromiseCapability(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = v.canvasContext.canvas;
              }
              get completed() {
                return this.capability.promise.catch(function() {
                });
              }
              initializeGraphics({
                transparency: c = !1,
                optionalContentConfig: v
              }) {
                var R, M;
                if (this.cancelled)
                  return;
                if (this._canvas) {
                  if (x(b, o).has(this._canvas))
                    throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                  x(b, o).add(this._canvas);
                }
                this._pdfBug && ((R = globalThis.StepperManager) != null && R.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
                const {
                  canvasContext: k,
                  viewport: a,
                  transform: f,
                  background: C
                } = this.params;
                this.gfx = new _canvas.CanvasGraphics(k, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                  optionalContentConfig: v
                }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
                  transform: f,
                  viewport: a,
                  transparency: c,
                  background: C
                }), this.operatorListIdx = 0, this.graphicsReady = !0, (M = this.graphicsReadyCallback) == null || M.call(this);
              }
              cancel(c = null, v = 0) {
                var k;
                this.running = !1, this.cancelled = !0, (k = this.gfx) == null || k.endDrawing(), x(b, o).delete(this._canvas), this.callback(c || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, v));
              }
              operatorListChanged() {
                var c;
                if (!this.graphicsReady) {
                  this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                  return;
                }
                (c = this.stepper) == null || c.updateOperatorList(this.operatorList), !this.running && this._continue();
              }
              _continue() {
                this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
              }
              _scheduleNext() {
                this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
                  this._nextBound().catch(this._cancelBound);
                }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
              }
              async _next() {
                this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), x(b, o).delete(this._canvas), this.callback())));
              }
            };
            o = new WeakMap(), Ne(b, o, /* @__PURE__ */ new WeakSet());
            let InternalRenderTask = b;
            const version = "3.11.174";
            exports.version = version;
            const build = "ce8716743";
            exports.build = build;
          },
          /* 3 */
          /***/
          (e, L, p) => {
            var X, N, H, Yi, P;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.SerializableEmpty = L.PrintAnnotationStorage = L.AnnotationStorage = void 0;
            var n = p(1), t = p(4), l = p(8);
            const W = Object.freeze({
              map: null,
              hash: "",
              transfers: void 0
            });
            L.SerializableEmpty = W;
            class Q {
              constructor() {
                Ne(this, H);
                Ne(this, X, !1);
                Ne(this, N, /* @__PURE__ */ new Map());
                this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
              }
              getValue(r, u) {
                const m = x(this, N).get(r);
                return m === void 0 ? u : Object.assign(u, m);
              }
              getRawValue(r) {
                return x(this, N).get(r);
              }
              remove(r) {
                if (x(this, N).delete(r), x(this, N).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
                  for (const u of x(this, N).values())
                    if (u instanceof t.AnnotationEditor)
                      return;
                  this.onAnnotationEditor(null);
                }
              }
              setValue(r, u) {
                const m = x(this, N).get(r);
                let s = !1;
                if (m !== void 0)
                  for (const [w, i] of Object.entries(u))
                    m[w] !== i && (s = !0, m[w] = i);
                else
                  s = !0, x(this, N).set(r, u);
                s && Te(this, H, Yi).call(this), u instanceof t.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(u.constructor._type);
              }
              has(r) {
                return x(this, N).has(r);
              }
              getAll() {
                return x(this, N).size > 0 ? (0, n.objectFromMap)(x(this, N)) : null;
              }
              setAll(r) {
                for (const [u, m] of Object.entries(r))
                  this.setValue(u, m);
              }
              get size() {
                return x(this, N).size;
              }
              resetModified() {
                x(this, X) && (je(this, X, !1), typeof this.onResetModified == "function" && this.onResetModified());
              }
              get print() {
                return new G(this);
              }
              get serializable() {
                if (x(this, N).size === 0)
                  return W;
                const r = /* @__PURE__ */ new Map(), u = new l.MurmurHash3_64(), m = [], s = /* @__PURE__ */ Object.create(null);
                let w = !1;
                for (const [i, o] of x(this, N)) {
                  const b = o instanceof t.AnnotationEditor ? o.serialize(!1, s) : o;
                  b && (r.set(i, b), u.update(`${i}:${JSON.stringify(b)}`), w || (w = !!b.bitmap));
                }
                if (w)
                  for (const i of r.values())
                    i.bitmap && m.push(i.bitmap);
                return r.size > 0 ? {
                  map: r,
                  hash: u.hexdigest(),
                  transfers: m
                } : W;
              }
            }
            X = new WeakMap(), N = new WeakMap(), H = new WeakSet(), Yi = function() {
              x(this, X) || (je(this, X, !0), typeof this.onSetModified == "function" && this.onSetModified());
            }, L.AnnotationStorage = Q;
            class G extends Q {
              constructor(u) {
                super();
                Ne(this, P);
                const {
                  map: m,
                  hash: s,
                  transfers: w
                } = u.serializable, i = structuredClone(m, w ? {
                  transfer: w
                } : null);
                je(this, P, {
                  map: i,
                  hash: s,
                  transfers: w
                });
              }
              get print() {
                (0, n.unreachable)("Should not call PrintAnnotationStorage.print");
              }
              get serializable() {
                return x(this, P);
              }
            }
            P = new WeakMap(), L.PrintAnnotationStorage = G;
          },
          /* 4 */
          /***/
          (e, L, p) => {
            var G, X, N, H, B, P, S, r, u, m, s, w, i, o, b, ai, ii, v, oi, si, Zi, Ji, Qi, ci, eo;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.AnnotationEditor = void 0;
            var n = p(5), t = p(1), l = p(6);
            const E = class E {
              constructor(y) {
                Ne(this, b);
                Ne(this, G, "");
                Ne(this, X, !1);
                Ne(this, N, null);
                Ne(this, H, null);
                Ne(this, B, null);
                Ne(this, P, !1);
                Ne(this, S, null);
                Ne(this, r, this.focusin.bind(this));
                Ne(this, u, this.focusout.bind(this));
                Ne(this, m, !1);
                Ne(this, s, !1);
                Ne(this, w, !1);
                Tn(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
                Tn(this, "_uiManager", null);
                Tn(this, "_focusEventsAllowed", !0);
                Tn(this, "_l10nPromise", null);
                Ne(this, i, !1);
                Ne(this, o, E._zIndex++);
                this.constructor === E && (0, t.unreachable)("Cannot initialize AnnotationEditor."), this.parent = y.parent, this.id = y.id, this.width = this.height = null, this.pageIndex = y.parent.pageIndex, this.name = y.name, this.div = null, this._uiManager = y.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = y.isCentered, this._structTreeParentId = null;
                const {
                  rotation: D,
                  rawDims: {
                    pageWidth: j,
                    pageHeight: A,
                    pageX: d,
                    pageY: _
                  }
                } = this.parent.viewport;
                this.rotation = D, this.pageRotation = (360 + D - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [j, A], this.pageTranslation = [d, _];
                const [F, U] = this.parentDimensions;
                this.x = y.x / F, this.y = y.y / U, this.isAttachedToDOM = !1, this.deleted = !1;
              }
              get editorType() {
                return Object.getPrototypeOf(this).constructor._type;
              }
              static get _defaultLineColor() {
                return (0, t.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
              }
              static deleteAnnotationElement(y) {
                const D = new Q({
                  id: y.parent.getNextId(),
                  parent: y.parent,
                  uiManager: y._uiManager
                });
                D.annotationElementId = y.annotationElementId, D.deleted = !0, D._uiManager.addToAnnotationStorage(D);
              }
              static initialize(y, D = null) {
                if (E._l10nPromise || (E._l10nPromise = new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map((A) => [A, y.get(A)]))), D != null && D.strings)
                  for (const A of D.strings)
                    E._l10nPromise.set(A, y.get(A));
                if (E._borderLineWidth !== -1)
                  return;
                const j = getComputedStyle(document.documentElement);
                E._borderLineWidth = parseFloat(j.getPropertyValue("--outline-width")) || 0;
              }
              static updateDefaultParams(y, D) {
              }
              static get defaultPropertiesToUpdate() {
                return [];
              }
              static isHandlingMimeForPasting(y) {
                return !1;
              }
              static paste(y, D) {
                (0, t.unreachable)("Not implemented");
              }
              get propertiesToUpdate() {
                return [];
              }
              get _isDraggable() {
                return x(this, i);
              }
              set _isDraggable(y) {
                var D;
                je(this, i, y), (D = this.div) == null || D.classList.toggle("draggable", y);
              }
              center() {
                const [y, D] = this.pageDimensions;
                switch (this.parentRotation) {
                  case 90:
                    this.x -= this.height * D / (y * 2), this.y += this.width * y / (D * 2);
                    break;
                  case 180:
                    this.x += this.width / 2, this.y += this.height / 2;
                    break;
                  case 270:
                    this.x += this.height * D / (y * 2), this.y -= this.width * y / (D * 2);
                    break;
                  default:
                    this.x -= this.width / 2, this.y -= this.height / 2;
                    break;
                }
                this.fixAndSetPosition();
              }
              addCommands(y) {
                this._uiManager.addCommands(y);
              }
              get currentLayer() {
                return this._uiManager.currentLayer;
              }
              setInBackground() {
                this.div.style.zIndex = 0;
              }
              setInForeground() {
                this.div.style.zIndex = x(this, o);
              }
              setParent(y) {
                y !== null && (this.pageIndex = y.pageIndex, this.pageDimensions = y.pageDimensions), this.parent = y;
              }
              focusin(y) {
                this._focusEventsAllowed && (x(this, m) ? je(this, m, !1) : this.parent.setSelected(this));
              }
              focusout(y) {
                var j;
                if (!this._focusEventsAllowed || !this.isAttachedToDOM)
                  return;
                const D = y.relatedTarget;
                D != null && D.closest(`#${this.id}`) || (y.preventDefault(), (j = this.parent) != null && j.isMultipleSelection || this.commitOrRemove());
              }
              commitOrRemove() {
                this.isEmpty() ? this.remove() : this.commit();
              }
              commit() {
                this.addToAnnotationStorage();
              }
              addToAnnotationStorage() {
                this._uiManager.addToAnnotationStorage(this);
              }
              setAt(y, D, j, A) {
                const [d, _] = this.parentDimensions;
                [j, A] = this.screenToPageTranslation(j, A), this.x = (y + j) / d, this.y = (D + A) / _, this.fixAndSetPosition();
              }
              translate(y, D) {
                Te(this, b, ai).call(this, this.parentDimensions, y, D);
              }
              translateInPage(y, D) {
                Te(this, b, ai).call(this, this.pageDimensions, y, D), this.div.scrollIntoView({
                  block: "nearest"
                });
              }
              drag(y, D) {
                const [j, A] = this.parentDimensions;
                if (this.x += y / j, this.y += D / A, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
                  const {
                    x: V,
                    y: $
                  } = this.div.getBoundingClientRect();
                  this.parent.findNewParent(this, V, $) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
                }
                let {
                  x: d,
                  y: _
                } = this;
                const [F, U] = Te(this, b, ii).call(this);
                d += F, _ += U, this.div.style.left = `${(100 * d).toFixed(2)}%`, this.div.style.top = `${(100 * _).toFixed(2)}%`, this.div.scrollIntoView({
                  block: "nearest"
                });
              }
              fixAndSetPosition() {
                const [y, D] = this.pageDimensions;
                let {
                  x: j,
                  y: A,
                  width: d,
                  height: _
                } = this;
                switch (d *= y, _ *= D, j *= y, A *= D, this.rotation) {
                  case 0:
                    j = Math.max(0, Math.min(y - d, j)), A = Math.max(0, Math.min(D - _, A));
                    break;
                  case 90:
                    j = Math.max(0, Math.min(y - _, j)), A = Math.min(D, Math.max(d, A));
                    break;
                  case 180:
                    j = Math.min(y, Math.max(d, j)), A = Math.min(D, Math.max(_, A));
                    break;
                  case 270:
                    j = Math.min(y, Math.max(_, j)), A = Math.max(0, Math.min(D - d, A));
                    break;
                }
                this.x = j /= y, this.y = A /= D;
                const [F, U] = Te(this, b, ii).call(this);
                j += F, A += U;
                const {
                  style: V
                } = this.div;
                V.left = `${(100 * j).toFixed(2)}%`, V.top = `${(100 * A).toFixed(2)}%`, this.moveInDOM();
              }
              screenToPageTranslation(y, D) {
                var j;
                return Te(j = E, v, oi).call(j, y, D, this.parentRotation);
              }
              pageTranslationToScreen(y, D) {
                var j;
                return Te(j = E, v, oi).call(j, y, D, 360 - this.parentRotation);
              }
              get parentScale() {
                return this._uiManager.viewParameters.realScale;
              }
              get parentRotation() {
                return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
              }
              get parentDimensions() {
                const {
                  parentScale: y,
                  pageDimensions: [D, j]
                } = this, A = D * y, d = j * y;
                return t.FeatureTest.isCSSRoundSupported ? [Math.round(A), Math.round(d)] : [A, d];
              }
              setDims(y, D) {
                var d;
                const [j, A] = this.parentDimensions;
                this.div.style.width = `${(100 * y / j).toFixed(2)}%`, x(this, P) || (this.div.style.height = `${(100 * D / A).toFixed(2)}%`), (d = x(this, N)) == null || d.classList.toggle("small", y < E.SMALL_EDITOR_SIZE || D < E.SMALL_EDITOR_SIZE);
              }
              fixDims() {
                const {
                  style: y
                } = this.div, {
                  height: D,
                  width: j
                } = y, A = j.endsWith("%"), d = !x(this, P) && D.endsWith("%");
                if (A && d)
                  return;
                const [_, F] = this.parentDimensions;
                A || (y.width = `${(100 * parseFloat(j) / _).toFixed(2)}%`), !x(this, P) && !d && (y.height = `${(100 * parseFloat(D) / F).toFixed(2)}%`);
              }
              getInitialTranslation() {
                return [0, 0];
              }
              async addAltTextButton() {
                if (x(this, N))
                  return;
                const y = je(this, N, document.createElement("button"));
                y.className = "altText";
                const D = await E._l10nPromise.get("editor_alt_text_button_label");
                y.textContent = D, y.setAttribute("aria-label", D), y.tabIndex = "0", y.addEventListener("contextmenu", l.noContextMenu), y.addEventListener("pointerdown", (j) => j.stopPropagation()), y.addEventListener("click", (j) => {
                  j.preventDefault(), this._uiManager.editAltText(this);
                }, {
                  capture: !0
                }), y.addEventListener("keydown", (j) => {
                  j.target === y && j.key === "Enter" && (j.preventDefault(), this._uiManager.editAltText(this));
                }), Te(this, b, ci).call(this), this.div.append(y), E.SMALL_EDITOR_SIZE || (E.SMALL_EDITOR_SIZE = Math.min(128, Math.round(y.getBoundingClientRect().width * 1.4)));
              }
              getClientDimensions() {
                return this.div.getBoundingClientRect();
              }
              get altTextData() {
                return {
                  altText: x(this, G),
                  decorative: x(this, X)
                };
              }
              set altTextData({
                altText: y,
                decorative: D
              }) {
                x(this, G) === y && x(this, X) === D || (je(this, G, y), je(this, X, D), Te(this, b, ci).call(this));
              }
              render() {
                this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", x(this, r)), this.div.addEventListener("focusout", x(this, u));
                const [y, D] = this.parentDimensions;
                this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * D / y).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * y / D).toFixed(2)}%`);
                const [j, A] = this.getInitialTranslation();
                return this.translate(j, A), (0, n.bindEvents)(this, this.div, ["pointerdown"]), this.div;
              }
              pointerdown(y) {
                const {
                  isMac: D
                } = t.FeatureTest.platform;
                if (y.button !== 0 || y.ctrlKey && D) {
                  y.preventDefault();
                  return;
                }
                je(this, m, !0), Te(this, b, eo).call(this, y);
              }
              moveInDOM() {
                var y;
                (y = this.parent) == null || y.moveEditorInDOM(this);
              }
              _setParentAndPosition(y, D, j) {
                y.changeParent(this), this.x = D, this.y = j, this.fixAndSetPosition();
              }
              getRect(y, D) {
                const j = this.parentScale, [A, d] = this.pageDimensions, [_, F] = this.pageTranslation, U = y / j, V = D / j, $ = this.x * A, re = this.y * d, ge = this.width * A, be = this.height * d;
                switch (this.rotation) {
                  case 0:
                    return [$ + U + _, d - re - V - be + F, $ + U + ge + _, d - re - V + F];
                  case 90:
                    return [$ + V + _, d - re + U + F, $ + V + be + _, d - re + U + ge + F];
                  case 180:
                    return [$ - U - ge + _, d - re + V + F, $ - U + _, d - re + V + be + F];
                  case 270:
                    return [$ - V - be + _, d - re - U - ge + F, $ - V + _, d - re - U + F];
                  default:
                    throw new Error("Invalid rotation");
                }
              }
              getRectInCurrentCoords(y, D) {
                const [j, A, d, _] = y, F = d - j, U = _ - A;
                switch (this.rotation) {
                  case 0:
                    return [j, D - _, F, U];
                  case 90:
                    return [j, D - A, U, F];
                  case 180:
                    return [d, D - A, F, U];
                  case 270:
                    return [d, D - _, U, F];
                  default:
                    throw new Error("Invalid rotation");
                }
              }
              onceAdded() {
              }
              isEmpty() {
                return !1;
              }
              enableEditMode() {
                je(this, w, !0);
              }
              disableEditMode() {
                je(this, w, !1);
              }
              isInEditMode() {
                return x(this, w);
              }
              shouldGetKeyboardEvents() {
                return !1;
              }
              needsToBeRebuilt() {
                return this.div && !this.isAttachedToDOM;
              }
              rebuild() {
                var y, D;
                (y = this.div) == null || y.addEventListener("focusin", x(this, r)), (D = this.div) == null || D.addEventListener("focusout", x(this, u));
              }
              serialize(y = !1, D = null) {
                (0, t.unreachable)("An editor must be serializable");
              }
              static deserialize(y, D, j) {
                const A = new this.prototype.constructor({
                  parent: D,
                  id: D.getNextId(),
                  uiManager: j
                });
                A.rotation = y.rotation;
                const [d, _] = A.pageDimensions, [F, U, V, $] = A.getRectInCurrentCoords(y.rect, _);
                return A.x = F / d, A.y = U / _, A.width = V / d, A.height = $ / _, A;
              }
              remove() {
                var y;
                this.div.removeEventListener("focusin", x(this, r)), this.div.removeEventListener("focusout", x(this, u)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), (y = x(this, N)) == null || y.remove(), je(this, N, null), je(this, H, null);
              }
              get isResizable() {
                return !1;
              }
              makeResizable() {
                this.isResizable && (Te(this, b, Zi).call(this), x(this, S).classList.remove("hidden"));
              }
              select() {
                var y;
                this.makeResizable(), (y = this.div) == null || y.classList.add("selectedEditor");
              }
              unselect() {
                var y, D, j;
                (y = x(this, S)) == null || y.classList.add("hidden"), (D = this.div) == null || D.classList.remove("selectedEditor"), (j = this.div) != null && j.contains(document.activeElement) && this._uiManager.currentLayer.div.focus();
              }
              updateParams(y, D) {
              }
              disableEditing() {
                x(this, N) && (x(this, N).hidden = !0);
              }
              enableEditing() {
                x(this, N) && (x(this, N).hidden = !1);
              }
              enterInEditMode() {
              }
              get contentDiv() {
                return this.div;
              }
              get isEditing() {
                return x(this, s);
              }
              set isEditing(y) {
                je(this, s, y), this.parent && (y ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
              }
              setAspectRatio(y, D) {
                je(this, P, !0);
                const j = y / D, {
                  style: A
                } = this.div;
                A.aspectRatio = j, A.height = "auto";
              }
              static get MIN_SIZE() {
                return 16;
              }
            };
            G = new WeakMap(), X = new WeakMap(), N = new WeakMap(), H = new WeakMap(), B = new WeakMap(), P = new WeakMap(), S = new WeakMap(), r = new WeakMap(), u = new WeakMap(), m = new WeakMap(), s = new WeakMap(), w = new WeakMap(), i = new WeakMap(), o = new WeakMap(), b = new WeakSet(), ai = function([y, D], j, A) {
              [j, A] = this.screenToPageTranslation(j, A), this.x += j / y, this.y += A / D, this.fixAndSetPosition();
            }, ii = function() {
              const [y, D] = this.parentDimensions, {
                _borderLineWidth: j
              } = E, A = j / y, d = j / D;
              switch (this.rotation) {
                case 90:
                  return [-A, d];
                case 180:
                  return [A, d];
                case 270:
                  return [A, -d];
                default:
                  return [-A, -d];
              }
            }, v = new WeakSet(), oi = function(y, D, j) {
              switch (j) {
                case 90:
                  return [D, -y];
                case 180:
                  return [-y, -D];
                case 270:
                  return [-D, y];
                default:
                  return [y, D];
              }
            }, si = function(y) {
              switch (y) {
                case 90: {
                  const [D, j] = this.pageDimensions;
                  return [0, -D / j, j / D, 0];
                }
                case 180:
                  return [-1, 0, 0, -1];
                case 270: {
                  const [D, j] = this.pageDimensions;
                  return [0, D / j, -j / D, 0];
                }
                default:
                  return [1, 0, 0, 1];
              }
            }, Zi = function() {
              if (x(this, S))
                return;
              je(this, S, document.createElement("div")), x(this, S).classList.add("resizers");
              const y = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
              this._willKeepAspectRatio || y.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft");
              for (const D of y) {
                const j = document.createElement("div");
                x(this, S).append(j), j.classList.add("resizer", D), j.addEventListener("pointerdown", Te(this, b, Ji).bind(this, D)), j.addEventListener("contextmenu", l.noContextMenu);
              }
              this.div.prepend(x(this, S));
            }, Ji = function(y, D) {
              D.preventDefault();
              const {
                isMac: j
              } = t.FeatureTest.platform;
              if (D.button !== 0 || D.ctrlKey && j)
                return;
              const A = Te(this, b, Qi).bind(this, y), d = this._isDraggable;
              this._isDraggable = !1;
              const _ = {
                passive: !0,
                capture: !0
              };
              window.addEventListener("pointermove", A, _);
              const F = this.x, U = this.y, V = this.width, $ = this.height, re = this.parent.div.style.cursor, ge = this.div.style.cursor;
              this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(D.target).cursor;
              const be = () => {
                this._isDraggable = d, window.removeEventListener("pointerup", be), window.removeEventListener("blur", be), window.removeEventListener("pointermove", A, _), this.parent.div.style.cursor = re, this.div.style.cursor = ge;
                const le = this.x, fe = this.y, Ae = this.width, qe = this.height;
                le === F && fe === U && Ae === V && qe === $ || this.addCommands({
                  cmd: () => {
                    this.width = Ae, this.height = qe, this.x = le, this.y = fe;
                    const [ye, ce] = this.parentDimensions;
                    this.setDims(ye * Ae, ce * qe), this.fixAndSetPosition();
                  },
                  undo: () => {
                    this.width = V, this.height = $, this.x = F, this.y = U;
                    const [ye, ce] = this.parentDimensions;
                    this.setDims(ye * V, ce * $), this.fixAndSetPosition();
                  },
                  mustExec: !0
                });
              };
              window.addEventListener("pointerup", be), window.addEventListener("blur", be);
            }, Qi = function(y, D) {
              const [j, A] = this.parentDimensions, d = this.x, _ = this.y, F = this.width, U = this.height, V = E.MIN_SIZE / j, $ = E.MIN_SIZE / A, re = (tt) => Math.round(tt * 1e4) / 1e4, ge = Te(this, b, si).call(this, this.rotation), be = (tt, Xe) => [ge[0] * tt + ge[2] * Xe, ge[1] * tt + ge[3] * Xe], le = Te(this, b, si).call(this, 360 - this.rotation), fe = (tt, Xe) => [le[0] * tt + le[2] * Xe, le[1] * tt + le[3] * Xe];
              let Ae, qe, ye = !1, ce = !1;
              switch (y) {
                case "topLeft":
                  ye = !0, Ae = (tt, Xe) => [0, 0], qe = (tt, Xe) => [tt, Xe];
                  break;
                case "topMiddle":
                  Ae = (tt, Xe) => [tt / 2, 0], qe = (tt, Xe) => [tt / 2, Xe];
                  break;
                case "topRight":
                  ye = !0, Ae = (tt, Xe) => [tt, 0], qe = (tt, Xe) => [0, Xe];
                  break;
                case "middleRight":
                  ce = !0, Ae = (tt, Xe) => [tt, Xe / 2], qe = (tt, Xe) => [0, Xe / 2];
                  break;
                case "bottomRight":
                  ye = !0, Ae = (tt, Xe) => [tt, Xe], qe = (tt, Xe) => [0, 0];
                  break;
                case "bottomMiddle":
                  Ae = (tt, Xe) => [tt / 2, Xe], qe = (tt, Xe) => [tt / 2, 0];
                  break;
                case "bottomLeft":
                  ye = !0, Ae = (tt, Xe) => [0, Xe], qe = (tt, Xe) => [tt, 0];
                  break;
                case "middleLeft":
                  ce = !0, Ae = (tt, Xe) => [0, Xe / 2], qe = (tt, Xe) => [tt, Xe / 2];
                  break;
              }
              const q = Ae(F, U), Z = qe(F, U);
              let pe = be(...Z);
              const me = re(d + pe[0]), _e = re(_ + pe[1]);
              let Be = 1, ke = 1, [de, $e] = this.screenToPageTranslation(D.movementX, D.movementY);
              if ([de, $e] = fe(de / j, $e / A), ye) {
                const tt = Math.hypot(F, U);
                Be = ke = Math.max(Math.min(Math.hypot(Z[0] - q[0] - de, Z[1] - q[1] - $e) / tt, 1 / F, 1 / U), V / F, $ / U);
              } else ce ? Be = Math.max(V, Math.min(1, Math.abs(Z[0] - q[0] - de))) / F : ke = Math.max($, Math.min(1, Math.abs(Z[1] - q[1] - $e))) / U;
              const Ge = re(F * Be), st = re(U * ke);
              pe = be(...qe(Ge, st));
              const it = me - pe[0], _t = _e - pe[1];
              this.width = Ge, this.height = st, this.x = it, this.y = _t, this.setDims(j * Ge, A * st), this.fixAndSetPosition();
            }, ci = async function() {
              var j;
              const y = x(this, N);
              if (!y)
                return;
              if (!x(this, G) && !x(this, X)) {
                y.classList.remove("done"), (j = x(this, H)) == null || j.remove();
                return;
              }
              E._l10nPromise.get("editor_alt_text_edit_button_label").then((A) => {
                y.setAttribute("aria-label", A);
              });
              let D = x(this, H);
              if (!D) {
                je(this, H, D = document.createElement("span")), D.className = "tooltip", D.setAttribute("role", "tooltip");
                const A = D.id = `alt-text-tooltip-${this.id}`;
                y.setAttribute("aria-describedby", A);
                const d = 100;
                y.addEventListener("mouseenter", () => {
                  je(this, B, setTimeout(() => {
                    je(this, B, null), x(this, H).classList.add("show"), this._uiManager._eventBus.dispatch("reporttelemetry", {
                      source: this,
                      details: {
                        type: "editing",
                        subtype: this.editorType,
                        data: {
                          action: "alt_text_tooltip"
                        }
                      }
                    });
                  }, d));
                }), y.addEventListener("mouseleave", () => {
                  var _;
                  clearTimeout(x(this, B)), je(this, B, null), (_ = x(this, H)) == null || _.classList.remove("show");
                });
              }
              y.classList.add("done"), D.innerText = x(this, X) ? await E._l10nPromise.get("editor_alt_text_decorative_tooltip") : x(this, G), D.parentNode || y.append(D);
            }, eo = function(y) {
              if (!this._isDraggable)
                return;
              const D = this._uiManager.isSelected(this);
              this._uiManager.setUpDragSession();
              let j, A;
              D && (j = {
                passive: !0,
                capture: !0
              }, A = (_) => {
                const [F, U] = this.screenToPageTranslation(_.movementX, _.movementY);
                this._uiManager.dragSelectedEditors(F, U);
              }, window.addEventListener("pointermove", A, j));
              const d = () => {
                if (window.removeEventListener("pointerup", d), window.removeEventListener("blur", d), D && window.removeEventListener("pointermove", A, j), je(this, m, !1), !this._uiManager.endDragSession()) {
                  const {
                    isMac: _
                  } = t.FeatureTest.platform;
                  y.ctrlKey && !_ || y.shiftKey || y.metaKey && _ ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
                }
              };
              window.addEventListener("pointerup", d), window.addEventListener("blur", d);
            }, Ne(E, v), Tn(E, "_borderLineWidth", -1), Tn(E, "_colorManager", new n.ColorManager()), Tn(E, "_zIndex", 1), Tn(E, "SMALL_EDITOR_SIZE", 0);
            let W = E;
            L.AnnotationEditor = W;
            class Q extends W {
              constructor(y) {
                super(y), this.annotationElementId = y.annotationElementId, this.deleted = !0;
              }
              serialize() {
                return {
                  id: this.annotationElementId,
                  deleted: !0,
                  pageIndex: this.pageIndex
                };
              }
            }
          },
          /* 5 */
          /***/
          (e, L, p) => {
            var P, S, r, u, m, li, i, o, b, g, c, to, a, f, C, R, M, I, E, T, y, D, j, A, d, _, F, U, V, $, re, ge, be, le, fe, Ae, qe, ye, ce, q, Z, pe, me, _e, Be, ke, de, no, ui, di, va, hi, fi, vr, Jr, ro, ao, mi, Qr, pi;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.KeyboardManager = L.CommandManager = L.ColorManager = L.AnnotationEditorUIManager = void 0, L.bindEvents = l, L.opacityToHex = W;
            var n = p(1), t = p(6);
            function l(Et, oe, He) {
              for (const at of He)
                oe.addEventListener(at, Et[at].bind(Et));
            }
            function W(Et) {
              return Math.round(Math.min(255, Math.max(1, 255 * Et))).toString(16).padStart(2, "0");
            }
            class Q {
              constructor() {
                Ne(this, P, 0);
              }
              getId() {
                return `${n.AnnotationEditorPrefix}${Zr(this, P)._++}`;
              }
            }
            P = new WeakMap();
            const w = class w {
              constructor() {
                Ne(this, m);
                Ne(this, S, (0, n.getUuid)());
                Ne(this, r, 0);
                Ne(this, u, null);
              }
              static get _isSVGFittingCanvas() {
                const oe = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', at = new OffscreenCanvas(1, 3).getContext("2d"), St = new Image();
                St.src = oe;
                const yt = St.decode().then(() => (at.drawImage(St, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(at.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
                return (0, n.shadow)(this, "_isSVGFittingCanvas", yt);
              }
              async getFromFile(oe) {
                const {
                  lastModified: He,
                  name: at,
                  size: St,
                  type: yt
                } = oe;
                return Te(this, m, li).call(this, `${He}_${at}_${St}_${yt}`, oe);
              }
              async getFromUrl(oe) {
                return Te(this, m, li).call(this, oe, oe);
              }
              async getFromId(oe) {
                x(this, u) || je(this, u, /* @__PURE__ */ new Map());
                const He = x(this, u).get(oe);
                return He ? He.bitmap ? (He.refCounter += 1, He) : He.file ? this.getFromFile(He.file) : this.getFromUrl(He.url) : null;
              }
              getSvgUrl(oe) {
                const He = x(this, u).get(oe);
                return He != null && He.isSvg ? He.svgUrl : null;
              }
              deleteId(oe) {
                x(this, u) || je(this, u, /* @__PURE__ */ new Map());
                const He = x(this, u).get(oe);
                He && (He.refCounter -= 1, He.refCounter === 0 && (He.bitmap = null));
              }
              isValidId(oe) {
                return oe.startsWith(`image_${x(this, S)}_`);
              }
            };
            S = new WeakMap(), r = new WeakMap(), u = new WeakMap(), m = new WeakSet(), li = async function(oe, He) {
              x(this, u) || je(this, u, /* @__PURE__ */ new Map());
              let at = x(this, u).get(oe);
              if (at === null)
                return null;
              if (at != null && at.bitmap)
                return at.refCounter += 1, at;
              try {
                at || (at = {
                  bitmap: null,
                  id: `image_${x(this, S)}_${Zr(this, r)._++}`,
                  refCounter: 0,
                  isSvg: !1
                });
                let St;
                if (typeof He == "string") {
                  at.url = He;
                  const yt = await fetch(He);
                  if (!yt.ok)
                    throw new Error(yt.statusText);
                  St = await yt.blob();
                } else
                  St = at.file = He;
                if (St.type === "image/svg+xml") {
                  const yt = w._isSVGFittingCanvas, dt = new FileReader(), ie = new Image(), te = new Promise((we, De) => {
                    ie.onload = () => {
                      at.bitmap = ie, at.isSvg = !0, we();
                    }, dt.onload = async () => {
                      const Ve = at.svgUrl = dt.result;
                      ie.src = await yt ? `${Ve}#svgView(preserveAspectRatio(none))` : Ve;
                    }, ie.onerror = dt.onerror = De;
                  });
                  dt.readAsDataURL(St), await te;
                } else
                  at.bitmap = await createImageBitmap(St);
                at.refCounter = 1;
              } catch (St) {
                console.error(St), at = null;
              }
              return x(this, u).set(oe, at), at && x(this, u).set(at.id, at), at;
            };
            let G = w;
            class X {
              constructor(oe = 128) {
                Ne(this, i, []);
                Ne(this, o, !1);
                Ne(this, b);
                Ne(this, g, -1);
                je(this, b, oe);
              }
              add({
                cmd: oe,
                undo: He,
                mustExec: at,
                type: St = NaN,
                overwriteIfSameType: yt = !1,
                keepUndo: dt = !1
              }) {
                if (at && oe(), x(this, o))
                  return;
                const ie = {
                  cmd: oe,
                  undo: He,
                  type: St
                };
                if (x(this, g) === -1) {
                  x(this, i).length > 0 && (x(this, i).length = 0), je(this, g, 0), x(this, i).push(ie);
                  return;
                }
                if (yt && x(this, i)[x(this, g)].type === St) {
                  dt && (ie.undo = x(this, i)[x(this, g)].undo), x(this, i)[x(this, g)] = ie;
                  return;
                }
                const te = x(this, g) + 1;
                te === x(this, b) ? x(this, i).splice(0, 1) : (je(this, g, te), te < x(this, i).length && x(this, i).splice(te)), x(this, i).push(ie);
              }
              undo() {
                x(this, g) !== -1 && (je(this, o, !0), x(this, i)[x(this, g)].undo(), je(this, o, !1), je(this, g, x(this, g) - 1));
              }
              redo() {
                x(this, g) < x(this, i).length - 1 && (je(this, g, x(this, g) + 1), je(this, o, !0), x(this, i)[x(this, g)].cmd(), je(this, o, !1));
              }
              hasSomethingToUndo() {
                return x(this, g) !== -1;
              }
              hasSomethingToRedo() {
                return x(this, g) < x(this, i).length - 1;
              }
              destroy() {
                je(this, i, null);
              }
            }
            i = new WeakMap(), o = new WeakMap(), b = new WeakMap(), g = new WeakMap(), L.CommandManager = X;
            class N {
              constructor(oe) {
                Ne(this, c);
                this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
                const {
                  isMac: He
                } = n.FeatureTest.platform;
                for (const [at, St, yt = {}] of oe)
                  for (const dt of at) {
                    const ie = dt.startsWith("mac+");
                    He && ie ? (this.callbacks.set(dt.slice(4), {
                      callback: St,
                      options: yt
                    }), this.allKeys.add(dt.split("+").at(-1))) : !He && !ie && (this.callbacks.set(dt, {
                      callback: St,
                      options: yt
                    }), this.allKeys.add(dt.split("+").at(-1)));
                  }
              }
              exec(oe, He) {
                if (!this.allKeys.has(He.key))
                  return;
                const at = this.callbacks.get(Te(this, c, to).call(this, He));
                if (!at)
                  return;
                const {
                  callback: St,
                  options: {
                    bubbles: yt = !1,
                    args: dt = [],
                    checker: ie = null
                  }
                } = at;
                ie && !ie(oe, He) || (St.bind(oe, ...dt)(), yt || (He.stopPropagation(), He.preventDefault()));
              }
            }
            c = new WeakSet(), to = function(oe) {
              oe.altKey && this.buffer.push("alt"), oe.ctrlKey && this.buffer.push("ctrl"), oe.metaKey && this.buffer.push("meta"), oe.shiftKey && this.buffer.push("shift"), this.buffer.push(oe.key);
              const He = this.buffer.join("+");
              return this.buffer.length = 0, He;
            }, L.KeyboardManager = N;
            const k = class k {
              get _colors() {
                const oe = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
                return (0, t.getColorValues)(oe), (0, n.shadow)(this, "_colors", oe);
              }
              convert(oe) {
                const He = (0, t.getRGB)(oe);
                if (!window.matchMedia("(forced-colors: active)").matches)
                  return He;
                for (const [at, St] of this._colors)
                  if (St.every((yt, dt) => yt === He[dt]))
                    return k._colorsMapping.get(at);
                return He;
              }
              getHexCode(oe) {
                const He = this._colors.get(oe);
                return He ? n.Util.makeHexColor(...He) : oe;
              }
            };
            Tn(k, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
            let H = k;
            L.ColorManager = H;
            const bt = class bt {
              constructor(oe, He, at, St, yt, dt) {
                Ne(this, de);
                Ne(this, a, null);
                Ne(this, f, /* @__PURE__ */ new Map());
                Ne(this, C, /* @__PURE__ */ new Map());
                Ne(this, R, null);
                Ne(this, M, null);
                Ne(this, I, new X());
                Ne(this, E, 0);
                Ne(this, T, /* @__PURE__ */ new Set());
                Ne(this, y, null);
                Ne(this, D, null);
                Ne(this, j, /* @__PURE__ */ new Set());
                Ne(this, A, null);
                Ne(this, d, new Q());
                Ne(this, _, !1);
                Ne(this, F, !1);
                Ne(this, U, null);
                Ne(this, V, n.AnnotationEditorType.NONE);
                Ne(this, $, /* @__PURE__ */ new Set());
                Ne(this, re, null);
                Ne(this, ge, this.blur.bind(this));
                Ne(this, be, this.focus.bind(this));
                Ne(this, le, this.copy.bind(this));
                Ne(this, fe, this.cut.bind(this));
                Ne(this, Ae, this.paste.bind(this));
                Ne(this, qe, this.keydown.bind(this));
                Ne(this, ye, this.onEditingAction.bind(this));
                Ne(this, ce, this.onPageChanging.bind(this));
                Ne(this, q, this.onScaleChanging.bind(this));
                Ne(this, Z, this.onRotationChanging.bind(this));
                Ne(this, pe, {
                  isEditing: !1,
                  isEmpty: !0,
                  hasSomethingToUndo: !1,
                  hasSomethingToRedo: !1,
                  hasSelectedEditor: !1
                });
                Ne(this, me, [0, 0]);
                Ne(this, _e, null);
                Ne(this, Be, null);
                Ne(this, ke, null);
                je(this, Be, oe), je(this, ke, He), je(this, R, at), this._eventBus = St, this._eventBus._on("editingaction", x(this, ye)), this._eventBus._on("pagechanging", x(this, ce)), this._eventBus._on("scalechanging", x(this, q)), this._eventBus._on("rotationchanging", x(this, Z)), je(this, M, yt.annotationStorage), je(this, A, yt.filterFactory), je(this, re, dt), this.viewParameters = {
                  realScale: t.PixelsPerInch.PDF_TO_CSS_UNITS,
                  rotation: 0
                };
              }
              static get _keyboardManager() {
                const oe = bt.prototype, He = (yt) => {
                  const {
                    activeElement: dt
                  } = document;
                  return dt && x(yt, Be).contains(dt) && yt.hasSomethingToControl();
                }, at = this.TRANSLATE_SMALL, St = this.TRANSLATE_BIG;
                return (0, n.shadow)(this, "_keyboardManager", new N([[["ctrl+a", "mac+meta+a"], oe.selectAll], [["ctrl+z", "mac+meta+z"], oe.undo], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], oe.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], oe.delete], [["Escape", "mac+Escape"], oe.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], oe.translateSelectedEditors, {
                  args: [-at, 0],
                  checker: He
                }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], oe.translateSelectedEditors, {
                  args: [-St, 0],
                  checker: He
                }], [["ArrowRight", "mac+ArrowRight"], oe.translateSelectedEditors, {
                  args: [at, 0],
                  checker: He
                }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], oe.translateSelectedEditors, {
                  args: [St, 0],
                  checker: He
                }], [["ArrowUp", "mac+ArrowUp"], oe.translateSelectedEditors, {
                  args: [0, -at],
                  checker: He
                }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], oe.translateSelectedEditors, {
                  args: [0, -St],
                  checker: He
                }], [["ArrowDown", "mac+ArrowDown"], oe.translateSelectedEditors, {
                  args: [0, at],
                  checker: He
                }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], oe.translateSelectedEditors, {
                  args: [0, St],
                  checker: He
                }]]));
              }
              destroy() {
                Te(this, de, va).call(this), Te(this, de, ui).call(this), this._eventBus._off("editingaction", x(this, ye)), this._eventBus._off("pagechanging", x(this, ce)), this._eventBus._off("scalechanging", x(this, q)), this._eventBus._off("rotationchanging", x(this, Z));
                for (const oe of x(this, C).values())
                  oe.destroy();
                x(this, C).clear(), x(this, f).clear(), x(this, j).clear(), je(this, a, null), x(this, $).clear(), x(this, I).destroy(), x(this, R).destroy();
              }
              get hcmFilter() {
                return (0, n.shadow)(this, "hcmFilter", x(this, re) ? x(this, A).addHCMFilter(x(this, re).foreground, x(this, re).background) : "none");
              }
              get direction() {
                return (0, n.shadow)(this, "direction", getComputedStyle(x(this, Be)).direction);
              }
              editAltText(oe) {
                var He;
                (He = x(this, R)) == null || He.editAltText(this, oe);
              }
              onPageChanging({
                pageNumber: oe
              }) {
                je(this, E, oe - 1);
              }
              focusMainContainer() {
                x(this, Be).focus();
              }
              findParent(oe, He) {
                for (const at of x(this, C).values()) {
                  const {
                    x: St,
                    y: yt,
                    width: dt,
                    height: ie
                  } = at.div.getBoundingClientRect();
                  if (oe >= St && oe <= St + dt && He >= yt && He <= yt + ie)
                    return at;
                }
                return null;
              }
              disableUserSelect(oe = !1) {
                x(this, ke).classList.toggle("noUserSelect", oe);
              }
              addShouldRescale(oe) {
                x(this, j).add(oe);
              }
              removeShouldRescale(oe) {
                x(this, j).delete(oe);
              }
              onScaleChanging({
                scale: oe
              }) {
                this.commitOrRemove(), this.viewParameters.realScale = oe * t.PixelsPerInch.PDF_TO_CSS_UNITS;
                for (const He of x(this, j))
                  He.onScaleChanging();
              }
              onRotationChanging({
                pagesRotation: oe
              }) {
                this.commitOrRemove(), this.viewParameters.rotation = oe;
              }
              addToAnnotationStorage(oe) {
                !oe.isEmpty() && x(this, M) && !x(this, M).has(oe.id) && x(this, M).setValue(oe.id, oe);
              }
              blur() {
                if (!this.hasSelection)
                  return;
                const {
                  activeElement: oe
                } = document;
                for (const He of x(this, $))
                  if (He.div.contains(oe)) {
                    je(this, U, [He, oe]), He._focusEventsAllowed = !1;
                    break;
                  }
              }
              focus() {
                if (!x(this, U))
                  return;
                const [oe, He] = x(this, U);
                je(this, U, null), He.addEventListener("focusin", () => {
                  oe._focusEventsAllowed = !0;
                }, {
                  once: !0
                }), He.focus();
              }
              addEditListeners() {
                Te(this, de, di).call(this), Te(this, de, hi).call(this);
              }
              removeEditListeners() {
                Te(this, de, va).call(this), Te(this, de, fi).call(this);
              }
              copy(oe) {
                var at;
                if (oe.preventDefault(), (at = x(this, a)) == null || at.commitOrRemove(), !this.hasSelection)
                  return;
                const He = [];
                for (const St of x(this, $)) {
                  const yt = St.serialize(!0);
                  yt && He.push(yt);
                }
                He.length !== 0 && oe.clipboardData.setData("application/pdfjs", JSON.stringify(He));
              }
              cut(oe) {
                this.copy(oe), this.delete();
              }
              paste(oe) {
                oe.preventDefault();
                const {
                  clipboardData: He
                } = oe;
                for (const yt of He.items)
                  for (const dt of x(this, D))
                    if (dt.isHandlingMimeForPasting(yt.type)) {
                      dt.paste(yt, this.currentLayer);
                      return;
                    }
                let at = He.getData("application/pdfjs");
                if (!at)
                  return;
                try {
                  at = JSON.parse(at);
                } catch (yt) {
                  (0, n.warn)(`paste: "${yt.message}".`);
                  return;
                }
                if (!Array.isArray(at))
                  return;
                this.unselectAll();
                const St = this.currentLayer;
                try {
                  const yt = [];
                  for (const te of at) {
                    const we = St.deserialize(te);
                    if (!we)
                      return;
                    yt.push(we);
                  }
                  const dt = () => {
                    for (const te of yt)
                      Te(this, de, mi).call(this, te);
                    Te(this, de, pi).call(this, yt);
                  }, ie = () => {
                    for (const te of yt)
                      te.remove();
                  };
                  this.addCommands({
                    cmd: dt,
                    undo: ie,
                    mustExec: !0
                  });
                } catch (yt) {
                  (0, n.warn)(`paste: "${yt.message}".`);
                }
              }
              keydown(oe) {
                var He;
                (He = this.getActive()) != null && He.shouldGetKeyboardEvents() || bt._keyboardManager.exec(this, oe);
              }
              onEditingAction(oe) {
                ["undo", "redo", "delete", "selectAll"].includes(oe.name) && this[oe.name]();
              }
              setEditingState(oe) {
                oe ? (Te(this, de, no).call(this), Te(this, de, di).call(this), Te(this, de, hi).call(this), Te(this, de, vr).call(this, {
                  isEditing: x(this, V) !== n.AnnotationEditorType.NONE,
                  isEmpty: Te(this, de, Qr).call(this),
                  hasSomethingToUndo: x(this, I).hasSomethingToUndo(),
                  hasSomethingToRedo: x(this, I).hasSomethingToRedo(),
                  hasSelectedEditor: !1
                })) : (Te(this, de, ui).call(this), Te(this, de, va).call(this), Te(this, de, fi).call(this), Te(this, de, vr).call(this, {
                  isEditing: !1
                }), this.disableUserSelect(!1));
              }
              registerEditorTypes(oe) {
                if (!x(this, D)) {
                  je(this, D, oe);
                  for (const He of x(this, D))
                    Te(this, de, Jr).call(this, He.defaultPropertiesToUpdate);
                }
              }
              getId() {
                return x(this, d).getId();
              }
              get currentLayer() {
                return x(this, C).get(x(this, E));
              }
              getLayer(oe) {
                return x(this, C).get(oe);
              }
              get currentPageIndex() {
                return x(this, E);
              }
              addLayer(oe) {
                x(this, C).set(oe.pageIndex, oe), x(this, _) ? oe.enable() : oe.disable();
              }
              removeLayer(oe) {
                x(this, C).delete(oe.pageIndex);
              }
              updateMode(oe, He = null) {
                if (x(this, V) !== oe) {
                  if (je(this, V, oe), oe === n.AnnotationEditorType.NONE) {
                    this.setEditingState(!1), Te(this, de, ao).call(this);
                    return;
                  }
                  this.setEditingState(!0), Te(this, de, ro).call(this), this.unselectAll();
                  for (const at of x(this, C).values())
                    at.updateMode(oe);
                  if (He) {
                    for (const at of x(this, f).values())
                      if (at.annotationElementId === He) {
                        this.setSelected(at), at.enterInEditMode();
                        break;
                      }
                  }
                }
              }
              updateToolbar(oe) {
                oe !== x(this, V) && this._eventBus.dispatch("switchannotationeditormode", {
                  source: this,
                  mode: oe
                });
              }
              updateParams(oe, He) {
                if (x(this, D)) {
                  if (oe === n.AnnotationEditorParamsType.CREATE) {
                    this.currentLayer.addNewEditor(oe);
                    return;
                  }
                  for (const at of x(this, $))
                    at.updateParams(oe, He);
                  for (const at of x(this, D))
                    at.updateDefaultParams(oe, He);
                }
              }
              enableWaiting(oe = !1) {
                if (x(this, F) !== oe) {
                  je(this, F, oe);
                  for (const He of x(this, C).values())
                    oe ? He.disableClick() : He.enableClick(), He.div.classList.toggle("waiting", oe);
                }
              }
              getEditors(oe) {
                const He = [];
                for (const at of x(this, f).values())
                  at.pageIndex === oe && He.push(at);
                return He;
              }
              getEditor(oe) {
                return x(this, f).get(oe);
              }
              addEditor(oe) {
                x(this, f).set(oe.id, oe);
              }
              removeEditor(oe) {
                var He;
                x(this, f).delete(oe.id), this.unselect(oe), (!oe.annotationElementId || !x(this, T).has(oe.annotationElementId)) && ((He = x(this, M)) == null || He.remove(oe.id));
              }
              addDeletedAnnotationElement(oe) {
                x(this, T).add(oe.annotationElementId), oe.deleted = !0;
              }
              isDeletedAnnotationElement(oe) {
                return x(this, T).has(oe);
              }
              removeDeletedAnnotationElement(oe) {
                x(this, T).delete(oe.annotationElementId), oe.deleted = !1;
              }
              setActiveEditor(oe) {
                x(this, a) !== oe && (je(this, a, oe), oe && Te(this, de, Jr).call(this, oe.propertiesToUpdate));
              }
              toggleSelected(oe) {
                if (x(this, $).has(oe)) {
                  x(this, $).delete(oe), oe.unselect(), Te(this, de, vr).call(this, {
                    hasSelectedEditor: this.hasSelection
                  });
                  return;
                }
                x(this, $).add(oe), oe.select(), Te(this, de, Jr).call(this, oe.propertiesToUpdate), Te(this, de, vr).call(this, {
                  hasSelectedEditor: !0
                });
              }
              setSelected(oe) {
                for (const He of x(this, $))
                  He !== oe && He.unselect();
                x(this, $).clear(), x(this, $).add(oe), oe.select(), Te(this, de, Jr).call(this, oe.propertiesToUpdate), Te(this, de, vr).call(this, {
                  hasSelectedEditor: !0
                });
              }
              isSelected(oe) {
                return x(this, $).has(oe);
              }
              unselect(oe) {
                oe.unselect(), x(this, $).delete(oe), Te(this, de, vr).call(this, {
                  hasSelectedEditor: this.hasSelection
                });
              }
              get hasSelection() {
                return x(this, $).size !== 0;
              }
              undo() {
                x(this, I).undo(), Te(this, de, vr).call(this, {
                  hasSomethingToUndo: x(this, I).hasSomethingToUndo(),
                  hasSomethingToRedo: !0,
                  isEmpty: Te(this, de, Qr).call(this)
                });
              }
              redo() {
                x(this, I).redo(), Te(this, de, vr).call(this, {
                  hasSomethingToUndo: !0,
                  hasSomethingToRedo: x(this, I).hasSomethingToRedo(),
                  isEmpty: Te(this, de, Qr).call(this)
                });
              }
              addCommands(oe) {
                x(this, I).add(oe), Te(this, de, vr).call(this, {
                  hasSomethingToUndo: !0,
                  hasSomethingToRedo: !1,
                  isEmpty: Te(this, de, Qr).call(this)
                });
              }
              delete() {
                if (this.commitOrRemove(), !this.hasSelection)
                  return;
                const oe = [...x(this, $)], He = () => {
                  for (const St of oe)
                    St.remove();
                }, at = () => {
                  for (const St of oe)
                    Te(this, de, mi).call(this, St);
                };
                this.addCommands({
                  cmd: He,
                  undo: at,
                  mustExec: !0
                });
              }
              commitOrRemove() {
                var oe;
                (oe = x(this, a)) == null || oe.commitOrRemove();
              }
              hasSomethingToControl() {
                return x(this, a) || this.hasSelection;
              }
              selectAll() {
                for (const oe of x(this, $))
                  oe.commit();
                Te(this, de, pi).call(this, x(this, f).values());
              }
              unselectAll() {
                if (x(this, a)) {
                  x(this, a).commitOrRemove();
                  return;
                }
                if (this.hasSelection) {
                  for (const oe of x(this, $))
                    oe.unselect();
                  x(this, $).clear(), Te(this, de, vr).call(this, {
                    hasSelectedEditor: !1
                  });
                }
              }
              translateSelectedEditors(oe, He, at = !1) {
                if (at || this.commitOrRemove(), !this.hasSelection)
                  return;
                x(this, me)[0] += oe, x(this, me)[1] += He;
                const [St, yt] = x(this, me), dt = [...x(this, $)], ie = 1e3;
                x(this, _e) && clearTimeout(x(this, _e)), je(this, _e, setTimeout(() => {
                  je(this, _e, null), x(this, me)[0] = x(this, me)[1] = 0, this.addCommands({
                    cmd: () => {
                      for (const te of dt)
                        x(this, f).has(te.id) && te.translateInPage(St, yt);
                    },
                    undo: () => {
                      for (const te of dt)
                        x(this, f).has(te.id) && te.translateInPage(-St, -yt);
                    },
                    mustExec: !1
                  });
                }, ie));
                for (const te of dt)
                  te.translateInPage(oe, He);
              }
              setUpDragSession() {
                if (this.hasSelection) {
                  this.disableUserSelect(!0), je(this, y, /* @__PURE__ */ new Map());
                  for (const oe of x(this, $))
                    x(this, y).set(oe, {
                      savedX: oe.x,
                      savedY: oe.y,
                      savedPageIndex: oe.pageIndex,
                      newX: 0,
                      newY: 0,
                      newPageIndex: -1
                    });
                }
              }
              endDragSession() {
                if (!x(this, y))
                  return !1;
                this.disableUserSelect(!1);
                const oe = x(this, y);
                je(this, y, null);
                let He = !1;
                for (const [{
                  x: St,
                  y: yt,
                  pageIndex: dt
                }, ie] of oe)
                  ie.newX = St, ie.newY = yt, ie.newPageIndex = dt, He || (He = St !== ie.savedX || yt !== ie.savedY || dt !== ie.savedPageIndex);
                if (!He)
                  return !1;
                const at = (St, yt, dt, ie) => {
                  if (x(this, f).has(St.id)) {
                    const te = x(this, C).get(ie);
                    te ? St._setParentAndPosition(te, yt, dt) : (St.pageIndex = ie, St.x = yt, St.y = dt);
                  }
                };
                return this.addCommands({
                  cmd: () => {
                    for (const [St, {
                      newX: yt,
                      newY: dt,
                      newPageIndex: ie
                    }] of oe)
                      at(St, yt, dt, ie);
                  },
                  undo: () => {
                    for (const [St, {
                      savedX: yt,
                      savedY: dt,
                      savedPageIndex: ie
                    }] of oe)
                      at(St, yt, dt, ie);
                  },
                  mustExec: !0
                }), !0;
              }
              dragSelectedEditors(oe, He) {
                if (x(this, y))
                  for (const at of x(this, y).keys())
                    at.drag(oe, He);
              }
              rebuild(oe) {
                if (oe.parent === null) {
                  const He = this.getLayer(oe.pageIndex);
                  He ? (He.changeParent(oe), He.addOrRebuild(oe)) : (this.addEditor(oe), this.addToAnnotationStorage(oe), oe.rebuild());
                } else
                  oe.parent.addOrRebuild(oe);
              }
              isActive(oe) {
                return x(this, a) === oe;
              }
              getActive() {
                return x(this, a);
              }
              getMode() {
                return x(this, V);
              }
              get imageManager() {
                return (0, n.shadow)(this, "imageManager", new G());
              }
            };
            a = new WeakMap(), f = new WeakMap(), C = new WeakMap(), R = new WeakMap(), M = new WeakMap(), I = new WeakMap(), E = new WeakMap(), T = new WeakMap(), y = new WeakMap(), D = new WeakMap(), j = new WeakMap(), A = new WeakMap(), d = new WeakMap(), _ = new WeakMap(), F = new WeakMap(), U = new WeakMap(), V = new WeakMap(), $ = new WeakMap(), re = new WeakMap(), ge = new WeakMap(), be = new WeakMap(), le = new WeakMap(), fe = new WeakMap(), Ae = new WeakMap(), qe = new WeakMap(), ye = new WeakMap(), ce = new WeakMap(), q = new WeakMap(), Z = new WeakMap(), pe = new WeakMap(), me = new WeakMap(), _e = new WeakMap(), Be = new WeakMap(), ke = new WeakMap(), de = new WeakSet(), no = function() {
              window.addEventListener("focus", x(this, be)), window.addEventListener("blur", x(this, ge));
            }, ui = function() {
              window.removeEventListener("focus", x(this, be)), window.removeEventListener("blur", x(this, ge));
            }, di = function() {
              window.addEventListener("keydown", x(this, qe), {
                capture: !0
              });
            }, va = function() {
              window.removeEventListener("keydown", x(this, qe), {
                capture: !0
              });
            }, hi = function() {
              document.addEventListener("copy", x(this, le)), document.addEventListener("cut", x(this, fe)), document.addEventListener("paste", x(this, Ae));
            }, fi = function() {
              document.removeEventListener("copy", x(this, le)), document.removeEventListener("cut", x(this, fe)), document.removeEventListener("paste", x(this, Ae));
            }, vr = function(oe) {
              Object.entries(oe).some(([at, St]) => x(this, pe)[at] !== St) && this._eventBus.dispatch("annotationeditorstateschanged", {
                source: this,
                details: Object.assign(x(this, pe), oe)
              });
            }, Jr = function(oe) {
              this._eventBus.dispatch("annotationeditorparamschanged", {
                source: this,
                details: oe
              });
            }, ro = function() {
              if (!x(this, _)) {
                je(this, _, !0);
                for (const oe of x(this, C).values())
                  oe.enable();
              }
            }, ao = function() {
              if (this.unselectAll(), x(this, _)) {
                je(this, _, !1);
                for (const oe of x(this, C).values())
                  oe.disable();
              }
            }, mi = function(oe) {
              const He = x(this, C).get(oe.pageIndex);
              He ? He.addOrRebuild(oe) : this.addEditor(oe);
            }, Qr = function() {
              if (x(this, f).size === 0)
                return !0;
              if (x(this, f).size === 1)
                for (const oe of x(this, f).values())
                  return oe.isEmpty();
              return !1;
            }, pi = function(oe) {
              x(this, $).clear();
              for (const He of oe)
                He.isEmpty() || (x(this, $).add(He), He.select());
              Te(this, de, vr).call(this, {
                hasSelectedEditor: !0
              });
            }, Tn(bt, "TRANSLATE_SMALL", 1), Tn(bt, "TRANSLATE_BIG", 10);
            let B = bt;
            L.AnnotationEditorUIManager = B;
          },
          /* 6 */
          /***/
          (e, L, p) => {
            var E, T, y, D, j, A, d, _, F, U, V, $, Vr, Hr, gi, ba, Ea, ea, ta;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.StatTimer = L.RenderingCancelledException = L.PixelsPerInch = L.PageViewport = L.PDFDateString = L.DOMStandardFontDataFactory = L.DOMSVGFactory = L.DOMFilterFactory = L.DOMCanvasFactory = L.DOMCMapReaderFactory = void 0, L.deprecated = g, L.getColorValues = f, L.getCurrentTransform = C, L.getCurrentTransformInverse = R, L.getFilenameFromUrl = m, L.getPdfFilenameFromUrl = s, L.getRGB = a, L.getXfaPageViewport = k, L.isDataScheme = r, L.isPdfFile = u, L.isValidFetchUrl = i, L.loadScript = b, L.noContextMenu = o, L.setLayerDimensions = M;
            var n = p(7), t = p(1);
            const l = "http://www.w3.org/2000/svg", I = class I {
            };
            Tn(I, "CSS", 96), Tn(I, "PDF", 72), Tn(I, "PDF_TO_CSS_UNITS", I.CSS / I.PDF);
            let W = I;
            L.PixelsPerInch = W;
            class Q extends n.BaseFilterFactory {
              constructor({
                docId: q,
                ownerDocument: Z = globalThis.document
              } = {}) {
                super();
                Ne(this, $);
                Ne(this, E);
                Ne(this, T);
                Ne(this, y);
                Ne(this, D);
                Ne(this, j);
                Ne(this, A);
                Ne(this, d);
                Ne(this, _);
                Ne(this, F);
                Ne(this, U);
                Ne(this, V, 0);
                je(this, y, q), je(this, D, Z);
              }
              addFilter(q) {
                if (!q)
                  return "none";
                let Z = x(this, $, Vr).get(q);
                if (Z)
                  return Z;
                let pe, me, _e, Be;
                if (q.length === 1) {
                  const Ge = q[0], st = new Array(256);
                  for (let it = 0; it < 256; it++)
                    st[it] = Ge[it] / 255;
                  Be = pe = me = _e = st.join(",");
                } else {
                  const [Ge, st, it] = q, _t = new Array(256), tt = new Array(256), Xe = new Array(256);
                  for (let ct = 0; ct < 256; ct++)
                    _t[ct] = Ge[ct] / 255, tt[ct] = st[ct] / 255, Xe[ct] = it[ct] / 255;
                  pe = _t.join(","), me = tt.join(","), _e = Xe.join(","), Be = `${pe}${me}${_e}`;
                }
                if (Z = x(this, $, Vr).get(Be), Z)
                  return x(this, $, Vr).set(q, Z), Z;
                const ke = `g_${x(this, y)}_transfer_map_${Zr(this, V)._++}`, de = `url(#${ke})`;
                x(this, $, Vr).set(q, de), x(this, $, Vr).set(Be, de);
                const $e = Te(this, $, ba).call(this, ke);
                return Te(this, $, ea).call(this, pe, me, _e, $e), de;
              }
              addHCMFilter(q, Z) {
                var st;
                const pe = `${q}-${Z}`;
                if (x(this, A) === pe)
                  return x(this, d);
                if (je(this, A, pe), je(this, d, "none"), (st = x(this, j)) == null || st.remove(), !q || !Z)
                  return x(this, d);
                const me = Te(this, $, ta).call(this, q);
                q = t.Util.makeHexColor(...me);
                const _e = Te(this, $, ta).call(this, Z);
                if (Z = t.Util.makeHexColor(..._e), x(this, $, Hr).style.color = "", q === "#000000" && Z === "#ffffff" || q === Z)
                  return x(this, d);
                const Be = new Array(256);
                for (let it = 0; it <= 255; it++) {
                  const _t = it / 255;
                  Be[it] = _t <= 0.03928 ? _t / 12.92 : ((_t + 0.055) / 1.055) ** 2.4;
                }
                const ke = Be.join(","), de = `g_${x(this, y)}_hcm_filter`, $e = je(this, _, Te(this, $, ba).call(this, de));
                Te(this, $, ea).call(this, ke, ke, ke, $e), Te(this, $, gi).call(this, $e);
                const Ge = (it, _t) => {
                  const tt = me[it] / 255, Xe = _e[it] / 255, ct = new Array(_t + 1);
                  for (let xt = 0; xt <= _t; xt++)
                    ct[xt] = tt + xt / _t * (Xe - tt);
                  return ct.join(",");
                };
                return Te(this, $, ea).call(this, Ge(0, 5), Ge(1, 5), Ge(2, 5), $e), je(this, d, `url(#${de})`), x(this, d);
              }
              addHighlightHCMFilter(q, Z, pe, me) {
                var Xe;
                const _e = `${q}-${Z}-${pe}-${me}`;
                if (x(this, F) === _e)
                  return x(this, U);
                if (je(this, F, _e), je(this, U, "none"), (Xe = x(this, _)) == null || Xe.remove(), !q || !Z)
                  return x(this, U);
                const [Be, ke] = [q, Z].map(Te(this, $, ta).bind(this));
                let de = Math.round(0.2126 * Be[0] + 0.7152 * Be[1] + 0.0722 * Be[2]), $e = Math.round(0.2126 * ke[0] + 0.7152 * ke[1] + 0.0722 * ke[2]), [Ge, st] = [pe, me].map(Te(this, $, ta).bind(this));
                $e < de && ([de, $e, Ge, st] = [$e, de, st, Ge]), x(this, $, Hr).style.color = "";
                const it = (ct, xt, We) => {
                  const Ce = new Array(256), Re = ($e - de) / We, lt = ct / 255, bt = (xt - ct) / (255 * We);
                  let Et = 0;
                  for (let oe = 0; oe <= We; oe++) {
                    const He = Math.round(de + oe * Re), at = lt + oe * bt;
                    for (let St = Et; St <= He; St++)
                      Ce[St] = at;
                    Et = He + 1;
                  }
                  for (let oe = Et; oe < 256; oe++)
                    Ce[oe] = Ce[Et - 1];
                  return Ce.join(",");
                }, _t = `g_${x(this, y)}_hcm_highlight_filter`, tt = je(this, _, Te(this, $, ba).call(this, _t));
                return Te(this, $, gi).call(this, tt), Te(this, $, ea).call(this, it(Ge[0], st[0], 5), it(Ge[1], st[1], 5), it(Ge[2], st[2], 5), tt), je(this, U, `url(#${_t})`), x(this, U);
              }
              destroy(q = !1) {
                q && (x(this, d) || x(this, U)) || (x(this, T) && (x(this, T).parentNode.parentNode.remove(), je(this, T, null)), x(this, E) && (x(this, E).clear(), je(this, E, null)), je(this, V, 0));
              }
            }
            E = new WeakMap(), T = new WeakMap(), y = new WeakMap(), D = new WeakMap(), j = new WeakMap(), A = new WeakMap(), d = new WeakMap(), _ = new WeakMap(), F = new WeakMap(), U = new WeakMap(), V = new WeakMap(), $ = new WeakSet(), Vr = function() {
              return x(this, E) || je(this, E, /* @__PURE__ */ new Map());
            }, Hr = function() {
              if (!x(this, T)) {
                const q = x(this, D).createElement("div"), {
                  style: Z
                } = q;
                Z.visibility = "hidden", Z.contain = "strict", Z.width = Z.height = 0, Z.position = "absolute", Z.top = Z.left = 0, Z.zIndex = -1;
                const pe = x(this, D).createElementNS(l, "svg");
                pe.setAttribute("width", 0), pe.setAttribute("height", 0), je(this, T, x(this, D).createElementNS(l, "defs")), q.append(pe), pe.append(x(this, T)), x(this, D).body.append(q);
              }
              return x(this, T);
            }, gi = function(q) {
              const Z = x(this, D).createElementNS(l, "feColorMatrix");
              Z.setAttribute("type", "matrix"), Z.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), q.append(Z);
            }, ba = function(q) {
              const Z = x(this, D).createElementNS(l, "filter");
              return Z.setAttribute("color-interpolation-filters", "sRGB"), Z.setAttribute("id", q), x(this, $, Hr).append(Z), Z;
            }, Ea = function(q, Z, pe) {
              const me = x(this, D).createElementNS(l, Z);
              me.setAttribute("type", "discrete"), me.setAttribute("tableValues", pe), q.append(me);
            }, ea = function(q, Z, pe, me) {
              const _e = x(this, D).createElementNS(l, "feComponentTransfer");
              me.append(_e), Te(this, $, Ea).call(this, _e, "feFuncR", q), Te(this, $, Ea).call(this, _e, "feFuncG", Z), Te(this, $, Ea).call(this, _e, "feFuncB", pe);
            }, ta = function(q) {
              return x(this, $, Hr).style.color = q, a(getComputedStyle(x(this, $, Hr)).getPropertyValue("color"));
            }, L.DOMFilterFactory = Q;
            class G extends n.BaseCanvasFactory {
              constructor({
                ownerDocument: ce = globalThis.document
              } = {}) {
                super(), this._document = ce;
              }
              _createCanvas(ce, q) {
                const Z = this._document.createElement("canvas");
                return Z.width = ce, Z.height = q, Z;
              }
            }
            L.DOMCanvasFactory = G;
            async function X(ye, ce = !1) {
              if (i(ye, document.baseURI)) {
                const q = await fetch(ye);
                if (!q.ok)
                  throw new Error(q.statusText);
                return ce ? new Uint8Array(await q.arrayBuffer()) : (0, t.stringToBytes)(await q.text());
              }
              return new Promise((q, Z) => {
                const pe = new XMLHttpRequest();
                pe.open("GET", ye, !0), ce && (pe.responseType = "arraybuffer"), pe.onreadystatechange = () => {
                  if (pe.readyState === XMLHttpRequest.DONE) {
                    if (pe.status === 200 || pe.status === 0) {
                      let me;
                      if (ce && pe.response ? me = new Uint8Array(pe.response) : !ce && pe.responseText && (me = (0, t.stringToBytes)(pe.responseText)), me) {
                        q(me);
                        return;
                      }
                    }
                    Z(new Error(pe.statusText));
                  }
                }, pe.send(null);
              });
            }
            class N extends n.BaseCMapReaderFactory {
              _fetchData(ce, q) {
                return X(ce, this.isCompressed).then((Z) => ({
                  cMapData: Z,
                  compressionType: q
                }));
              }
            }
            L.DOMCMapReaderFactory = N;
            class H extends n.BaseStandardFontDataFactory {
              _fetchData(ce) {
                return X(ce, !0);
              }
            }
            L.DOMStandardFontDataFactory = H;
            class B extends n.BaseSVGFactory {
              _createSVG(ce) {
                return document.createElementNS(l, ce);
              }
            }
            L.DOMSVGFactory = B;
            class P {
              constructor({
                viewBox: ce,
                scale: q,
                rotation: Z,
                offsetX: pe = 0,
                offsetY: me = 0,
                dontFlip: _e = !1
              }) {
                this.viewBox = ce, this.scale = q, this.rotation = Z, this.offsetX = pe, this.offsetY = me;
                const Be = (ce[2] + ce[0]) / 2, ke = (ce[3] + ce[1]) / 2;
                let de, $e, Ge, st;
                switch (Z %= 360, Z < 0 && (Z += 360), Z) {
                  case 180:
                    de = -1, $e = 0, Ge = 0, st = 1;
                    break;
                  case 90:
                    de = 0, $e = 1, Ge = 1, st = 0;
                    break;
                  case 270:
                    de = 0, $e = -1, Ge = -1, st = 0;
                    break;
                  case 0:
                    de = 1, $e = 0, Ge = 0, st = -1;
                    break;
                  default:
                    throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
                }
                _e && (Ge = -Ge, st = -st);
                let it, _t, tt, Xe;
                de === 0 ? (it = Math.abs(ke - ce[1]) * q + pe, _t = Math.abs(Be - ce[0]) * q + me, tt = (ce[3] - ce[1]) * q, Xe = (ce[2] - ce[0]) * q) : (it = Math.abs(Be - ce[0]) * q + pe, _t = Math.abs(ke - ce[1]) * q + me, tt = (ce[2] - ce[0]) * q, Xe = (ce[3] - ce[1]) * q), this.transform = [de * q, $e * q, Ge * q, st * q, it - de * q * Be - Ge * q * ke, _t - $e * q * Be - st * q * ke], this.width = tt, this.height = Xe;
              }
              get rawDims() {
                const {
                  viewBox: ce
                } = this;
                return (0, t.shadow)(this, "rawDims", {
                  pageWidth: ce[2] - ce[0],
                  pageHeight: ce[3] - ce[1],
                  pageX: ce[0],
                  pageY: ce[1]
                });
              }
              clone({
                scale: ce = this.scale,
                rotation: q = this.rotation,
                offsetX: Z = this.offsetX,
                offsetY: pe = this.offsetY,
                dontFlip: me = !1
              } = {}) {
                return new P({
                  viewBox: this.viewBox.slice(),
                  scale: ce,
                  rotation: q,
                  offsetX: Z,
                  offsetY: pe,
                  dontFlip: me
                });
              }
              convertToViewportPoint(ce, q) {
                return t.Util.applyTransform([ce, q], this.transform);
              }
              convertToViewportRectangle(ce) {
                const q = t.Util.applyTransform([ce[0], ce[1]], this.transform), Z = t.Util.applyTransform([ce[2], ce[3]], this.transform);
                return [q[0], q[1], Z[0], Z[1]];
              }
              convertToPdfPoint(ce, q) {
                return t.Util.applyInverseTransform([ce, q], this.transform);
              }
            }
            L.PageViewport = P;
            class S extends t.BaseException {
              constructor(ce, q = 0) {
                super(ce, "RenderingCancelledException"), this.extraDelay = q;
              }
            }
            L.RenderingCancelledException = S;
            function r(ye) {
              const ce = ye.length;
              let q = 0;
              for (; q < ce && ye[q].trim() === ""; )
                q++;
              return ye.substring(q, q + 5).toLowerCase() === "data:";
            }
            function u(ye) {
              return typeof ye == "string" && /\.pdf$/i.test(ye);
            }
            function m(ye, ce = !1) {
              return ce || ([ye] = ye.split(/[#?]/, 1)), ye.substring(ye.lastIndexOf("/") + 1);
            }
            function s(ye, ce = "document.pdf") {
              if (typeof ye != "string")
                return ce;
              if (r(ye))
                return (0, t.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), ce;
              const q = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, Z = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, pe = q.exec(ye);
              let me = Z.exec(pe[1]) || Z.exec(pe[2]) || Z.exec(pe[3]);
              if (me && (me = me[0], me.includes("%")))
                try {
                  me = Z.exec(decodeURIComponent(me))[0];
                } catch {
                }
              return me || ce;
            }
            class w {
              constructor() {
                Tn(this, "started", /* @__PURE__ */ Object.create(null));
                Tn(this, "times", []);
              }
              time(ce) {
                ce in this.started && (0, t.warn)(`Timer is already running for ${ce}`), this.started[ce] = Date.now();
              }
              timeEnd(ce) {
                ce in this.started || (0, t.warn)(`Timer has not been started for ${ce}`), this.times.push({
                  name: ce,
                  start: this.started[ce],
                  end: Date.now()
                }), delete this.started[ce];
              }
              toString() {
                const ce = [];
                let q = 0;
                for (const {
                  name: Z
                } of this.times)
                  q = Math.max(Z.length, q);
                for (const {
                  name: Z,
                  start: pe,
                  end: me
                } of this.times)
                  ce.push(`${Z.padEnd(q)} ${me - pe}ms
`);
                return ce.join("");
              }
            }
            L.StatTimer = w;
            function i(ye, ce) {
              try {
                const {
                  protocol: q
                } = ce ? new URL(ye, ce) : new URL(ye);
                return q === "http:" || q === "https:";
              } catch {
                return !1;
              }
            }
            function o(ye) {
              ye.preventDefault();
            }
            function b(ye, ce = !1) {
              return new Promise((q, Z) => {
                const pe = document.createElement("script");
                pe.src = ye, pe.onload = function(me) {
                  ce && pe.remove(), q(me);
                }, pe.onerror = function() {
                  Z(new Error(`Cannot load script at: ${pe.src}`));
                }, (document.head || document.documentElement).append(pe);
              });
            }
            function g(ye) {
              console.log("Deprecated API usage: " + ye);
            }
            let c;
            class v {
              static toDateObject(ce) {
                if (!ce || typeof ce != "string")
                  return null;
                c || (c = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
                const q = c.exec(ce);
                if (!q)
                  return null;
                const Z = parseInt(q[1], 10);
                let pe = parseInt(q[2], 10);
                pe = pe >= 1 && pe <= 12 ? pe - 1 : 0;
                let me = parseInt(q[3], 10);
                me = me >= 1 && me <= 31 ? me : 1;
                let _e = parseInt(q[4], 10);
                _e = _e >= 0 && _e <= 23 ? _e : 0;
                let Be = parseInt(q[5], 10);
                Be = Be >= 0 && Be <= 59 ? Be : 0;
                let ke = parseInt(q[6], 10);
                ke = ke >= 0 && ke <= 59 ? ke : 0;
                const de = q[7] || "Z";
                let $e = parseInt(q[8], 10);
                $e = $e >= 0 && $e <= 23 ? $e : 0;
                let Ge = parseInt(q[9], 10) || 0;
                return Ge = Ge >= 0 && Ge <= 59 ? Ge : 0, de === "-" ? (_e += $e, Be += Ge) : de === "+" && (_e -= $e, Be -= Ge), new Date(Date.UTC(Z, pe, me, _e, Be, ke));
              }
            }
            L.PDFDateString = v;
            function k(ye, {
              scale: ce = 1,
              rotation: q = 0
            }) {
              const {
                width: Z,
                height: pe
              } = ye.attributes.style, me = [0, 0, parseInt(Z), parseInt(pe)];
              return new P({
                viewBox: me,
                scale: ce,
                rotation: q
              });
            }
            function a(ye) {
              if (ye.startsWith("#")) {
                const ce = parseInt(ye.slice(1), 16);
                return [(ce & 16711680) >> 16, (ce & 65280) >> 8, ce & 255];
              }
              return ye.startsWith("rgb(") ? ye.slice(4, -1).split(",").map((ce) => parseInt(ce)) : ye.startsWith("rgba(") ? ye.slice(5, -1).split(",").map((ce) => parseInt(ce)).slice(0, 3) : ((0, t.warn)(`Not a valid color format: "${ye}"`), [0, 0, 0]);
            }
            function f(ye) {
              const ce = document.createElement("span");
              ce.style.visibility = "hidden", document.body.append(ce);
              for (const q of ye.keys()) {
                ce.style.color = q;
                const Z = window.getComputedStyle(ce).color;
                ye.set(q, a(Z));
              }
              ce.remove();
            }
            function C(ye) {
              const {
                a: ce,
                b: q,
                c: Z,
                d: pe,
                e: me,
                f: _e
              } = ye.getTransform();
              return [ce, q, Z, pe, me, _e];
            }
            function R(ye) {
              const {
                a: ce,
                b: q,
                c: Z,
                d: pe,
                e: me,
                f: _e
              } = ye.getTransform().invertSelf();
              return [ce, q, Z, pe, me, _e];
            }
            function M(ye, ce, q = !1, Z = !0) {
              if (ce instanceof P) {
                const {
                  pageWidth: pe,
                  pageHeight: me
                } = ce.rawDims, {
                  style: _e
                } = ye, Be = t.FeatureTest.isCSSRoundSupported, ke = `var(--scale-factor) * ${pe}px`, de = `var(--scale-factor) * ${me}px`, $e = Be ? `round(${ke}, 1px)` : `calc(${ke})`, Ge = Be ? `round(${de}, 1px)` : `calc(${de})`;
                !q || ce.rotation % 180 === 0 ? (_e.width = $e, _e.height = Ge) : (_e.width = Ge, _e.height = $e);
              }
              Z && ye.setAttribute("data-main-rotation", ce.rotation);
            }
          },
          /* 7 */
          /***/
          (e, L, p) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.BaseStandardFontDataFactory = L.BaseSVGFactory = L.BaseFilterFactory = L.BaseCanvasFactory = L.BaseCMapReaderFactory = void 0;
            var n = p(1);
            class t {
              constructor() {
                this.constructor === t && (0, n.unreachable)("Cannot initialize BaseFilterFactory.");
              }
              addFilter(N) {
                return "none";
              }
              addHCMFilter(N, H) {
                return "none";
              }
              addHighlightHCMFilter(N, H, B, P) {
                return "none";
              }
              destroy(N = !1) {
              }
            }
            L.BaseFilterFactory = t;
            class l {
              constructor() {
                this.constructor === l && (0, n.unreachable)("Cannot initialize BaseCanvasFactory.");
              }
              create(N, H) {
                if (N <= 0 || H <= 0)
                  throw new Error("Invalid canvas size");
                const B = this._createCanvas(N, H);
                return {
                  canvas: B,
                  context: B.getContext("2d")
                };
              }
              reset(N, H, B) {
                if (!N.canvas)
                  throw new Error("Canvas is not specified");
                if (H <= 0 || B <= 0)
                  throw new Error("Invalid canvas size");
                N.canvas.width = H, N.canvas.height = B;
              }
              destroy(N) {
                if (!N.canvas)
                  throw new Error("Canvas is not specified");
                N.canvas.width = 0, N.canvas.height = 0, N.canvas = null, N.context = null;
              }
              _createCanvas(N, H) {
                (0, n.unreachable)("Abstract method `_createCanvas` called.");
              }
            }
            L.BaseCanvasFactory = l;
            class W {
              constructor({
                baseUrl: N = null,
                isCompressed: H = !0
              }) {
                this.constructor === W && (0, n.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = N, this.isCompressed = H;
              }
              async fetch({
                name: N
              }) {
                if (!this.baseUrl)
                  throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                if (!N)
                  throw new Error("CMap name must be specified.");
                const H = this.baseUrl + N + (this.isCompressed ? ".bcmap" : ""), B = this.isCompressed ? n.CMapCompressionType.BINARY : n.CMapCompressionType.NONE;
                return this._fetchData(H, B).catch((P) => {
                  throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${H}`);
                });
              }
              _fetchData(N, H) {
                (0, n.unreachable)("Abstract method `_fetchData` called.");
              }
            }
            L.BaseCMapReaderFactory = W;
            class Q {
              constructor({
                baseUrl: N = null
              }) {
                this.constructor === Q && (0, n.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = N;
              }
              async fetch({
                filename: N
              }) {
                if (!this.baseUrl)
                  throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
                if (!N)
                  throw new Error("Font filename must be specified.");
                const H = `${this.baseUrl}${N}`;
                return this._fetchData(H).catch((B) => {
                  throw new Error(`Unable to load font data at: ${H}`);
                });
              }
              _fetchData(N) {
                (0, n.unreachable)("Abstract method `_fetchData` called.");
              }
            }
            L.BaseStandardFontDataFactory = Q;
            class G {
              constructor() {
                this.constructor === G && (0, n.unreachable)("Cannot initialize BaseSVGFactory.");
              }
              create(N, H, B = !1) {
                if (N <= 0 || H <= 0)
                  throw new Error("Invalid SVG dimensions");
                const P = this._createSVG("svg:svg");
                return P.setAttribute("version", "1.1"), B || (P.setAttribute("width", `${N}px`), P.setAttribute("height", `${H}px`)), P.setAttribute("preserveAspectRatio", "none"), P.setAttribute("viewBox", `0 0 ${N} ${H}`), P;
              }
              createElement(N) {
                if (typeof N != "string")
                  throw new Error("Invalid SVG element type");
                return this._createSVG(N);
              }
              _createSVG(N) {
                (0, n.unreachable)("Abstract method `_createSVG` called.");
              }
            }
            L.BaseSVGFactory = G;
          },
          /* 8 */
          /***/
          (e, L, p) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.MurmurHash3_64 = void 0;
            var n = p(1);
            const t = 3285377520, l = 4294901760, W = 65535;
            class Q {
              constructor(X) {
                this.h1 = X ? X & 4294967295 : t, this.h2 = X ? X & 4294967295 : t;
              }
              update(X) {
                let N, H;
                if (typeof X == "string") {
                  N = new Uint8Array(X.length * 2), H = 0;
                  for (let g = 0, c = X.length; g < c; g++) {
                    const v = X.charCodeAt(g);
                    v <= 255 ? N[H++] = v : (N[H++] = v >>> 8, N[H++] = v & 255);
                  }
                } else if ((0, n.isArrayBuffer)(X))
                  N = X.slice(), H = N.byteLength;
                else
                  throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                const B = H >> 2, P = H - B * 4, S = new Uint32Array(N.buffer, 0, B);
                let r = 0, u = 0, m = this.h1, s = this.h2;
                const w = 3432918353, i = 461845907, o = w & W, b = i & W;
                for (let g = 0; g < B; g++)
                  g & 1 ? (r = S[g], r = r * w & l | r * o & W, r = r << 15 | r >>> 17, r = r * i & l | r * b & W, m ^= r, m = m << 13 | m >>> 19, m = m * 5 + 3864292196) : (u = S[g], u = u * w & l | u * o & W, u = u << 15 | u >>> 17, u = u * i & l | u * b & W, s ^= u, s = s << 13 | s >>> 19, s = s * 5 + 3864292196);
                switch (r = 0, P) {
                  case 3:
                    r ^= N[B * 4 + 2] << 16;
                  case 2:
                    r ^= N[B * 4 + 1] << 8;
                  case 1:
                    r ^= N[B * 4], r = r * w & l | r * o & W, r = r << 15 | r >>> 17, r = r * i & l | r * b & W, B & 1 ? m ^= r : s ^= r;
                }
                this.h1 = m, this.h2 = s;
              }
              hexdigest() {
                let X = this.h1, N = this.h2;
                return X ^= N >>> 1, X = X * 3981806797 & l | X * 36045 & W, N = N * 4283543511 & l | ((N << 16 | X >>> 16) * 2950163797 & l) >>> 16, X ^= N >>> 1, X = X * 444984403 & l | X * 60499 & W, N = N * 3301882366 & l | ((N << 16 | X >>> 16) * 3120437893 & l) >>> 16, X ^= N >>> 1, (X >>> 0).toString(16).padStart(8, "0") + (N >>> 0).toString(16).padStart(8, "0");
              }
            }
            L.MurmurHash3_64 = Q;
          },
          /* 9 */
          /***/
          (e, L, p) => {
            var W;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.FontLoader = L.FontFaceObject = void 0;
            var n = p(1);
            class t {
              constructor({
                ownerDocument: G = globalThis.document,
                styleElement: X = null
              }) {
                Ne(this, W, /* @__PURE__ */ new Set());
                this._document = G, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
              }
              addNativeFontFace(G) {
                this.nativeFontFaces.add(G), this._document.fonts.add(G);
              }
              removeNativeFontFace(G) {
                this.nativeFontFaces.delete(G), this._document.fonts.delete(G);
              }
              insertRule(G) {
                this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
                const X = this.styleElement.sheet;
                X.insertRule(G, X.cssRules.length);
              }
              clear() {
                for (const G of this.nativeFontFaces)
                  this._document.fonts.delete(G);
                this.nativeFontFaces.clear(), x(this, W).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
              }
              async loadSystemFont(G) {
                if (!(!G || x(this, W).has(G.loadedName))) {
                  if ((0, n.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
                    const {
                      loadedName: X,
                      src: N,
                      style: H
                    } = G, B = new FontFace(X, N, H);
                    this.addNativeFontFace(B);
                    try {
                      await B.load(), x(this, W).add(X);
                    } catch {
                      (0, n.warn)(`Cannot load system font: ${G.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(B);
                    }
                    return;
                  }
                  (0, n.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
                }
              }
              async bind(G) {
                if (G.attached || G.missingFile && !G.systemFontInfo)
                  return;
                if (G.attached = !0, G.systemFontInfo) {
                  await this.loadSystemFont(G.systemFontInfo);
                  return;
                }
                if (this.isFontLoadingAPISupported) {
                  const N = G.createNativeFontFace();
                  if (N) {
                    this.addNativeFontFace(N);
                    try {
                      await N.loaded;
                    } catch (H) {
                      throw (0, n.warn)(`Failed to load font '${N.family}': '${H}'.`), G.disableFontFace = !0, H;
                    }
                  }
                  return;
                }
                const X = G.createFontFaceRule();
                if (X) {
                  if (this.insertRule(X), this.isSyncFontLoadingSupported)
                    return;
                  await new Promise((N) => {
                    const H = this._queueLoadingCallback(N);
                    this._prepareFontLoadEvent(G, H);
                  });
                }
              }
              get isFontLoadingAPISupported() {
                var X;
                const G = !!((X = this._document) != null && X.fonts);
                return (0, n.shadow)(this, "isFontLoadingAPISupported", G);
              }
              get isSyncFontLoadingSupported() {
                let G = !1;
                return (n.isNodeJS || typeof navigator < "u" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (G = !0), (0, n.shadow)(this, "isSyncFontLoadingSupported", G);
              }
              _queueLoadingCallback(G) {
                function X() {
                  for ((0, n.assert)(!H.done, "completeRequest() cannot be called twice."), H.done = !0; N.length > 0 && N[0].done; ) {
                    const B = N.shift();
                    setTimeout(B.callback, 0);
                  }
                }
                const {
                  loadingRequests: N
                } = this, H = {
                  done: !1,
                  complete: X,
                  callback: G
                };
                return N.push(H), H;
              }
              get _loadTestFont() {
                const G = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                return (0, n.shadow)(this, "_loadTestFont", G);
              }
              _prepareFontLoadEvent(G, X) {
                function N(a, f) {
                  return a.charCodeAt(f) << 24 | a.charCodeAt(f + 1) << 16 | a.charCodeAt(f + 2) << 8 | a.charCodeAt(f + 3) & 255;
                }
                function H(a, f, C, R) {
                  const M = a.substring(0, f), I = a.substring(f + C);
                  return M + R + I;
                }
                let B, P;
                const S = this._document.createElement("canvas");
                S.width = 1, S.height = 1;
                const r = S.getContext("2d");
                let u = 0;
                function m(a, f) {
                  if (++u > 30) {
                    (0, n.warn)("Load test font never loaded."), f();
                    return;
                  }
                  if (r.font = "30px " + a, r.fillText(".", 0, 20), r.getImageData(0, 0, 1, 1).data[3] > 0) {
                    f();
                    return;
                  }
                  setTimeout(m.bind(null, a, f));
                }
                const s = `lt${Date.now()}${this.loadTestFontId++}`;
                let w = this._loadTestFont;
                w = H(w, 976, s.length, s);
                const o = 16, b = 1482184792;
                let g = N(w, o);
                for (B = 0, P = s.length - 3; B < P; B += 4)
                  g = g - b + N(s, B) | 0;
                B < s.length && (g = g - b + N(s + "XXX", B) | 0), w = H(w, o, 4, (0, n.string32)(g));
                const c = `url(data:font/opentype;base64,${btoa(w)});`, v = `@font-face {font-family:"${s}";src:${c}}`;
                this.insertRule(v);
                const k = this._document.createElement("div");
                k.style.visibility = "hidden", k.style.width = k.style.height = "10px", k.style.position = "absolute", k.style.top = k.style.left = "0px";
                for (const a of [G.loadedName, s]) {
                  const f = this._document.createElement("span");
                  f.textContent = "Hi", f.style.fontFamily = a, k.append(f);
                }
                this._document.body.append(k), m(s, () => {
                  k.remove(), X.complete();
                });
              }
            }
            W = new WeakMap(), L.FontLoader = t;
            class l {
              constructor(G, {
                isEvalSupported: X = !0,
                disableFontFace: N = !1,
                ignoreErrors: H = !1,
                inspectFont: B = null
              }) {
                this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                for (const P in G)
                  this[P] = G[P];
                this.isEvalSupported = X !== !1, this.disableFontFace = N === !0, this.ignoreErrors = H === !0, this._inspectFont = B;
              }
              createNativeFontFace() {
                var X;
                if (!this.data || this.disableFontFace)
                  return null;
                let G;
                if (!this.cssFontInfo)
                  G = new FontFace(this.loadedName, this.data, {});
                else {
                  const N = {
                    weight: this.cssFontInfo.fontWeight
                  };
                  this.cssFontInfo.italicAngle && (N.style = `oblique ${this.cssFontInfo.italicAngle}deg`), G = new FontFace(this.cssFontInfo.fontFamily, this.data, N);
                }
                return (X = this._inspectFont) == null || X.call(this, this), G;
              }
              createFontFaceRule() {
                var H;
                if (!this.data || this.disableFontFace)
                  return null;
                const G = (0, n.bytesToString)(this.data), X = `url(data:${this.mimetype};base64,${btoa(G)});`;
                let N;
                if (!this.cssFontInfo)
                  N = `@font-face {font-family:"${this.loadedName}";src:${X}}`;
                else {
                  let B = `font-weight: ${this.cssFontInfo.fontWeight};`;
                  this.cssFontInfo.italicAngle && (B += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), N = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${B}src:${X}}`;
                }
                return (H = this._inspectFont) == null || H.call(this, this, X), N;
              }
              getPathGenerator(G, X) {
                if (this.compiledGlyphs[X] !== void 0)
                  return this.compiledGlyphs[X];
                let N;
                try {
                  N = G.get(this.loadedName + "_path_" + X);
                } catch (H) {
                  if (!this.ignoreErrors)
                    throw H;
                  return (0, n.warn)(`getPathGenerator - ignoring character: "${H}".`), this.compiledGlyphs[X] = function(B, P) {
                  };
                }
                if (this.isEvalSupported && n.FeatureTest.isEvalSupported) {
                  const H = [];
                  for (const B of N) {
                    const P = B.args !== void 0 ? B.args.join(",") : "";
                    H.push("c.", B.cmd, "(", P, `);
`);
                  }
                  return this.compiledGlyphs[X] = new Function("c", "size", H.join(""));
                }
                return this.compiledGlyphs[X] = function(H, B) {
                  for (const P of N)
                    P.cmd === "scale" && (P.args = [B, -B]), H[P.cmd].apply(H, P.args);
                };
              }
            }
            L.FontFaceObject = l;
          },
          /* 10 */
          /***/
          (e, L, p) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.NodeStandardFontDataFactory = L.NodeFilterFactory = L.NodeCanvasFactory = L.NodeCMapReaderFactory = void 0;
            var n = p(7);
            p(1);
            const t = function(X) {
              return new Promise((N, H) => {
                require$$5.readFile(X, (P, S) => {
                  if (P || !S) {
                    H(new Error(P));
                    return;
                  }
                  N(new Uint8Array(S));
                });
              });
            };
            class l extends n.BaseFilterFactory {
            }
            L.NodeFilterFactory = l;
            class W extends n.BaseCanvasFactory {
              _createCanvas(N, H) {
                return require$$5.createCanvas(N, H);
              }
            }
            L.NodeCanvasFactory = W;
            class Q extends n.BaseCMapReaderFactory {
              _fetchData(N, H) {
                return t(N).then((B) => ({
                  cMapData: B,
                  compressionType: H
                }));
              }
            }
            L.NodeCMapReaderFactory = Q;
            class G extends n.BaseStandardFontDataFactory {
              _fetchData(N) {
                return t(N);
              }
            }
            L.NodeStandardFontDataFactory = G;
          },
          /* 11 */
          /***/
          (e, L, p) => {
            var T, vi, bi;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.CanvasGraphics = void 0;
            var n = p(1), t = p(6), l = p(12), W = p(13);
            const Q = 16, G = 100, X = 4096, N = 15, H = 10, B = 1e3, P = 16;
            function S(A, d) {
              if (A._removeMirroring)
                throw new Error("Context is already forwarding operations.");
              A.__originalSave = A.save, A.__originalRestore = A.restore, A.__originalRotate = A.rotate, A.__originalScale = A.scale, A.__originalTranslate = A.translate, A.__originalTransform = A.transform, A.__originalSetTransform = A.setTransform, A.__originalResetTransform = A.resetTransform, A.__originalClip = A.clip, A.__originalMoveTo = A.moveTo, A.__originalLineTo = A.lineTo, A.__originalBezierCurveTo = A.bezierCurveTo, A.__originalRect = A.rect, A.__originalClosePath = A.closePath, A.__originalBeginPath = A.beginPath, A._removeMirroring = () => {
                A.save = A.__originalSave, A.restore = A.__originalRestore, A.rotate = A.__originalRotate, A.scale = A.__originalScale, A.translate = A.__originalTranslate, A.transform = A.__originalTransform, A.setTransform = A.__originalSetTransform, A.resetTransform = A.__originalResetTransform, A.clip = A.__originalClip, A.moveTo = A.__originalMoveTo, A.lineTo = A.__originalLineTo, A.bezierCurveTo = A.__originalBezierCurveTo, A.rect = A.__originalRect, A.closePath = A.__originalClosePath, A.beginPath = A.__originalBeginPath, delete A._removeMirroring;
              }, A.save = function() {
                d.save(), this.__originalSave();
              }, A.restore = function() {
                d.restore(), this.__originalRestore();
              }, A.translate = function(F, U) {
                d.translate(F, U), this.__originalTranslate(F, U);
              }, A.scale = function(F, U) {
                d.scale(F, U), this.__originalScale(F, U);
              }, A.transform = function(F, U, V, $, re, ge) {
                d.transform(F, U, V, $, re, ge), this.__originalTransform(F, U, V, $, re, ge);
              }, A.setTransform = function(F, U, V, $, re, ge) {
                d.setTransform(F, U, V, $, re, ge), this.__originalSetTransform(F, U, V, $, re, ge);
              }, A.resetTransform = function() {
                d.resetTransform(), this.__originalResetTransform();
              }, A.rotate = function(F) {
                d.rotate(F), this.__originalRotate(F);
              }, A.clip = function(F) {
                d.clip(F), this.__originalClip(F);
              }, A.moveTo = function(_, F) {
                d.moveTo(_, F), this.__originalMoveTo(_, F);
              }, A.lineTo = function(_, F) {
                d.lineTo(_, F), this.__originalLineTo(_, F);
              }, A.bezierCurveTo = function(_, F, U, V, $, re) {
                d.bezierCurveTo(_, F, U, V, $, re), this.__originalBezierCurveTo(_, F, U, V, $, re);
              }, A.rect = function(_, F, U, V) {
                d.rect(_, F, U, V), this.__originalRect(_, F, U, V);
              }, A.closePath = function() {
                d.closePath(), this.__originalClosePath();
              }, A.beginPath = function() {
                d.beginPath(), this.__originalBeginPath();
              };
            }
            class r {
              constructor(d) {
                this.canvasFactory = d, this.cache = /* @__PURE__ */ Object.create(null);
              }
              getCanvas(d, _, F) {
                let U;
                return this.cache[d] !== void 0 ? (U = this.cache[d], this.canvasFactory.reset(U, _, F)) : (U = this.canvasFactory.create(_, F), this.cache[d] = U), U;
              }
              delete(d) {
                delete this.cache[d];
              }
              clear() {
                for (const d in this.cache) {
                  const _ = this.cache[d];
                  this.canvasFactory.destroy(_), delete this.cache[d];
                }
              }
            }
            function u(A, d, _, F, U, V, $, re, ge, be) {
              const [le, fe, Ae, qe, ye, ce] = (0, t.getCurrentTransform)(A);
              if (fe === 0 && Ae === 0) {
                const pe = $ * le + ye, me = Math.round(pe), _e = re * qe + ce, Be = Math.round(_e), ke = ($ + ge) * le + ye, de = Math.abs(Math.round(ke) - me) || 1, $e = (re + be) * qe + ce, Ge = Math.abs(Math.round($e) - Be) || 1;
                return A.setTransform(Math.sign(le), 0, 0, Math.sign(qe), me, Be), A.drawImage(d, _, F, U, V, 0, 0, de, Ge), A.setTransform(le, fe, Ae, qe, ye, ce), [de, Ge];
              }
              if (le === 0 && qe === 0) {
                const pe = re * Ae + ye, me = Math.round(pe), _e = $ * fe + ce, Be = Math.round(_e), ke = (re + be) * Ae + ye, de = Math.abs(Math.round(ke) - me) || 1, $e = ($ + ge) * fe + ce, Ge = Math.abs(Math.round($e) - Be) || 1;
                return A.setTransform(0, Math.sign(fe), Math.sign(Ae), 0, me, Be), A.drawImage(d, _, F, U, V, 0, 0, Ge, de), A.setTransform(le, fe, Ae, qe, ye, ce), [Ge, de];
              }
              A.drawImage(d, _, F, U, V, $, re, ge, be);
              const q = Math.hypot(le, fe), Z = Math.hypot(Ae, qe);
              return [q * ge, Z * be];
            }
            function m(A) {
              const {
                width: d,
                height: _
              } = A;
              if (d > B || _ > B)
                return null;
              const F = 1e3, U = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), V = d + 1;
              let $ = new Uint8Array(V * (_ + 1)), re, ge, be;
              const le = d + 7 & -8;
              let fe = new Uint8Array(le * _), Ae = 0;
              for (const Z of A.data) {
                let pe = 128;
                for (; pe > 0; )
                  fe[Ae++] = Z & pe ? 0 : 255, pe >>= 1;
              }
              let qe = 0;
              for (Ae = 0, fe[Ae] !== 0 && ($[0] = 1, ++qe), ge = 1; ge < d; ge++)
                fe[Ae] !== fe[Ae + 1] && ($[ge] = fe[Ae] ? 2 : 1, ++qe), Ae++;
              for (fe[Ae] !== 0 && ($[ge] = 2, ++qe), re = 1; re < _; re++) {
                Ae = re * le, be = re * V, fe[Ae - le] !== fe[Ae] && ($[be] = fe[Ae] ? 1 : 8, ++qe);
                let Z = (fe[Ae] ? 4 : 0) + (fe[Ae - le] ? 8 : 0);
                for (ge = 1; ge < d; ge++)
                  Z = (Z >> 2) + (fe[Ae + 1] ? 4 : 0) + (fe[Ae - le + 1] ? 8 : 0), U[Z] && ($[be + ge] = U[Z], ++qe), Ae++;
                if (fe[Ae - le] !== fe[Ae] && ($[be + ge] = fe[Ae] ? 2 : 4, ++qe), qe > F)
                  return null;
              }
              for (Ae = le * (_ - 1), be = re * V, fe[Ae] !== 0 && ($[be] = 8, ++qe), ge = 1; ge < d; ge++)
                fe[Ae] !== fe[Ae + 1] && ($[be + ge] = fe[Ae] ? 4 : 8, ++qe), Ae++;
              if (fe[Ae] !== 0 && ($[be + ge] = 4, ++qe), qe > F)
                return null;
              const ye = new Int32Array([0, V, -1, 0, -V, 0, 0, 0, 1]), ce = new Path2D();
              for (re = 0; qe && re <= _; re++) {
                let Z = re * V;
                const pe = Z + d;
                for (; Z < pe && !$[Z]; )
                  Z++;
                if (Z === pe)
                  continue;
                ce.moveTo(Z % V, re);
                const me = Z;
                let _e = $[Z];
                do {
                  const Be = ye[_e];
                  do
                    Z += Be;
                  while (!$[Z]);
                  const ke = $[Z];
                  ke !== 5 && ke !== 10 ? (_e = ke, $[Z] = 0) : (_e = ke & 51 * _e >> 4, $[Z] &= _e >> 2 | _e << 2), ce.lineTo(Z % V, Z / V | 0), $[Z] || --qe;
                } while (me !== Z);
                --re;
              }
              return fe = null, $ = null, function(Z) {
                Z.save(), Z.scale(1 / d, -1 / _), Z.translate(0, -_), Z.fill(ce), Z.beginPath(), Z.restore();
              };
            }
            class s {
              constructor(d, _) {
                this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = n.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = n.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = n.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, d, _]);
              }
              clone() {
                const d = Object.create(this);
                return d.clipBox = this.clipBox.slice(), d;
              }
              setCurrentPoint(d, _) {
                this.x = d, this.y = _;
              }
              updatePathMinMax(d, _, F) {
                [_, F] = n.Util.applyTransform([_, F], d), this.minX = Math.min(this.minX, _), this.minY = Math.min(this.minY, F), this.maxX = Math.max(this.maxX, _), this.maxY = Math.max(this.maxY, F);
              }
              updateRectMinMax(d, _) {
                const F = n.Util.applyTransform(_, d), U = n.Util.applyTransform(_.slice(2), d);
                this.minX = Math.min(this.minX, F[0], U[0]), this.minY = Math.min(this.minY, F[1], U[1]), this.maxX = Math.max(this.maxX, F[0], U[0]), this.maxY = Math.max(this.maxY, F[1], U[1]);
              }
              updateScalingPathMinMax(d, _) {
                n.Util.scaleMinMax(d, _), this.minX = Math.min(this.minX, _[0]), this.maxX = Math.max(this.maxX, _[1]), this.minY = Math.min(this.minY, _[2]), this.maxY = Math.max(this.maxY, _[3]);
              }
              updateCurvePathMinMax(d, _, F, U, V, $, re, ge, be, le) {
                const fe = n.Util.bezierBoundingBox(_, F, U, V, $, re, ge, be);
                if (le) {
                  le[0] = Math.min(le[0], fe[0], fe[2]), le[1] = Math.max(le[1], fe[0], fe[2]), le[2] = Math.min(le[2], fe[1], fe[3]), le[3] = Math.max(le[3], fe[1], fe[3]);
                  return;
                }
                this.updateRectMinMax(d, fe);
              }
              getPathBoundingBox(d = l.PathType.FILL, _ = null) {
                const F = [this.minX, this.minY, this.maxX, this.maxY];
                if (d === l.PathType.STROKE) {
                  _ || (0, n.unreachable)("Stroke bounding box must include transform.");
                  const U = n.Util.singularValueDecompose2dScale(_), V = U[0] * this.lineWidth / 2, $ = U[1] * this.lineWidth / 2;
                  F[0] -= V, F[1] -= $, F[2] += V, F[3] += $;
                }
                return F;
              }
              updateClipFromPath() {
                const d = n.Util.intersect(this.clipBox, this.getPathBoundingBox());
                this.startNewPathAndClipBox(d || [0, 0, 0, 0]);
              }
              isEmptyClip() {
                return this.minX === 1 / 0;
              }
              startNewPathAndClipBox(d) {
                this.clipBox = d, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
              }
              getClippedPathBoundingBox(d = l.PathType.FILL, _ = null) {
                return n.Util.intersect(this.clipBox, this.getPathBoundingBox(d, _));
              }
            }
            function w(A, d) {
              if (typeof ImageData < "u" && d instanceof ImageData) {
                A.putImageData(d, 0, 0);
                return;
              }
              const _ = d.height, F = d.width, U = _ % P, V = (_ - U) / P, $ = U === 0 ? V : V + 1, re = A.createImageData(F, P);
              let ge = 0, be;
              const le = d.data, fe = re.data;
              let Ae, qe, ye, ce;
              if (d.kind === n.ImageKind.GRAYSCALE_1BPP) {
                const q = le.byteLength, Z = new Uint32Array(fe.buffer, 0, fe.byteLength >> 2), pe = Z.length, me = F + 7 >> 3, _e = 4294967295, Be = n.FeatureTest.isLittleEndian ? 4278190080 : 255;
                for (Ae = 0; Ae < $; Ae++) {
                  for (ye = Ae < V ? P : U, be = 0, qe = 0; qe < ye; qe++) {
                    const ke = q - ge;
                    let de = 0;
                    const $e = ke > me ? F : ke * 8 - 7, Ge = $e & -8;
                    let st = 0, it = 0;
                    for (; de < Ge; de += 8)
                      it = le[ge++], Z[be++] = it & 128 ? _e : Be, Z[be++] = it & 64 ? _e : Be, Z[be++] = it & 32 ? _e : Be, Z[be++] = it & 16 ? _e : Be, Z[be++] = it & 8 ? _e : Be, Z[be++] = it & 4 ? _e : Be, Z[be++] = it & 2 ? _e : Be, Z[be++] = it & 1 ? _e : Be;
                    for (; de < $e; de++)
                      st === 0 && (it = le[ge++], st = 128), Z[be++] = it & st ? _e : Be, st >>= 1;
                  }
                  for (; be < pe; )
                    Z[be++] = 0;
                  A.putImageData(re, 0, Ae * P);
                }
              } else if (d.kind === n.ImageKind.RGBA_32BPP) {
                for (qe = 0, ce = F * P * 4, Ae = 0; Ae < V; Ae++)
                  fe.set(le.subarray(ge, ge + ce)), ge += ce, A.putImageData(re, 0, qe), qe += P;
                Ae < $ && (ce = F * U * 4, fe.set(le.subarray(ge, ge + ce)), A.putImageData(re, 0, qe));
              } else if (d.kind === n.ImageKind.RGB_24BPP)
                for (ye = P, ce = F * ye, Ae = 0; Ae < $; Ae++) {
                  for (Ae >= V && (ye = U, ce = F * ye), be = 0, qe = ce; qe--; )
                    fe[be++] = le[ge++], fe[be++] = le[ge++], fe[be++] = le[ge++], fe[be++] = 255;
                  A.putImageData(re, 0, Ae * P);
                }
              else
                throw new Error(`bad image kind: ${d.kind}`);
            }
            function i(A, d) {
              if (d.bitmap) {
                A.drawImage(d.bitmap, 0, 0);
                return;
              }
              const _ = d.height, F = d.width, U = _ % P, V = (_ - U) / P, $ = U === 0 ? V : V + 1, re = A.createImageData(F, P);
              let ge = 0;
              const be = d.data, le = re.data;
              for (let fe = 0; fe < $; fe++) {
                const Ae = fe < V ? P : U;
                ({
                  srcPos: ge
                } = (0, W.convertBlackAndWhiteToRGBA)({
                  src: be,
                  srcPos: ge,
                  dest: le,
                  width: F,
                  height: Ae,
                  nonBlackColor: 0
                })), A.putImageData(re, 0, fe * P);
              }
            }
            function o(A, d) {
              const _ = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
              for (const F of _)
                A[F] !== void 0 && (d[F] = A[F]);
              A.setLineDash !== void 0 && (d.setLineDash(A.getLineDash()), d.lineDashOffset = A.lineDashOffset);
            }
            function b(A) {
              if (A.strokeStyle = A.fillStyle = "#000000", A.fillRule = "nonzero", A.globalAlpha = 1, A.lineWidth = 1, A.lineCap = "butt", A.lineJoin = "miter", A.miterLimit = 10, A.globalCompositeOperation = "source-over", A.font = "10px sans-serif", A.setLineDash !== void 0 && (A.setLineDash([]), A.lineDashOffset = 0), !n.isNodeJS) {
                const {
                  filter: d
                } = A;
                d !== "none" && d !== "" && (A.filter = "none");
              }
            }
            function g(A, d, _, F) {
              const U = A.length;
              for (let V = 3; V < U; V += 4) {
                const $ = A[V];
                if ($ === 0)
                  A[V - 3] = d, A[V - 2] = _, A[V - 1] = F;
                else if ($ < 255) {
                  const re = 255 - $;
                  A[V - 3] = A[V - 3] * $ + d * re >> 8, A[V - 2] = A[V - 2] * $ + _ * re >> 8, A[V - 1] = A[V - 1] * $ + F * re >> 8;
                }
              }
            }
            function c(A, d, _) {
              const F = A.length, U = 1 / 255;
              for (let V = 3; V < F; V += 4) {
                const $ = _ ? _[A[V]] : A[V];
                d[V] = d[V] * $ * U | 0;
              }
            }
            function v(A, d, _) {
              const F = A.length;
              for (let U = 3; U < F; U += 4) {
                const V = A[U - 3] * 77 + A[U - 2] * 152 + A[U - 1] * 28;
                d[U] = _ ? d[U] * _[V >> 8] >> 8 : d[U] * V >> 16;
              }
            }
            function k(A, d, _, F, U, V, $, re, ge, be, le) {
              const fe = !!V, Ae = fe ? V[0] : 0, qe = fe ? V[1] : 0, ye = fe ? V[2] : 0, ce = U === "Luminosity" ? v : c, Z = Math.min(F, Math.ceil(1048576 / _));
              for (let pe = 0; pe < F; pe += Z) {
                const me = Math.min(Z, F - pe), _e = A.getImageData(re - be, pe + (ge - le), _, me), Be = d.getImageData(re, pe + ge, _, me);
                fe && g(_e.data, Ae, qe, ye), ce(_e.data, Be.data, $), d.putImageData(Be, re, pe + ge);
              }
            }
            function a(A, d, _, F) {
              const U = F[0], V = F[1], $ = F[2] - U, re = F[3] - V;
              $ === 0 || re === 0 || (k(d.context, _, $, re, d.subtype, d.backdrop, d.transferMap, U, V, d.offsetX, d.offsetY), A.save(), A.globalAlpha = 1, A.globalCompositeOperation = "source-over", A.setTransform(1, 0, 0, 1, 0, 0), A.drawImage(_.canvas, 0, 0), A.restore());
            }
            function f(A, d) {
              const _ = n.Util.singularValueDecompose2dScale(A);
              _[0] = Math.fround(_[0]), _[1] = Math.fround(_[1]);
              const F = Math.fround((globalThis.devicePixelRatio || 1) * t.PixelsPerInch.PDF_TO_CSS_UNITS);
              return d !== void 0 ? d : _[0] <= F || _[1] <= F;
            }
            const C = ["butt", "round", "square"], R = ["miter", "round", "bevel"], M = {}, I = {}, j = class j {
              constructor(d, _, F, U, V, {
                optionalContentConfig: $,
                markedContentStack: re = null
              }, ge, be) {
                Ne(this, T);
                this.ctx = d, this.current = new s(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = _, this.objs = F, this.canvasFactory = U, this.filterFactory = V, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = re || [], this.optionalContentConfig = $, this.cachedCanvases = new r(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = ge, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = be, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
              }
              getObject(d, _ = null) {
                return typeof d == "string" ? d.startsWith("g_") ? this.commonObjs.get(d) : this.objs.get(d) : _;
              }
              beginDrawing({
                transform: d,
                viewport: _,
                transparency: F = !1,
                background: U = null
              }) {
                const V = this.ctx.canvas.width, $ = this.ctx.canvas.height, re = this.ctx.fillStyle;
                if (this.ctx.fillStyle = U || "#ffffff", this.ctx.fillRect(0, 0, V, $), this.ctx.fillStyle = re, F) {
                  const ge = this.cachedCanvases.getCanvas("transparent", V, $);
                  this.compositeCtx = this.ctx, this.transparentCanvas = ge.canvas, this.ctx = ge.context, this.ctx.save(), this.ctx.transform(...(0, t.getCurrentTransform)(this.compositeCtx));
                }
                this.ctx.save(), b(this.ctx), d && (this.ctx.transform(...d), this.outputScaleX = d[0], this.outputScaleY = d[0]), this.ctx.transform(..._.transform), this.viewportScale = _.scale, this.baseTransform = (0, t.getCurrentTransform)(this.ctx);
              }
              executeOperatorList(d, _, F, U) {
                const V = d.argsArray, $ = d.fnArray;
                let re = _ || 0;
                const ge = V.length;
                if (ge === re)
                  return re;
                const be = ge - re > H && typeof F == "function", le = be ? Date.now() + N : 0;
                let fe = 0;
                const Ae = this.commonObjs, qe = this.objs;
                let ye;
                for (; ; ) {
                  if (U !== void 0 && re === U.nextBreakPoint)
                    return U.breakIt(re, F), re;
                  if (ye = $[re], ye !== n.OPS.dependency)
                    this[ye].apply(this, V[re]);
                  else
                    for (const ce of V[re]) {
                      const q = ce.startsWith("g_") ? Ae : qe;
                      if (!q.has(ce))
                        return q.get(ce, F), re;
                    }
                  if (re++, re === ge)
                    return re;
                  if (be && ++fe > H) {
                    if (Date.now() > le)
                      return F(), re;
                    fe = 0;
                  }
                }
              }
              endDrawing() {
                Te(this, T, vi).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
                for (const d of this._cachedBitmapsMap.values()) {
                  for (const _ of d.values())
                    typeof HTMLCanvasElement < "u" && _ instanceof HTMLCanvasElement && (_.width = _.height = 0);
                  d.clear();
                }
                this._cachedBitmapsMap.clear(), Te(this, T, bi).call(this);
              }
              _scaleImage(d, _) {
                const F = d.width, U = d.height;
                let V = Math.max(Math.hypot(_[0], _[1]), 1), $ = Math.max(Math.hypot(_[2], _[3]), 1), re = F, ge = U, be = "prescale1", le, fe;
                for (; V > 2 && re > 1 || $ > 2 && ge > 1; ) {
                  let Ae = re, qe = ge;
                  V > 2 && re > 1 && (Ae = re >= 16384 ? Math.floor(re / 2) - 1 || 1 : Math.ceil(re / 2), V /= re / Ae), $ > 2 && ge > 1 && (qe = ge >= 16384 ? Math.floor(ge / 2) - 1 || 1 : Math.ceil(ge) / 2, $ /= ge / qe), le = this.cachedCanvases.getCanvas(be, Ae, qe), fe = le.context, fe.clearRect(0, 0, Ae, qe), fe.drawImage(d, 0, 0, re, ge, 0, 0, Ae, qe), d = le.canvas, re = Ae, ge = qe, be = be === "prescale1" ? "prescale2" : "prescale1";
                }
                return {
                  img: d,
                  paintWidth: re,
                  paintHeight: ge
                };
              }
              _createMaskCanvas(d) {
                const _ = this.ctx, {
                  width: F,
                  height: U
                } = d, V = this.current.fillColor, $ = this.current.patternFill, re = (0, t.getCurrentTransform)(_);
                let ge, be, le, fe;
                if ((d.bitmap || d.data) && d.count > 1) {
                  const de = d.bitmap || d.data.buffer;
                  be = JSON.stringify($ ? re : [re.slice(0, 4), V]), ge = this._cachedBitmapsMap.get(de), ge || (ge = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(de, ge));
                  const $e = ge.get(be);
                  if ($e && !$) {
                    const Ge = Math.round(Math.min(re[0], re[2]) + re[4]), st = Math.round(Math.min(re[1], re[3]) + re[5]);
                    return {
                      canvas: $e,
                      offsetX: Ge,
                      offsetY: st
                    };
                  }
                  le = $e;
                }
                le || (fe = this.cachedCanvases.getCanvas("maskCanvas", F, U), i(fe.context, d));
                let Ae = n.Util.transform(re, [1 / F, 0, 0, -1 / U, 0, 0]);
                Ae = n.Util.transform(Ae, [1, 0, 0, 1, 0, -U]);
                const qe = n.Util.applyTransform([0, 0], Ae), ye = n.Util.applyTransform([F, U], Ae), ce = n.Util.normalizeRect([qe[0], qe[1], ye[0], ye[1]]), q = Math.round(ce[2] - ce[0]) || 1, Z = Math.round(ce[3] - ce[1]) || 1, pe = this.cachedCanvases.getCanvas("fillCanvas", q, Z), me = pe.context, _e = Math.min(qe[0], ye[0]), Be = Math.min(qe[1], ye[1]);
                me.translate(-_e, -Be), me.transform(...Ae), le || (le = this._scaleImage(fe.canvas, (0, t.getCurrentTransformInverse)(me)), le = le.img, ge && $ && ge.set(be, le)), me.imageSmoothingEnabled = f((0, t.getCurrentTransform)(me), d.interpolate), u(me, le, 0, 0, le.width, le.height, 0, 0, F, U), me.globalCompositeOperation = "source-in";
                const ke = n.Util.transform((0, t.getCurrentTransformInverse)(me), [1, 0, 0, 1, -_e, -Be]);
                return me.fillStyle = $ ? V.getPattern(_, this, ke, l.PathType.FILL) : V, me.fillRect(0, 0, F, U), ge && !$ && (this.cachedCanvases.delete("fillCanvas"), ge.set(be, pe.canvas)), {
                  canvas: pe.canvas,
                  offsetX: Math.round(_e),
                  offsetY: Math.round(Be)
                };
              }
              setLineWidth(d) {
                d !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = d, this.ctx.lineWidth = d;
              }
              setLineCap(d) {
                this.ctx.lineCap = C[d];
              }
              setLineJoin(d) {
                this.ctx.lineJoin = R[d];
              }
              setMiterLimit(d) {
                this.ctx.miterLimit = d;
              }
              setDash(d, _) {
                const F = this.ctx;
                F.setLineDash !== void 0 && (F.setLineDash(d), F.lineDashOffset = _);
              }
              setRenderingIntent(d) {
              }
              setFlatness(d) {
              }
              setGState(d) {
                for (const [_, F] of d)
                  switch (_) {
                    case "LW":
                      this.setLineWidth(F);
                      break;
                    case "LC":
                      this.setLineCap(F);
                      break;
                    case "LJ":
                      this.setLineJoin(F);
                      break;
                    case "ML":
                      this.setMiterLimit(F);
                      break;
                    case "D":
                      this.setDash(F[0], F[1]);
                      break;
                    case "RI":
                      this.setRenderingIntent(F);
                      break;
                    case "FL":
                      this.setFlatness(F);
                      break;
                    case "Font":
                      this.setFont(F[0], F[1]);
                      break;
                    case "CA":
                      this.current.strokeAlpha = F;
                      break;
                    case "ca":
                      this.current.fillAlpha = F, this.ctx.globalAlpha = F;
                      break;
                    case "BM":
                      this.ctx.globalCompositeOperation = F;
                      break;
                    case "SMask":
                      this.current.activeSMask = F ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
                      break;
                    case "TR":
                      this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(F);
                      break;
                  }
              }
              get inSMaskMode() {
                return !!this.suspendedCtx;
              }
              checkSMaskState() {
                const d = this.inSMaskMode;
                this.current.activeSMask && !d ? this.beginSMaskMode() : !this.current.activeSMask && d && this.endSMaskMode();
              }
              beginSMaskMode() {
                if (this.inSMaskMode)
                  throw new Error("beginSMaskMode called while already in smask mode");
                const d = this.ctx.canvas.width, _ = this.ctx.canvas.height, F = "smaskGroupAt" + this.groupLevel, U = this.cachedCanvases.getCanvas(F, d, _);
                this.suspendedCtx = this.ctx, this.ctx = U.context;
                const V = this.ctx;
                V.setTransform(...(0, t.getCurrentTransform)(this.suspendedCtx)), o(this.suspendedCtx, V), S(V, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
              }
              endSMaskMode() {
                if (!this.inSMaskMode)
                  throw new Error("endSMaskMode called while not in smask mode");
                this.ctx._removeMirroring(), o(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
              }
              compose(d) {
                if (!this.current.activeSMask)
                  return;
                d ? (d[0] = Math.floor(d[0]), d[1] = Math.floor(d[1]), d[2] = Math.ceil(d[2]), d[3] = Math.ceil(d[3])) : d = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
                const _ = this.current.activeSMask, F = this.suspendedCtx;
                a(F, _, this.ctx, d), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
              }
              save() {
                this.inSMaskMode ? (o(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
                const d = this.current;
                this.stateStack.push(d), this.current = d.clone();
              }
              restore() {
                this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), o(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
              }
              transform(d, _, F, U, V, $) {
                this.ctx.transform(d, _, F, U, V, $), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
              }
              constructPath(d, _, F) {
                const U = this.ctx, V = this.current;
                let $ = V.x, re = V.y, ge, be;
                const le = (0, t.getCurrentTransform)(U), fe = le[0] === 0 && le[3] === 0 || le[1] === 0 && le[2] === 0, Ae = fe ? F.slice(0) : null;
                for (let qe = 0, ye = 0, ce = d.length; qe < ce; qe++)
                  switch (d[qe] | 0) {
                    case n.OPS.rectangle:
                      $ = _[ye++], re = _[ye++];
                      const q = _[ye++], Z = _[ye++], pe = $ + q, me = re + Z;
                      U.moveTo($, re), q === 0 || Z === 0 ? U.lineTo(pe, me) : (U.lineTo(pe, re), U.lineTo(pe, me), U.lineTo($, me)), fe || V.updateRectMinMax(le, [$, re, pe, me]), U.closePath();
                      break;
                    case n.OPS.moveTo:
                      $ = _[ye++], re = _[ye++], U.moveTo($, re), fe || V.updatePathMinMax(le, $, re);
                      break;
                    case n.OPS.lineTo:
                      $ = _[ye++], re = _[ye++], U.lineTo($, re), fe || V.updatePathMinMax(le, $, re);
                      break;
                    case n.OPS.curveTo:
                      ge = $, be = re, $ = _[ye + 4], re = _[ye + 5], U.bezierCurveTo(_[ye], _[ye + 1], _[ye + 2], _[ye + 3], $, re), V.updateCurvePathMinMax(le, ge, be, _[ye], _[ye + 1], _[ye + 2], _[ye + 3], $, re, Ae), ye += 6;
                      break;
                    case n.OPS.curveTo2:
                      ge = $, be = re, U.bezierCurveTo($, re, _[ye], _[ye + 1], _[ye + 2], _[ye + 3]), V.updateCurvePathMinMax(le, ge, be, $, re, _[ye], _[ye + 1], _[ye + 2], _[ye + 3], Ae), $ = _[ye + 2], re = _[ye + 3], ye += 4;
                      break;
                    case n.OPS.curveTo3:
                      ge = $, be = re, $ = _[ye + 2], re = _[ye + 3], U.bezierCurveTo(_[ye], _[ye + 1], $, re, $, re), V.updateCurvePathMinMax(le, ge, be, _[ye], _[ye + 1], $, re, $, re, Ae), ye += 4;
                      break;
                    case n.OPS.closePath:
                      U.closePath();
                      break;
                  }
                fe && V.updateScalingPathMinMax(le, Ae), V.setCurrentPoint($, re);
              }
              closePath() {
                this.ctx.closePath();
              }
              stroke(d = !0) {
                const _ = this.ctx, F = this.current.strokeColor;
                _.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof F == "object" && (F != null && F.getPattern) ? (_.save(), _.strokeStyle = F.getPattern(_, this, (0, t.getCurrentTransformInverse)(_), l.PathType.STROKE), this.rescaleAndStroke(!1), _.restore()) : this.rescaleAndStroke(!0)), d && this.consumePath(this.current.getClippedPathBoundingBox()), _.globalAlpha = this.current.fillAlpha;
              }
              closeStroke() {
                this.closePath(), this.stroke();
              }
              fill(d = !0) {
                const _ = this.ctx, F = this.current.fillColor, U = this.current.patternFill;
                let V = !1;
                U && (_.save(), _.fillStyle = F.getPattern(_, this, (0, t.getCurrentTransformInverse)(_), l.PathType.FILL), V = !0);
                const $ = this.current.getClippedPathBoundingBox();
                this.contentVisible && $ !== null && (this.pendingEOFill ? (_.fill("evenodd"), this.pendingEOFill = !1) : _.fill()), V && _.restore(), d && this.consumePath($);
              }
              eoFill() {
                this.pendingEOFill = !0, this.fill();
              }
              fillStroke() {
                this.fill(!1), this.stroke(!1), this.consumePath();
              }
              eoFillStroke() {
                this.pendingEOFill = !0, this.fillStroke();
              }
              closeFillStroke() {
                this.closePath(), this.fillStroke();
              }
              closeEOFillStroke() {
                this.pendingEOFill = !0, this.closePath(), this.fillStroke();
              }
              endPath() {
                this.consumePath();
              }
              clip() {
                this.pendingClip = M;
              }
              eoClip() {
                this.pendingClip = I;
              }
              beginText() {
                this.current.textMatrix = n.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
              }
              endText() {
                const d = this.pendingTextPaths, _ = this.ctx;
                if (d === void 0) {
                  _.beginPath();
                  return;
                }
                _.save(), _.beginPath();
                for (const F of d)
                  _.setTransform(...F.transform), _.translate(F.x, F.y), F.addToPath(_, F.fontSize);
                _.restore(), _.clip(), _.beginPath(), delete this.pendingTextPaths;
              }
              setCharSpacing(d) {
                this.current.charSpacing = d;
              }
              setWordSpacing(d) {
                this.current.wordSpacing = d;
              }
              setHScale(d) {
                this.current.textHScale = d / 100;
              }
              setLeading(d) {
                this.current.leading = -d;
              }
              setFont(d, _) {
                var le;
                const F = this.commonObjs.get(d), U = this.current;
                if (!F)
                  throw new Error(`Can't find font for ${d}`);
                if (U.fontMatrix = F.fontMatrix || n.FONT_IDENTITY_MATRIX, (U.fontMatrix[0] === 0 || U.fontMatrix[3] === 0) && (0, n.warn)("Invalid font matrix for font " + d), _ < 0 ? (_ = -_, U.fontDirection = -1) : U.fontDirection = 1, this.current.font = F, this.current.fontSize = _, F.isType3Font)
                  return;
                const V = F.loadedName || "sans-serif", $ = ((le = F.systemFontInfo) == null ? void 0 : le.css) || `"${V}", ${F.fallbackName}`;
                let re = "normal";
                F.black ? re = "900" : F.bold && (re = "bold");
                const ge = F.italic ? "italic" : "normal";
                let be = _;
                _ < Q ? be = Q : _ > G && (be = G), this.current.fontSizeScale = _ / be, this.ctx.font = `${ge} ${re} ${be}px ${$}`;
              }
              setTextRenderingMode(d) {
                this.current.textRenderingMode = d;
              }
              setTextRise(d) {
                this.current.textRise = d;
              }
              moveText(d, _) {
                this.current.x = this.current.lineX += d, this.current.y = this.current.lineY += _;
              }
              setLeadingMoveText(d, _) {
                this.setLeading(-_), this.moveText(d, _);
              }
              setTextMatrix(d, _, F, U, V, $) {
                this.current.textMatrix = [d, _, F, U, V, $], this.current.textMatrixScale = Math.hypot(d, _), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
              }
              nextLine() {
                this.moveText(0, this.current.leading);
              }
              paintChar(d, _, F, U) {
                const V = this.ctx, $ = this.current, re = $.font, ge = $.textRenderingMode, be = $.fontSize / $.fontSizeScale, le = ge & n.TextRenderingMode.FILL_STROKE_MASK, fe = !!(ge & n.TextRenderingMode.ADD_TO_PATH_FLAG), Ae = $.patternFill && !re.missingFile;
                let qe;
                (re.disableFontFace || fe || Ae) && (qe = re.getPathGenerator(this.commonObjs, d)), re.disableFontFace || Ae ? (V.save(), V.translate(_, F), V.beginPath(), qe(V, be), U && V.setTransform(...U), (le === n.TextRenderingMode.FILL || le === n.TextRenderingMode.FILL_STROKE) && V.fill(), (le === n.TextRenderingMode.STROKE || le === n.TextRenderingMode.FILL_STROKE) && V.stroke(), V.restore()) : ((le === n.TextRenderingMode.FILL || le === n.TextRenderingMode.FILL_STROKE) && V.fillText(d, _, F), (le === n.TextRenderingMode.STROKE || le === n.TextRenderingMode.FILL_STROKE) && V.strokeText(d, _, F)), fe && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
                  transform: (0, t.getCurrentTransform)(V),
                  x: _,
                  y: F,
                  fontSize: be,
                  addToPath: qe
                });
              }
              get isFontSubpixelAAEnabled() {
                const {
                  context: d
                } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
                d.scale(1.5, 1), d.fillText("I", 0, 10);
                const _ = d.getImageData(0, 0, 10, 10).data;
                let F = !1;
                for (let U = 3; U < _.length; U += 4)
                  if (_[U] > 0 && _[U] < 255) {
                    F = !0;
                    break;
                  }
                return (0, n.shadow)(this, "isFontSubpixelAAEnabled", F);
              }
              showText(d) {
                const _ = this.current, F = _.font;
                if (F.isType3Font)
                  return this.showType3Text(d);
                const U = _.fontSize;
                if (U === 0)
                  return;
                const V = this.ctx, $ = _.fontSizeScale, re = _.charSpacing, ge = _.wordSpacing, be = _.fontDirection, le = _.textHScale * be, fe = d.length, Ae = F.vertical, qe = Ae ? 1 : -1, ye = F.defaultVMetrics, ce = U * _.fontMatrix[0], q = _.textRenderingMode === n.TextRenderingMode.FILL && !F.disableFontFace && !_.patternFill;
                V.save(), V.transform(..._.textMatrix), V.translate(_.x, _.y + _.textRise), be > 0 ? V.scale(le, -1) : V.scale(le, 1);
                let Z;
                if (_.patternFill) {
                  V.save();
                  const ke = _.fillColor.getPattern(V, this, (0, t.getCurrentTransformInverse)(V), l.PathType.FILL);
                  Z = (0, t.getCurrentTransform)(V), V.restore(), V.fillStyle = ke;
                }
                let pe = _.lineWidth;
                const me = _.textMatrixScale;
                if (me === 0 || pe === 0) {
                  const ke = _.textRenderingMode & n.TextRenderingMode.FILL_STROKE_MASK;
                  (ke === n.TextRenderingMode.STROKE || ke === n.TextRenderingMode.FILL_STROKE) && (pe = this.getSinglePixelWidth());
                } else
                  pe /= me;
                if ($ !== 1 && (V.scale($, $), pe /= $), V.lineWidth = pe, F.isInvalidPDFjsFont) {
                  const ke = [];
                  let de = 0;
                  for (const $e of d)
                    ke.push($e.unicode), de += $e.width;
                  V.fillText(ke.join(""), 0, 0), _.x += de * ce * le, V.restore(), this.compose();
                  return;
                }
                let _e = 0, Be;
                for (Be = 0; Be < fe; ++Be) {
                  const ke = d[Be];
                  if (typeof ke == "number") {
                    _e += qe * ke * U / 1e3;
                    continue;
                  }
                  let de = !1;
                  const $e = (ke.isSpace ? ge : 0) + re, Ge = ke.fontChar, st = ke.accent;
                  let it, _t, tt = ke.width;
                  if (Ae) {
                    const ct = ke.vmetric || ye, xt = -(ke.vmetric ? ct[1] : tt * 0.5) * ce, We = ct[2] * ce;
                    tt = ct ? -ct[0] : tt, it = xt / $, _t = (_e + We) / $;
                  } else
                    it = _e / $, _t = 0;
                  if (F.remeasure && tt > 0) {
                    const ct = V.measureText(Ge).width * 1e3 / U * $;
                    if (tt < ct && this.isFontSubpixelAAEnabled) {
                      const xt = tt / ct;
                      de = !0, V.save(), V.scale(xt, 1), it /= xt;
                    } else tt !== ct && (it += (tt - ct) / 2e3 * U / $);
                  }
                  if (this.contentVisible && (ke.isInFont || F.missingFile)) {
                    if (q && !st)
                      V.fillText(Ge, it, _t);
                    else if (this.paintChar(Ge, it, _t, Z), st) {
                      const ct = it + U * st.offset.x / $, xt = _t - U * st.offset.y / $;
                      this.paintChar(st.fontChar, ct, xt, Z);
                    }
                  }
                  const Xe = Ae ? tt * ce - $e * be : tt * ce + $e * be;
                  _e += Xe, de && V.restore();
                }
                Ae ? _.y -= _e : _.x += _e * le, V.restore(), this.compose();
              }
              showType3Text(d) {
                const _ = this.ctx, F = this.current, U = F.font, V = F.fontSize, $ = F.fontDirection, re = U.vertical ? 1 : -1, ge = F.charSpacing, be = F.wordSpacing, le = F.textHScale * $, fe = F.fontMatrix || n.FONT_IDENTITY_MATRIX, Ae = d.length, qe = F.textRenderingMode === n.TextRenderingMode.INVISIBLE;
                let ye, ce, q, Z;
                if (!(qe || V === 0)) {
                  for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, _.save(), _.transform(...F.textMatrix), _.translate(F.x, F.y), _.scale(le, $), ye = 0; ye < Ae; ++ye) {
                    if (ce = d[ye], typeof ce == "number") {
                      Z = re * ce * V / 1e3, this.ctx.translate(Z, 0), F.x += Z * le;
                      continue;
                    }
                    const pe = (ce.isSpace ? be : 0) + ge, me = U.charProcOperatorList[ce.operatorListId];
                    if (!me) {
                      (0, n.warn)(`Type3 character "${ce.operatorListId}" is not available.`);
                      continue;
                    }
                    this.contentVisible && (this.processingType3 = ce, this.save(), _.scale(V, V), _.transform(...fe), this.executeOperatorList(me), this.restore()), q = n.Util.applyTransform([ce.width, 0], fe)[0] * V + pe, _.translate(q, 0), F.x += q * le;
                  }
                  _.restore(), this.processingType3 = null;
                }
              }
              setCharWidth(d, _) {
              }
              setCharWidthAndBounds(d, _, F, U, V, $) {
                this.ctx.rect(F, U, V - F, $ - U), this.ctx.clip(), this.endPath();
              }
              getColorN_Pattern(d) {
                let _;
                if (d[0] === "TilingPattern") {
                  const F = d[1], U = this.baseTransform || (0, t.getCurrentTransform)(this.ctx), V = {
                    createCanvasGraphics: ($) => new j($, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                      optionalContentConfig: this.optionalContentConfig,
                      markedContentStack: this.markedContentStack
                    })
                  };
                  _ = new l.TilingPattern(d, F, this.ctx, V, U);
                } else
                  _ = this._getPattern(d[1], d[2]);
                return _;
              }
              setStrokeColorN() {
                this.current.strokeColor = this.getColorN_Pattern(arguments);
              }
              setFillColorN() {
                this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
              }
              setStrokeRGBColor(d, _, F) {
                const U = n.Util.makeHexColor(d, _, F);
                this.ctx.strokeStyle = U, this.current.strokeColor = U;
              }
              setFillRGBColor(d, _, F) {
                const U = n.Util.makeHexColor(d, _, F);
                this.ctx.fillStyle = U, this.current.fillColor = U, this.current.patternFill = !1;
              }
              _getPattern(d, _ = null) {
                let F;
                return this.cachedPatterns.has(d) ? F = this.cachedPatterns.get(d) : (F = (0, l.getShadingPattern)(this.getObject(d)), this.cachedPatterns.set(d, F)), _ && (F.matrix = _), F;
              }
              shadingFill(d) {
                if (!this.contentVisible)
                  return;
                const _ = this.ctx;
                this.save();
                const F = this._getPattern(d);
                _.fillStyle = F.getPattern(_, this, (0, t.getCurrentTransformInverse)(_), l.PathType.SHADING);
                const U = (0, t.getCurrentTransformInverse)(_);
                if (U) {
                  const {
                    width: V,
                    height: $
                  } = _.canvas, [re, ge, be, le] = n.Util.getAxialAlignedBoundingBox([0, 0, V, $], U);
                  this.ctx.fillRect(re, ge, be - re, le - ge);
                } else
                  this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                this.compose(this.current.getClippedPathBoundingBox()), this.restore();
              }
              beginInlineImage() {
                (0, n.unreachable)("Should not call beginInlineImage");
              }
              beginImageData() {
                (0, n.unreachable)("Should not call beginImageData");
              }
              paintFormXObjectBegin(d, _) {
                if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(d) && d.length === 6 && this.transform(...d), this.baseTransform = (0, t.getCurrentTransform)(this.ctx), _)) {
                  const F = _[2] - _[0], U = _[3] - _[1];
                  this.ctx.rect(_[0], _[1], F, U), this.current.updateRectMinMax((0, t.getCurrentTransform)(this.ctx), _), this.clip(), this.endPath();
                }
              }
              paintFormXObjectEnd() {
                this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
              }
              beginGroup(d) {
                if (!this.contentVisible)
                  return;
                this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
                const _ = this.ctx;
                d.isolated || (0, n.info)("TODO: Support non-isolated groups."), d.knockout && (0, n.warn)("Knockout groups not supported.");
                const F = (0, t.getCurrentTransform)(_);
                if (d.matrix && _.transform(...d.matrix), !d.bbox)
                  throw new Error("Bounding box is required.");
                let U = n.Util.getAxialAlignedBoundingBox(d.bbox, (0, t.getCurrentTransform)(_));
                const V = [0, 0, _.canvas.width, _.canvas.height];
                U = n.Util.intersect(U, V) || [0, 0, 0, 0];
                const $ = Math.floor(U[0]), re = Math.floor(U[1]);
                let ge = Math.max(Math.ceil(U[2]) - $, 1), be = Math.max(Math.ceil(U[3]) - re, 1), le = 1, fe = 1;
                ge > X && (le = ge / X, ge = X), be > X && (fe = be / X, be = X), this.current.startNewPathAndClipBox([0, 0, ge, be]);
                let Ae = "groupAt" + this.groupLevel;
                d.smask && (Ae += "_smask_" + this.smaskCounter++ % 2);
                const qe = this.cachedCanvases.getCanvas(Ae, ge, be), ye = qe.context;
                ye.scale(1 / le, 1 / fe), ye.translate(-$, -re), ye.transform(...F), d.smask ? this.smaskStack.push({
                  canvas: qe.canvas,
                  context: ye,
                  offsetX: $,
                  offsetY: re,
                  scaleX: le,
                  scaleY: fe,
                  subtype: d.smask.subtype,
                  backdrop: d.smask.backdrop,
                  transferMap: d.smask.transferMap || null,
                  startTransformInverse: null
                }) : (_.setTransform(1, 0, 0, 1, 0, 0), _.translate($, re), _.scale(le, fe), _.save()), o(_, ye), this.ctx = ye, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(_), this.groupLevel++;
              }
              endGroup(d) {
                if (!this.contentVisible)
                  return;
                this.groupLevel--;
                const _ = this.ctx, F = this.groupStack.pop();
                if (this.ctx = F, this.ctx.imageSmoothingEnabled = !1, d.smask)
                  this.tempSMask = this.smaskStack.pop(), this.restore();
                else {
                  this.ctx.restore();
                  const U = (0, t.getCurrentTransform)(this.ctx);
                  this.restore(), this.ctx.save(), this.ctx.setTransform(...U);
                  const V = n.Util.getAxialAlignedBoundingBox([0, 0, _.canvas.width, _.canvas.height], U);
                  this.ctx.drawImage(_.canvas, 0, 0), this.ctx.restore(), this.compose(V);
                }
              }
              beginAnnotation(d, _, F, U, V) {
                if (Te(this, T, vi).call(this), b(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(_) && _.length === 4) {
                  const $ = _[2] - _[0], re = _[3] - _[1];
                  if (V && this.annotationCanvasMap) {
                    F = F.slice(), F[4] -= _[0], F[5] -= _[1], _ = _.slice(), _[0] = _[1] = 0, _[2] = $, _[3] = re;
                    const [ge, be] = n.Util.singularValueDecompose2dScale((0, t.getCurrentTransform)(this.ctx)), {
                      viewportScale: le
                    } = this, fe = Math.ceil($ * this.outputScaleX * le), Ae = Math.ceil(re * this.outputScaleY * le);
                    this.annotationCanvas = this.canvasFactory.create(fe, Ae);
                    const {
                      canvas: qe,
                      context: ye
                    } = this.annotationCanvas;
                    this.annotationCanvasMap.set(d, qe), this.annotationCanvas.savedCtx = this.ctx, this.ctx = ye, this.ctx.save(), this.ctx.setTransform(ge, 0, 0, -be, 0, re * be), b(this.ctx);
                  } else
                    b(this.ctx), this.ctx.rect(_[0], _[1], $, re), this.ctx.clip(), this.endPath();
                }
                this.current = new s(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...F), this.transform(...U);
              }
              endAnnotation() {
                this.annotationCanvas && (this.ctx.restore(), Te(this, T, bi).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
              }
              paintImageMaskXObject(d) {
                if (!this.contentVisible)
                  return;
                const _ = d.count;
                d = this.getObject(d.data, d), d.count = _;
                const F = this.ctx, U = this.processingType3;
                if (U && (U.compiled === void 0 && (U.compiled = m(d)), U.compiled)) {
                  U.compiled(F);
                  return;
                }
                const V = this._createMaskCanvas(d), $ = V.canvas;
                F.save(), F.setTransform(1, 0, 0, 1, 0, 0), F.drawImage($, V.offsetX, V.offsetY), F.restore(), this.compose();
              }
              paintImageMaskXObjectRepeat(d, _, F = 0, U = 0, V, $) {
                if (!this.contentVisible)
                  return;
                d = this.getObject(d.data, d);
                const re = this.ctx;
                re.save();
                const ge = (0, t.getCurrentTransform)(re);
                re.transform(_, F, U, V, 0, 0);
                const be = this._createMaskCanvas(d);
                re.setTransform(1, 0, 0, 1, be.offsetX - ge[4], be.offsetY - ge[5]);
                for (let le = 0, fe = $.length; le < fe; le += 2) {
                  const Ae = n.Util.transform(ge, [_, F, U, V, $[le], $[le + 1]]), [qe, ye] = n.Util.applyTransform([0, 0], Ae);
                  re.drawImage(be.canvas, qe, ye);
                }
                re.restore(), this.compose();
              }
              paintImageMaskXObjectGroup(d) {
                if (!this.contentVisible)
                  return;
                const _ = this.ctx, F = this.current.fillColor, U = this.current.patternFill;
                for (const V of d) {
                  const {
                    data: $,
                    width: re,
                    height: ge,
                    transform: be
                  } = V, le = this.cachedCanvases.getCanvas("maskCanvas", re, ge), fe = le.context;
                  fe.save();
                  const Ae = this.getObject($, V);
                  i(fe, Ae), fe.globalCompositeOperation = "source-in", fe.fillStyle = U ? F.getPattern(fe, this, (0, t.getCurrentTransformInverse)(_), l.PathType.FILL) : F, fe.fillRect(0, 0, re, ge), fe.restore(), _.save(), _.transform(...be), _.scale(1, -1), u(_, le.canvas, 0, 0, re, ge, 0, -1, 1, 1), _.restore();
                }
                this.compose();
              }
              paintImageXObject(d) {
                if (!this.contentVisible)
                  return;
                const _ = this.getObject(d);
                if (!_) {
                  (0, n.warn)("Dependent image isn't ready yet");
                  return;
                }
                this.paintInlineImageXObject(_);
              }
              paintImageXObjectRepeat(d, _, F, U) {
                if (!this.contentVisible)
                  return;
                const V = this.getObject(d);
                if (!V) {
                  (0, n.warn)("Dependent image isn't ready yet");
                  return;
                }
                const $ = V.width, re = V.height, ge = [];
                for (let be = 0, le = U.length; be < le; be += 2)
                  ge.push({
                    transform: [_, 0, 0, F, U[be], U[be + 1]],
                    x: 0,
                    y: 0,
                    w: $,
                    h: re
                  });
                this.paintInlineImageXObjectGroup(V, ge);
              }
              applyTransferMapsToCanvas(d) {
                return this.current.transferMaps !== "none" && (d.filter = this.current.transferMaps, d.drawImage(d.canvas, 0, 0), d.filter = "none"), d.canvas;
              }
              applyTransferMapsToBitmap(d) {
                if (this.current.transferMaps === "none")
                  return d.bitmap;
                const {
                  bitmap: _,
                  width: F,
                  height: U
                } = d, V = this.cachedCanvases.getCanvas("inlineImage", F, U), $ = V.context;
                return $.filter = this.current.transferMaps, $.drawImage(_, 0, 0), $.filter = "none", V.canvas;
              }
              paintInlineImageXObject(d) {
                if (!this.contentVisible)
                  return;
                const _ = d.width, F = d.height, U = this.ctx;
                if (this.save(), !n.isNodeJS) {
                  const {
                    filter: re
                  } = U;
                  re !== "none" && re !== "" && (U.filter = "none");
                }
                U.scale(1 / _, -1 / F);
                let V;
                if (d.bitmap)
                  V = this.applyTransferMapsToBitmap(d);
                else if (typeof HTMLElement == "function" && d instanceof HTMLElement || !d.data)
                  V = d;
                else {
                  const ge = this.cachedCanvases.getCanvas("inlineImage", _, F).context;
                  w(ge, d), V = this.applyTransferMapsToCanvas(ge);
                }
                const $ = this._scaleImage(V, (0, t.getCurrentTransformInverse)(U));
                U.imageSmoothingEnabled = f((0, t.getCurrentTransform)(U), d.interpolate), u(U, $.img, 0, 0, $.paintWidth, $.paintHeight, 0, -F, _, F), this.compose(), this.restore();
              }
              paintInlineImageXObjectGroup(d, _) {
                if (!this.contentVisible)
                  return;
                const F = this.ctx;
                let U;
                if (d.bitmap)
                  U = d.bitmap;
                else {
                  const V = d.width, $ = d.height, ge = this.cachedCanvases.getCanvas("inlineImage", V, $).context;
                  w(ge, d), U = this.applyTransferMapsToCanvas(ge);
                }
                for (const V of _)
                  F.save(), F.transform(...V.transform), F.scale(1, -1), u(F, U, V.x, V.y, V.w, V.h, 0, -1, 1, 1), F.restore();
                this.compose();
              }
              paintSolidColorImageMask() {
                this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
              }
              markPoint(d) {
              }
              markPointProps(d, _) {
              }
              beginMarkedContent(d) {
                this.markedContentStack.push({
                  visible: !0
                });
              }
              beginMarkedContentProps(d, _) {
                d === "OC" ? this.markedContentStack.push({
                  visible: this.optionalContentConfig.isVisible(_)
                }) : this.markedContentStack.push({
                  visible: !0
                }), this.contentVisible = this.isContentVisible();
              }
              endMarkedContent() {
                this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
              }
              beginCompat() {
              }
              endCompat() {
              }
              consumePath(d) {
                const _ = this.current.isEmptyClip();
                this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(d);
                const F = this.ctx;
                this.pendingClip && (_ || (this.pendingClip === I ? F.clip("evenodd") : F.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), F.beginPath();
              }
              getSinglePixelWidth() {
                if (!this._cachedGetSinglePixelWidth) {
                  const d = (0, t.getCurrentTransform)(this.ctx);
                  if (d[1] === 0 && d[2] === 0)
                    this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(d[0]), Math.abs(d[3]));
                  else {
                    const _ = Math.abs(d[0] * d[3] - d[2] * d[1]), F = Math.hypot(d[0], d[2]), U = Math.hypot(d[1], d[3]);
                    this._cachedGetSinglePixelWidth = Math.max(F, U) / _;
                  }
                }
                return this._cachedGetSinglePixelWidth;
              }
              getScaleForStroking() {
                if (this._cachedScaleForStroking[0] === -1) {
                  const {
                    lineWidth: d
                  } = this.current, {
                    a: _,
                    b: F,
                    c: U,
                    d: V
                  } = this.ctx.getTransform();
                  let $, re;
                  if (F === 0 && U === 0) {
                    const ge = Math.abs(_), be = Math.abs(V);
                    if (ge === be)
                      if (d === 0)
                        $ = re = 1 / ge;
                      else {
                        const le = ge * d;
                        $ = re = le < 1 ? 1 / le : 1;
                      }
                    else if (d === 0)
                      $ = 1 / ge, re = 1 / be;
                    else {
                      const le = ge * d, fe = be * d;
                      $ = le < 1 ? 1 / le : 1, re = fe < 1 ? 1 / fe : 1;
                    }
                  } else {
                    const ge = Math.abs(_ * V - F * U), be = Math.hypot(_, F), le = Math.hypot(U, V);
                    if (d === 0)
                      $ = le / ge, re = be / ge;
                    else {
                      const fe = d * ge;
                      $ = le > fe ? le / fe : 1, re = be > fe ? be / fe : 1;
                    }
                  }
                  this._cachedScaleForStroking[0] = $, this._cachedScaleForStroking[1] = re;
                }
                return this._cachedScaleForStroking;
              }
              rescaleAndStroke(d) {
                const {
                  ctx: _
                } = this, {
                  lineWidth: F
                } = this.current, [U, V] = this.getScaleForStroking();
                if (_.lineWidth = F || 1, U === 1 && V === 1) {
                  _.stroke();
                  return;
                }
                const $ = _.getLineDash();
                if (d && _.save(), _.scale(U, V), $.length > 0) {
                  const re = Math.max(U, V);
                  _.setLineDash($.map((ge) => ge / re)), _.lineDashOffset /= re;
                }
                _.stroke(), d && _.restore();
              }
              isContentVisible() {
                for (let d = this.markedContentStack.length - 1; d >= 0; d--)
                  if (!this.markedContentStack[d].visible)
                    return !1;
                return !0;
              }
            };
            T = new WeakSet(), vi = function() {
              for (; this.stateStack.length || this.inSMaskMode; )
                this.restore();
              this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
            }, bi = function() {
              if (this.pageColors) {
                const d = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
                if (d !== "none") {
                  const _ = this.ctx.filter;
                  this.ctx.filter = d, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = _;
                }
              }
            };
            let E = j;
            L.CanvasGraphics = E;
            for (const A in n.OPS)
              E.prototype[A] !== void 0 && (E.prototype[n.OPS[A]] = E.prototype[A]);
          },
          /* 12 */
          /***/
          (e, L, p) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.TilingPattern = L.PathType = void 0, L.getShadingPattern = P;
            var n = p(1), t = p(6);
            const l = {
              FILL: "Fill",
              STROKE: "Stroke",
              SHADING: "Shading"
            };
            L.PathType = l;
            function W(m, s) {
              if (!s)
                return;
              const w = s[2] - s[0], i = s[3] - s[1], o = new Path2D();
              o.rect(s[0], s[1], w, i), m.clip(o);
            }
            class Q {
              constructor() {
                this.constructor === Q && (0, n.unreachable)("Cannot initialize BaseShadingPattern.");
              }
              getPattern() {
                (0, n.unreachable)("Abstract method `getPattern` called.");
              }
            }
            class G extends Q {
              constructor(s) {
                super(), this._type = s[1], this._bbox = s[2], this._colorStops = s[3], this._p0 = s[4], this._p1 = s[5], this._r0 = s[6], this._r1 = s[7], this.matrix = null;
              }
              _createGradient(s) {
                let w;
                this._type === "axial" ? w = s.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (w = s.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
                for (const i of this._colorStops)
                  w.addColorStop(i[0], i[1]);
                return w;
              }
              getPattern(s, w, i, o) {
                let b;
                if (o === l.STROKE || o === l.FILL) {
                  const g = w.current.getClippedPathBoundingBox(o, (0, t.getCurrentTransform)(s)) || [0, 0, 0, 0], c = Math.ceil(g[2] - g[0]) || 1, v = Math.ceil(g[3] - g[1]) || 1, k = w.cachedCanvases.getCanvas("pattern", c, v, !0), a = k.context;
                  a.clearRect(0, 0, a.canvas.width, a.canvas.height), a.beginPath(), a.rect(0, 0, a.canvas.width, a.canvas.height), a.translate(-g[0], -g[1]), i = n.Util.transform(i, [1, 0, 0, 1, g[0], g[1]]), a.transform(...w.baseTransform), this.matrix && a.transform(...this.matrix), W(a, this._bbox), a.fillStyle = this._createGradient(a), a.fill(), b = s.createPattern(k.canvas, "no-repeat");
                  const f = new DOMMatrix(i);
                  b.setTransform(f);
                } else
                  W(s, this._bbox), b = this._createGradient(s);
                return b;
              }
            }
            function X(m, s, w, i, o, b, g, c) {
              const v = s.coords, k = s.colors, a = m.data, f = m.width * 4;
              let C;
              v[w + 1] > v[i + 1] && (C = w, w = i, i = C, C = b, b = g, g = C), v[i + 1] > v[o + 1] && (C = i, i = o, o = C, C = g, g = c, c = C), v[w + 1] > v[i + 1] && (C = w, w = i, i = C, C = b, b = g, g = C);
              const R = (v[w] + s.offsetX) * s.scaleX, M = (v[w + 1] + s.offsetY) * s.scaleY, I = (v[i] + s.offsetX) * s.scaleX, E = (v[i + 1] + s.offsetY) * s.scaleY, T = (v[o] + s.offsetX) * s.scaleX, y = (v[o + 1] + s.offsetY) * s.scaleY;
              if (M >= y)
                return;
              const D = k[b], j = k[b + 1], A = k[b + 2], d = k[g], _ = k[g + 1], F = k[g + 2], U = k[c], V = k[c + 1], $ = k[c + 2], re = Math.round(M), ge = Math.round(y);
              let be, le, fe, Ae, qe, ye, ce, q;
              for (let Z = re; Z <= ge; Z++) {
                if (Z < E) {
                  const ke = Z < M ? 0 : (M - Z) / (M - E);
                  be = R - (R - I) * ke, le = D - (D - d) * ke, fe = j - (j - _) * ke, Ae = A - (A - F) * ke;
                } else {
                  let ke;
                  Z > y ? ke = 1 : E === y ? ke = 0 : ke = (E - Z) / (E - y), be = I - (I - T) * ke, le = d - (d - U) * ke, fe = _ - (_ - V) * ke, Ae = F - (F - $) * ke;
                }
                let pe;
                Z < M ? pe = 0 : Z > y ? pe = 1 : pe = (M - Z) / (M - y), qe = R - (R - T) * pe, ye = D - (D - U) * pe, ce = j - (j - V) * pe, q = A - (A - $) * pe;
                const me = Math.round(Math.min(be, qe)), _e = Math.round(Math.max(be, qe));
                let Be = f * Z + me * 4;
                for (let ke = me; ke <= _e; ke++)
                  pe = (be - ke) / (be - qe), pe < 0 ? pe = 0 : pe > 1 && (pe = 1), a[Be++] = le - (le - ye) * pe | 0, a[Be++] = fe - (fe - ce) * pe | 0, a[Be++] = Ae - (Ae - q) * pe | 0, a[Be++] = 255;
              }
            }
            function N(m, s, w) {
              const i = s.coords, o = s.colors;
              let b, g;
              switch (s.type) {
                case "lattice":
                  const c = s.verticesPerRow, v = Math.floor(i.length / c) - 1, k = c - 1;
                  for (b = 0; b < v; b++) {
                    let a = b * c;
                    for (let f = 0; f < k; f++, a++)
                      X(m, w, i[a], i[a + 1], i[a + c], o[a], o[a + 1], o[a + c]), X(m, w, i[a + c + 1], i[a + 1], i[a + c], o[a + c + 1], o[a + 1], o[a + c]);
                  }
                  break;
                case "triangles":
                  for (b = 0, g = i.length; b < g; b += 3)
                    X(m, w, i[b], i[b + 1], i[b + 2], o[b], o[b + 1], o[b + 2]);
                  break;
                default:
                  throw new Error("illegal figure");
              }
            }
            class H extends Q {
              constructor(s) {
                super(), this._coords = s[2], this._colors = s[3], this._figures = s[4], this._bounds = s[5], this._bbox = s[7], this._background = s[8], this.matrix = null;
              }
              _createMeshCanvas(s, w, i) {
                const c = Math.floor(this._bounds[0]), v = Math.floor(this._bounds[1]), k = Math.ceil(this._bounds[2]) - c, a = Math.ceil(this._bounds[3]) - v, f = Math.min(Math.ceil(Math.abs(k * s[0] * 1.1)), 3e3), C = Math.min(Math.ceil(Math.abs(a * s[1] * 1.1)), 3e3), R = k / f, M = a / C, I = {
                  coords: this._coords,
                  colors: this._colors,
                  offsetX: -c,
                  offsetY: -v,
                  scaleX: 1 / R,
                  scaleY: 1 / M
                }, E = f + 2 * 2, T = C + 2 * 2, y = i.getCanvas("mesh", E, T, !1), D = y.context, j = D.createImageData(f, C);
                if (w) {
                  const d = j.data;
                  for (let _ = 0, F = d.length; _ < F; _ += 4)
                    d[_] = w[0], d[_ + 1] = w[1], d[_ + 2] = w[2], d[_ + 3] = 255;
                }
                for (const d of this._figures)
                  N(j, d, I);
                return D.putImageData(j, 2, 2), {
                  canvas: y.canvas,
                  offsetX: c - 2 * R,
                  offsetY: v - 2 * M,
                  scaleX: R,
                  scaleY: M
                };
              }
              getPattern(s, w, i, o) {
                W(s, this._bbox);
                let b;
                if (o === l.SHADING)
                  b = n.Util.singularValueDecompose2dScale((0, t.getCurrentTransform)(s));
                else if (b = n.Util.singularValueDecompose2dScale(w.baseTransform), this.matrix) {
                  const c = n.Util.singularValueDecompose2dScale(this.matrix);
                  b = [b[0] * c[0], b[1] * c[1]];
                }
                const g = this._createMeshCanvas(b, o === l.SHADING ? null : this._background, w.cachedCanvases);
                return o !== l.SHADING && (s.setTransform(...w.baseTransform), this.matrix && s.transform(...this.matrix)), s.translate(g.offsetX, g.offsetY), s.scale(g.scaleX, g.scaleY), s.createPattern(g.canvas, "no-repeat");
              }
            }
            class B extends Q {
              getPattern() {
                return "hotpink";
              }
            }
            function P(m) {
              switch (m[0]) {
                case "RadialAxial":
                  return new G(m);
                case "Mesh":
                  return new H(m);
                case "Dummy":
                  return new B();
              }
              throw new Error(`Unknown IR type: ${m[0]}`);
            }
            const S = {
              COLORED: 1,
              UNCOLORED: 2
            }, u = class u {
              constructor(s, w, i, o, b) {
                this.operatorList = s[2], this.matrix = s[3] || [1, 0, 0, 1, 0, 0], this.bbox = s[4], this.xstep = s[5], this.ystep = s[6], this.paintType = s[7], this.tilingType = s[8], this.color = w, this.ctx = i, this.canvasGraphicsFactory = o, this.baseTransform = b;
              }
              createPatternCanvas(s) {
                const w = this.operatorList, i = this.bbox, o = this.xstep, b = this.ystep, g = this.paintType, c = this.tilingType, v = this.color, k = this.canvasGraphicsFactory;
                (0, n.info)("TilingType: " + c);
                const a = i[0], f = i[1], C = i[2], R = i[3], M = n.Util.singularValueDecompose2dScale(this.matrix), I = n.Util.singularValueDecompose2dScale(this.baseTransform), E = [M[0] * I[0], M[1] * I[1]], T = this.getSizeAndScale(o, this.ctx.canvas.width, E[0]), y = this.getSizeAndScale(b, this.ctx.canvas.height, E[1]), D = s.cachedCanvases.getCanvas("pattern", T.size, y.size, !0), j = D.context, A = k.createCanvasGraphics(j);
                A.groupLevel = s.groupLevel, this.setFillAndStrokeStyleToContext(A, g, v);
                let d = a, _ = f, F = C, U = R;
                return a < 0 && (d = 0, F += Math.abs(a)), f < 0 && (_ = 0, U += Math.abs(f)), j.translate(-(T.scale * d), -(y.scale * _)), A.transform(T.scale, 0, 0, y.scale, 0, 0), j.save(), this.clipBbox(A, d, _, F, U), A.baseTransform = (0, t.getCurrentTransform)(A.ctx), A.executeOperatorList(w), A.endDrawing(), {
                  canvas: D.canvas,
                  scaleX: T.scale,
                  scaleY: y.scale,
                  offsetX: d,
                  offsetY: _
                };
              }
              getSizeAndScale(s, w, i) {
                s = Math.abs(s);
                const o = Math.max(u.MAX_PATTERN_SIZE, w);
                let b = Math.ceil(s * i);
                return b >= o ? b = o : i = b / s, {
                  scale: i,
                  size: b
                };
              }
              clipBbox(s, w, i, o, b) {
                const g = o - w, c = b - i;
                s.ctx.rect(w, i, g, c), s.current.updateRectMinMax((0, t.getCurrentTransform)(s.ctx), [w, i, o, b]), s.clip(), s.endPath();
              }
              setFillAndStrokeStyleToContext(s, w, i) {
                const o = s.ctx, b = s.current;
                switch (w) {
                  case S.COLORED:
                    const g = this.ctx;
                    o.fillStyle = g.fillStyle, o.strokeStyle = g.strokeStyle, b.fillColor = g.fillStyle, b.strokeColor = g.strokeStyle;
                    break;
                  case S.UNCOLORED:
                    const c = n.Util.makeHexColor(i[0], i[1], i[2]);
                    o.fillStyle = c, o.strokeStyle = c, b.fillColor = c, b.strokeColor = c;
                    break;
                  default:
                    throw new n.FormatError(`Unsupported paint type: ${w}`);
                }
              }
              getPattern(s, w, i, o) {
                let b = i;
                o !== l.SHADING && (b = n.Util.transform(b, w.baseTransform), this.matrix && (b = n.Util.transform(b, this.matrix)));
                const g = this.createPatternCanvas(w);
                let c = new DOMMatrix(b);
                c = c.translate(g.offsetX, g.offsetY), c = c.scale(1 / g.scaleX, 1 / g.scaleY);
                const v = s.createPattern(g.canvas, "repeat");
                return v.setTransform(c), v;
              }
            };
            Tn(u, "MAX_PATTERN_SIZE", 3e3);
            let r = u;
            L.TilingPattern = r;
          },
          /* 13 */
          /***/
          (e, L, p) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.convertBlackAndWhiteToRGBA = l, L.convertToRGBA = t, L.grayToRGBA = Q;
            var n = p(1);
            function t(G) {
              switch (G.kind) {
                case n.ImageKind.GRAYSCALE_1BPP:
                  return l(G);
                case n.ImageKind.RGB_24BPP:
                  return W(G);
              }
              return null;
            }
            function l({
              src: G,
              srcPos: X = 0,
              dest: N,
              width: H,
              height: B,
              nonBlackColor: P = 4294967295,
              inverseDecode: S = !1
            }) {
              const r = n.FeatureTest.isLittleEndian ? 4278190080 : 255, [u, m] = S ? [P, r] : [r, P], s = H >> 3, w = H & 7, i = G.length;
              N = new Uint32Array(N.buffer);
              let o = 0;
              for (let b = 0; b < B; b++) {
                for (const c = X + s; X < c; X++) {
                  const v = X < i ? G[X] : 255;
                  N[o++] = v & 128 ? m : u, N[o++] = v & 64 ? m : u, N[o++] = v & 32 ? m : u, N[o++] = v & 16 ? m : u, N[o++] = v & 8 ? m : u, N[o++] = v & 4 ? m : u, N[o++] = v & 2 ? m : u, N[o++] = v & 1 ? m : u;
                }
                if (w === 0)
                  continue;
                const g = X < i ? G[X++] : 255;
                for (let c = 0; c < w; c++)
                  N[o++] = g & 1 << 7 - c ? m : u;
              }
              return {
                srcPos: X,
                destPos: o
              };
            }
            function W({
              src: G,
              srcPos: X = 0,
              dest: N,
              destPos: H = 0,
              width: B,
              height: P
            }) {
              let S = 0;
              const r = G.length >> 2, u = new Uint32Array(G.buffer, X, r);
              if (n.FeatureTest.isLittleEndian) {
                for (; S < r - 2; S += 3, H += 4) {
                  const m = u[S], s = u[S + 1], w = u[S + 2];
                  N[H] = m | 4278190080, N[H + 1] = m >>> 24 | s << 8 | 4278190080, N[H + 2] = s >>> 16 | w << 16 | 4278190080, N[H + 3] = w >>> 8 | 4278190080;
                }
                for (let m = S * 4, s = G.length; m < s; m += 3)
                  N[H++] = G[m] | G[m + 1] << 8 | G[m + 2] << 16 | 4278190080;
              } else {
                for (; S < r - 2; S += 3, H += 4) {
                  const m = u[S], s = u[S + 1], w = u[S + 2];
                  N[H] = m | 255, N[H + 1] = m << 24 | s >>> 8 | 255, N[H + 2] = s << 16 | w >>> 16 | 255, N[H + 3] = w << 8 | 255;
                }
                for (let m = S * 4, s = G.length; m < s; m += 3)
                  N[H++] = G[m] << 24 | G[m + 1] << 16 | G[m + 2] << 8 | 255;
              }
              return {
                srcPos: X,
                destPos: H
              };
            }
            function Q(G, X) {
              if (n.FeatureTest.isLittleEndian)
                for (let N = 0, H = G.length; N < H; N++)
                  X[N] = G[N] * 65793 | 4278190080;
              else
                for (let N = 0, H = G.length; N < H; N++)
                  X[N] = G[N] * 16843008 | 255;
            }
          },
          /* 14 */
          /***/
          (e, L) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.GlobalWorkerOptions = void 0;
            const p = /* @__PURE__ */ Object.create(null);
            L.GlobalWorkerOptions = p, p.workerPort = null, p.workerSrc = "";
          },
          /* 15 */
          /***/
          (e, L, p) => {
            var G, io, oo, _a;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.MessageHandler = void 0;
            var n = p(1);
            const t = {
              DATA: 1,
              ERROR: 2
            }, l = {
              CANCEL: 1,
              CANCEL_COMPLETE: 2,
              CLOSE: 3,
              ENQUEUE: 4,
              ERROR: 5,
              PULL: 6,
              PULL_COMPLETE: 7,
              START_COMPLETE: 8
            };
            function W(B) {
              switch (B instanceof Error || typeof B == "object" && B !== null || (0, n.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), B.name) {
                case "AbortException":
                  return new n.AbortException(B.message);
                case "MissingPDFException":
                  return new n.MissingPDFException(B.message);
                case "PasswordException":
                  return new n.PasswordException(B.message, B.code);
                case "UnexpectedResponseException":
                  return new n.UnexpectedResponseException(B.message, B.status);
                case "UnknownErrorException":
                  return new n.UnknownErrorException(B.message, B.details);
                default:
                  return new n.UnknownErrorException(B.message, B.toString());
              }
            }
            class Q {
              constructor(P, S, r) {
                Ne(this, G);
                this.sourceName = P, this.targetName = S, this.comObj = r, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (u) => {
                  const m = u.data;
                  if (m.targetName !== this.sourceName)
                    return;
                  if (m.stream) {
                    Te(this, G, oo).call(this, m);
                    return;
                  }
                  if (m.callback) {
                    const w = m.callbackId, i = this.callbackCapabilities[w];
                    if (!i)
                      throw new Error(`Cannot resolve callback ${w}`);
                    if (delete this.callbackCapabilities[w], m.callback === t.DATA)
                      i.resolve(m.data);
                    else if (m.callback === t.ERROR)
                      i.reject(W(m.reason));
                    else
                      throw new Error("Unexpected callback case");
                    return;
                  }
                  const s = this.actionHandler[m.action];
                  if (!s)
                    throw new Error(`Unknown action from worker: ${m.action}`);
                  if (m.callbackId) {
                    const w = this.sourceName, i = m.sourceName;
                    new Promise(function(o) {
                      o(s(m.data));
                    }).then(function(o) {
                      r.postMessage({
                        sourceName: w,
                        targetName: i,
                        callback: t.DATA,
                        callbackId: m.callbackId,
                        data: o
                      });
                    }, function(o) {
                      r.postMessage({
                        sourceName: w,
                        targetName: i,
                        callback: t.ERROR,
                        callbackId: m.callbackId,
                        reason: W(o)
                      });
                    });
                    return;
                  }
                  if (m.streamId) {
                    Te(this, G, io).call(this, m);
                    return;
                  }
                  s(m.data);
                }, r.addEventListener("message", this._onComObjOnMessage);
              }
              on(P, S) {
                const r = this.actionHandler;
                if (r[P])
                  throw new Error(`There is already an actionName called "${P}"`);
                r[P] = S;
              }
              send(P, S, r) {
                this.comObj.postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: P,
                  data: S
                }, r);
              }
              sendWithPromise(P, S, r) {
                const u = this.callbackId++, m = new n.PromiseCapability();
                this.callbackCapabilities[u] = m;
                try {
                  this.comObj.postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: P,
                    callbackId: u,
                    data: S
                  }, r);
                } catch (s) {
                  m.reject(s);
                }
                return m.promise;
              }
              sendWithStream(P, S, r, u) {
                const m = this.streamId++, s = this.sourceName, w = this.targetName, i = this.comObj;
                return new ReadableStream({
                  start: (o) => {
                    const b = new n.PromiseCapability();
                    return this.streamControllers[m] = {
                      controller: o,
                      startCall: b,
                      pullCall: null,
                      cancelCall: null,
                      isClosed: !1
                    }, i.postMessage({
                      sourceName: s,
                      targetName: w,
                      action: P,
                      streamId: m,
                      data: S,
                      desiredSize: o.desiredSize
                    }, u), b.promise;
                  },
                  pull: (o) => {
                    const b = new n.PromiseCapability();
                    return this.streamControllers[m].pullCall = b, i.postMessage({
                      sourceName: s,
                      targetName: w,
                      stream: l.PULL,
                      streamId: m,
                      desiredSize: o.desiredSize
                    }), b.promise;
                  },
                  cancel: (o) => {
                    (0, n.assert)(o instanceof Error, "cancel must have a valid reason");
                    const b = new n.PromiseCapability();
                    return this.streamControllers[m].cancelCall = b, this.streamControllers[m].isClosed = !0, i.postMessage({
                      sourceName: s,
                      targetName: w,
                      stream: l.CANCEL,
                      streamId: m,
                      reason: W(o)
                    }), b.promise;
                  }
                }, r);
              }
              destroy() {
                this.comObj.removeEventListener("message", this._onComObjOnMessage);
              }
            }
            G = new WeakSet(), io = function(P) {
              const S = P.streamId, r = this.sourceName, u = P.sourceName, m = this.comObj, s = this, w = this.actionHandler[P.action], i = {
                enqueue(o, b = 1, g) {
                  if (this.isCancelled)
                    return;
                  const c = this.desiredSize;
                  this.desiredSize -= b, c > 0 && this.desiredSize <= 0 && (this.sinkCapability = new n.PromiseCapability(), this.ready = this.sinkCapability.promise), m.postMessage({
                    sourceName: r,
                    targetName: u,
                    stream: l.ENQUEUE,
                    streamId: S,
                    chunk: o
                  }, g);
                },
                close() {
                  this.isCancelled || (this.isCancelled = !0, m.postMessage({
                    sourceName: r,
                    targetName: u,
                    stream: l.CLOSE,
                    streamId: S
                  }), delete s.streamSinks[S]);
                },
                error(o) {
                  (0, n.assert)(o instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, m.postMessage({
                    sourceName: r,
                    targetName: u,
                    stream: l.ERROR,
                    streamId: S,
                    reason: W(o)
                  }));
                },
                sinkCapability: new n.PromiseCapability(),
                onPull: null,
                onCancel: null,
                isCancelled: !1,
                desiredSize: P.desiredSize,
                ready: null
              };
              i.sinkCapability.resolve(), i.ready = i.sinkCapability.promise, this.streamSinks[S] = i, new Promise(function(o) {
                o(w(P.data, i));
              }).then(function() {
                m.postMessage({
                  sourceName: r,
                  targetName: u,
                  stream: l.START_COMPLETE,
                  streamId: S,
                  success: !0
                });
              }, function(o) {
                m.postMessage({
                  sourceName: r,
                  targetName: u,
                  stream: l.START_COMPLETE,
                  streamId: S,
                  reason: W(o)
                });
              });
            }, oo = function(P) {
              const S = P.streamId, r = this.sourceName, u = P.sourceName, m = this.comObj, s = this.streamControllers[S], w = this.streamSinks[S];
              switch (P.stream) {
                case l.START_COMPLETE:
                  P.success ? s.startCall.resolve() : s.startCall.reject(W(P.reason));
                  break;
                case l.PULL_COMPLETE:
                  P.success ? s.pullCall.resolve() : s.pullCall.reject(W(P.reason));
                  break;
                case l.PULL:
                  if (!w) {
                    m.postMessage({
                      sourceName: r,
                      targetName: u,
                      stream: l.PULL_COMPLETE,
                      streamId: S,
                      success: !0
                    });
                    break;
                  }
                  w.desiredSize <= 0 && P.desiredSize > 0 && w.sinkCapability.resolve(), w.desiredSize = P.desiredSize, new Promise(function(i) {
                    var o;
                    i((o = w.onPull) == null ? void 0 : o.call(w));
                  }).then(function() {
                    m.postMessage({
                      sourceName: r,
                      targetName: u,
                      stream: l.PULL_COMPLETE,
                      streamId: S,
                      success: !0
                    });
                  }, function(i) {
                    m.postMessage({
                      sourceName: r,
                      targetName: u,
                      stream: l.PULL_COMPLETE,
                      streamId: S,
                      reason: W(i)
                    });
                  });
                  break;
                case l.ENQUEUE:
                  if ((0, n.assert)(s, "enqueue should have stream controller"), s.isClosed)
                    break;
                  s.controller.enqueue(P.chunk);
                  break;
                case l.CLOSE:
                  if ((0, n.assert)(s, "close should have stream controller"), s.isClosed)
                    break;
                  s.isClosed = !0, s.controller.close(), Te(this, G, _a).call(this, s, S);
                  break;
                case l.ERROR:
                  (0, n.assert)(s, "error should have stream controller"), s.controller.error(W(P.reason)), Te(this, G, _a).call(this, s, S);
                  break;
                case l.CANCEL_COMPLETE:
                  P.success ? s.cancelCall.resolve() : s.cancelCall.reject(W(P.reason)), Te(this, G, _a).call(this, s, S);
                  break;
                case l.CANCEL:
                  if (!w)
                    break;
                  new Promise(function(i) {
                    var o;
                    i((o = w.onCancel) == null ? void 0 : o.call(w, W(P.reason)));
                  }).then(function() {
                    m.postMessage({
                      sourceName: r,
                      targetName: u,
                      stream: l.CANCEL_COMPLETE,
                      streamId: S,
                      success: !0
                    });
                  }, function(i) {
                    m.postMessage({
                      sourceName: r,
                      targetName: u,
                      stream: l.CANCEL_COMPLETE,
                      streamId: S,
                      reason: W(i)
                    });
                  }), w.sinkCapability.reject(W(P.reason)), w.isCancelled = !0, delete this.streamSinks[S];
                  break;
                default:
                  throw new Error("Unexpected stream case");
              }
            }, _a = async function(P, S) {
              var r, u, m;
              await Promise.allSettled([(r = P.startCall) == null ? void 0 : r.promise, (u = P.pullCall) == null ? void 0 : u.promise, (m = P.cancelCall) == null ? void 0 : m.promise]), delete this.streamControllers[S];
            }, L.MessageHandler = Q;
          },
          /* 16 */
          /***/
          (e, L, p) => {
            var l, W;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.Metadata = void 0;
            var n = p(1);
            class t {
              constructor({
                parsedData: G,
                rawData: X
              }) {
                Ne(this, l);
                Ne(this, W);
                je(this, l, G), je(this, W, X);
              }
              getRaw() {
                return x(this, W);
              }
              get(G) {
                return x(this, l).get(G) ?? null;
              }
              getAll() {
                return (0, n.objectFromMap)(x(this, l));
              }
              has(G) {
                return x(this, l).has(G);
              }
            }
            l = new WeakMap(), W = new WeakMap(), L.Metadata = t;
          },
          /* 17 */
          /***/
          (e, L, p) => {
            var G, X, N, H, B, P, Ei;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.OptionalContentConfig = void 0;
            var n = p(1), t = p(8);
            const l = Symbol("INTERNAL");
            class W {
              constructor(u, m) {
                Ne(this, G, !0);
                this.name = u, this.intent = m;
              }
              get visible() {
                return x(this, G);
              }
              _setVisible(u, m) {
                u !== l && (0, n.unreachable)("Internal method `_setVisible` called."), je(this, G, m);
              }
            }
            G = new WeakMap();
            class Q {
              constructor(u) {
                Ne(this, P);
                Ne(this, X, null);
                Ne(this, N, /* @__PURE__ */ new Map());
                Ne(this, H, null);
                Ne(this, B, null);
                if (this.name = null, this.creator = null, u !== null) {
                  this.name = u.name, this.creator = u.creator, je(this, B, u.order);
                  for (const m of u.groups)
                    x(this, N).set(m.id, new W(m.name, m.intent));
                  if (u.baseState === "OFF")
                    for (const m of x(this, N).values())
                      m._setVisible(l, !1);
                  for (const m of u.on)
                    x(this, N).get(m)._setVisible(l, !0);
                  for (const m of u.off)
                    x(this, N).get(m)._setVisible(l, !1);
                  je(this, H, this.getHash());
                }
              }
              isVisible(u) {
                if (x(this, N).size === 0)
                  return !0;
                if (!u)
                  return (0, n.warn)("Optional content group not defined."), !0;
                if (u.type === "OCG")
                  return x(this, N).has(u.id) ? x(this, N).get(u.id).visible : ((0, n.warn)(`Optional content group not found: ${u.id}`), !0);
                if (u.type === "OCMD") {
                  if (u.expression)
                    return Te(this, P, Ei).call(this, u.expression);
                  if (!u.policy || u.policy === "AnyOn") {
                    for (const m of u.ids) {
                      if (!x(this, N).has(m))
                        return (0, n.warn)(`Optional content group not found: ${m}`), !0;
                      if (x(this, N).get(m).visible)
                        return !0;
                    }
                    return !1;
                  } else if (u.policy === "AllOn") {
                    for (const m of u.ids) {
                      if (!x(this, N).has(m))
                        return (0, n.warn)(`Optional content group not found: ${m}`), !0;
                      if (!x(this, N).get(m).visible)
                        return !1;
                    }
                    return !0;
                  } else if (u.policy === "AnyOff") {
                    for (const m of u.ids) {
                      if (!x(this, N).has(m))
                        return (0, n.warn)(`Optional content group not found: ${m}`), !0;
                      if (!x(this, N).get(m).visible)
                        return !0;
                    }
                    return !1;
                  } else if (u.policy === "AllOff") {
                    for (const m of u.ids) {
                      if (!x(this, N).has(m))
                        return (0, n.warn)(`Optional content group not found: ${m}`), !0;
                      if (x(this, N).get(m).visible)
                        return !1;
                    }
                    return !0;
                  }
                  return (0, n.warn)(`Unknown optional content policy ${u.policy}.`), !0;
                }
                return (0, n.warn)(`Unknown group type ${u.type}.`), !0;
              }
              setVisibility(u, m = !0) {
                if (!x(this, N).has(u)) {
                  (0, n.warn)(`Optional content group not found: ${u}`);
                  return;
                }
                x(this, N).get(u)._setVisible(l, !!m), je(this, X, null);
              }
              get hasInitialVisibility() {
                return x(this, H) === null || this.getHash() === x(this, H);
              }
              getOrder() {
                return x(this, N).size ? x(this, B) ? x(this, B).slice() : [...x(this, N).keys()] : null;
              }
              getGroups() {
                return x(this, N).size > 0 ? (0, n.objectFromMap)(x(this, N)) : null;
              }
              getGroup(u) {
                return x(this, N).get(u) || null;
              }
              getHash() {
                if (x(this, X) !== null)
                  return x(this, X);
                const u = new t.MurmurHash3_64();
                for (const [m, s] of x(this, N))
                  u.update(`${m}:${s.visible}`);
                return je(this, X, u.hexdigest());
              }
            }
            X = new WeakMap(), N = new WeakMap(), H = new WeakMap(), B = new WeakMap(), P = new WeakSet(), Ei = function(u) {
              const m = u.length;
              if (m < 2)
                return !0;
              const s = u[0];
              for (let w = 1; w < m; w++) {
                const i = u[w];
                let o;
                if (Array.isArray(i))
                  o = Te(this, P, Ei).call(this, i);
                else if (x(this, N).has(i))
                  o = x(this, N).get(i).visible;
                else
                  return (0, n.warn)(`Optional content group not found: ${i}`), !0;
                switch (s) {
                  case "And":
                    if (!o)
                      return !1;
                    break;
                  case "Or":
                    if (o)
                      return !0;
                    break;
                  case "Not":
                    return !o;
                  default:
                    return !0;
                }
              }
              return s === "And";
            }, L.OptionalContentConfig = Q;
          },
          /* 18 */
          /***/
          (e, L, p) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.PDFDataTransportStream = void 0;
            var n = p(1), t = p(6);
            class l {
              constructor({
                length: X,
                initialData: N,
                progressiveDone: H = !1,
                contentDispositionFilename: B = null,
                disableRange: P = !1,
                disableStream: S = !1
              }, r) {
                if ((0, n.assert)(r, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = H, this._contentDispositionFilename = B, (N == null ? void 0 : N.length) > 0) {
                  const u = N instanceof Uint8Array && N.byteLength === N.buffer.byteLength ? N.buffer : new Uint8Array(N).buffer;
                  this._queuedChunks.push(u);
                }
                this._pdfDataRangeTransport = r, this._isStreamingSupported = !S, this._isRangeSupported = !P, this._contentLength = X, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((u, m) => {
                  this._onReceiveData({
                    begin: u,
                    chunk: m
                  });
                }), this._pdfDataRangeTransport.addProgressListener((u, m) => {
                  this._onProgress({
                    loaded: u,
                    total: m
                  });
                }), this._pdfDataRangeTransport.addProgressiveReadListener((u) => {
                  this._onReceiveData({
                    chunk: u
                  });
                }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                  this._onProgressiveDone();
                }), this._pdfDataRangeTransport.transportReady();
              }
              _onReceiveData({
                begin: X,
                chunk: N
              }) {
                const H = N instanceof Uint8Array && N.byteLength === N.buffer.byteLength ? N.buffer : new Uint8Array(N).buffer;
                if (X === void 0)
                  this._fullRequestReader ? this._fullRequestReader._enqueue(H) : this._queuedChunks.push(H);
                else {
                  const B = this._rangeReaders.some(function(P) {
                    return P._begin !== X ? !1 : (P._enqueue(H), !0);
                  });
                  (0, n.assert)(B, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
                }
              }
              get _progressiveDataLength() {
                var X;
                return ((X = this._fullRequestReader) == null ? void 0 : X._loaded) ?? 0;
              }
              _onProgress(X) {
                var N, H, B, P;
                X.total === void 0 ? (H = (N = this._rangeReaders[0]) == null ? void 0 : N.onProgress) == null || H.call(N, {
                  loaded: X.loaded
                }) : (P = (B = this._fullRequestReader) == null ? void 0 : B.onProgress) == null || P.call(B, {
                  loaded: X.loaded,
                  total: X.total
                });
              }
              _onProgressiveDone() {
                var X;
                (X = this._fullRequestReader) == null || X.progressiveDone(), this._progressiveDone = !0;
              }
              _removeRangeReader(X) {
                const N = this._rangeReaders.indexOf(X);
                N >= 0 && this._rangeReaders.splice(N, 1);
              }
              getFullReader() {
                (0, n.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                const X = this._queuedChunks;
                return this._queuedChunks = null, new W(this, X, this._progressiveDone, this._contentDispositionFilename);
              }
              getRangeReader(X, N) {
                if (N <= this._progressiveDataLength)
                  return null;
                const H = new Q(this, X, N);
                return this._pdfDataRangeTransport.requestDataRange(X, N), this._rangeReaders.push(H), H;
              }
              cancelAllRequests(X) {
                var N;
                (N = this._fullRequestReader) == null || N.cancel(X);
                for (const H of this._rangeReaders.slice(0))
                  H.cancel(X);
                this._pdfDataRangeTransport.abort();
              }
            }
            L.PDFDataTransportStream = l;
            class W {
              constructor(X, N, H = !1, B = null) {
                this._stream = X, this._done = H || !1, this._filename = (0, t.isPdfFile)(B) ? B : null, this._queuedChunks = N || [], this._loaded = 0;
                for (const P of this._queuedChunks)
                  this._loaded += P.byteLength;
                this._requests = [], this._headersReady = Promise.resolve(), X._fullRequestReader = this, this.onProgress = null;
              }
              _enqueue(X) {
                this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
                  value: X,
                  done: !1
                }) : this._queuedChunks.push(X), this._loaded += X.byteLength);
              }
              get headersReady() {
                return this._headersReady;
              }
              get filename() {
                return this._filename;
              }
              get isRangeSupported() {
                return this._stream._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._stream._isStreamingSupported;
              }
              get contentLength() {
                return this._stream._contentLength;
              }
              async read() {
                if (this._queuedChunks.length > 0)
                  return {
                    value: this._queuedChunks.shift(),
                    done: !1
                  };
                if (this._done)
                  return {
                    value: void 0,
                    done: !0
                  };
                const X = new n.PromiseCapability();
                return this._requests.push(X), X.promise;
              }
              cancel(X) {
                this._done = !0;
                for (const N of this._requests)
                  N.resolve({
                    value: void 0,
                    done: !0
                  });
                this._requests.length = 0;
              }
              progressiveDone() {
                this._done || (this._done = !0);
              }
            }
            class Q {
              constructor(X, N, H) {
                this._stream = X, this._begin = N, this._end = H, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
              }
              _enqueue(X) {
                if (!this._done) {
                  if (this._requests.length === 0)
                    this._queuedChunk = X;
                  else {
                    this._requests.shift().resolve({
                      value: X,
                      done: !1
                    });
                    for (const H of this._requests)
                      H.resolve({
                        value: void 0,
                        done: !0
                      });
                    this._requests.length = 0;
                  }
                  this._done = !0, this._stream._removeRangeReader(this);
                }
              }
              get isStreamingSupported() {
                return !1;
              }
              async read() {
                if (this._queuedChunk) {
                  const N = this._queuedChunk;
                  return this._queuedChunk = null, {
                    value: N,
                    done: !1
                  };
                }
                if (this._done)
                  return {
                    value: void 0,
                    done: !0
                  };
                const X = new n.PromiseCapability();
                return this._requests.push(X), X.promise;
              }
              cancel(X) {
                this._done = !0;
                for (const N of this._requests)
                  N.resolve({
                    value: void 0,
                    done: !0
                  });
                this._requests.length = 0, this._stream._removeRangeReader(this);
              }
            }
          },
          /* 19 */
          /***/
          (e, L, p) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.PDFFetchStream = void 0;
            var n = p(1), t = p(20);
            function l(H, B, P) {
              return {
                method: "GET",
                headers: H,
                signal: P.signal,
                mode: "cors",
                credentials: B ? "include" : "same-origin",
                redirect: "follow"
              };
            }
            function W(H) {
              const B = new Headers();
              for (const P in H) {
                const S = H[P];
                S !== void 0 && B.append(P, S);
              }
              return B;
            }
            function Q(H) {
              return H instanceof Uint8Array ? H.buffer : H instanceof ArrayBuffer ? H : ((0, n.warn)(`getArrayBuffer - unexpected data format: ${H}`), new Uint8Array(H).buffer);
            }
            class G {
              constructor(B) {
                this.source = B, this.isHttp = /^https?:/i.test(B.url), this.httpHeaders = this.isHttp && B.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
              }
              get _progressiveDataLength() {
                var B;
                return ((B = this._fullRequestReader) == null ? void 0 : B._loaded) ?? 0;
              }
              getFullReader() {
                return (0, n.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new X(this), this._fullRequestReader;
              }
              getRangeReader(B, P) {
                if (P <= this._progressiveDataLength)
                  return null;
                const S = new N(this, B, P);
                return this._rangeRequestReaders.push(S), S;
              }
              cancelAllRequests(B) {
                var P;
                (P = this._fullRequestReader) == null || P.cancel(B);
                for (const S of this._rangeRequestReaders.slice(0))
                  S.cancel(B);
              }
            }
            L.PDFFetchStream = G;
            class X {
              constructor(B) {
                this._stream = B, this._reader = null, this._loaded = 0, this._filename = null;
                const P = B.source;
                this._withCredentials = P.withCredentials || !1, this._contentLength = P.length, this._headersCapability = new n.PromiseCapability(), this._disableRange = P.disableRange || !1, this._rangeChunkSize = P.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !P.disableStream, this._isRangeSupported = !P.disableRange, this._headers = W(this._stream.httpHeaders);
                const S = P.url;
                fetch(S, l(this._headers, this._withCredentials, this._abortController)).then((r) => {
                  if (!(0, t.validateResponseStatus)(r.status))
                    throw (0, t.createResponseStatusError)(r.status, S);
                  this._reader = r.body.getReader(), this._headersCapability.resolve();
                  const u = (w) => r.headers.get(w), {
                    allowRangeRequests: m,
                    suggestedLength: s
                  } = (0, t.validateRangeRequestCapabilities)({
                    getResponseHeader: u,
                    isHttp: this._stream.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  this._isRangeSupported = m, this._contentLength = s || this._contentLength, this._filename = (0, t.extractFilenameFromHeader)(u), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new n.AbortException("Streaming is disabled."));
                }).catch(this._headersCapability.reject), this.onProgress = null;
              }
              get headersReady() {
                return this._headersCapability.promise;
              }
              get filename() {
                return this._filename;
              }
              get contentLength() {
                return this._contentLength;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                var S;
                await this._headersCapability.promise;
                const {
                  value: B,
                  done: P
                } = await this._reader.read();
                return P ? {
                  value: B,
                  done: P
                } : (this._loaded += B.byteLength, (S = this.onProgress) == null || S.call(this, {
                  loaded: this._loaded,
                  total: this._contentLength
                }), {
                  value: Q(B),
                  done: !1
                });
              }
              cancel(B) {
                var P;
                (P = this._reader) == null || P.cancel(B), this._abortController.abort();
              }
            }
            class N {
              constructor(B, P, S) {
                this._stream = B, this._reader = null, this._loaded = 0;
                const r = B.source;
                this._withCredentials = r.withCredentials || !1, this._readCapability = new n.PromiseCapability(), this._isStreamingSupported = !r.disableStream, this._abortController = new AbortController(), this._headers = W(this._stream.httpHeaders), this._headers.append("Range", `bytes=${P}-${S - 1}`);
                const u = r.url;
                fetch(u, l(this._headers, this._withCredentials, this._abortController)).then((m) => {
                  if (!(0, t.validateResponseStatus)(m.status))
                    throw (0, t.createResponseStatusError)(m.status, u);
                  this._readCapability.resolve(), this._reader = m.body.getReader();
                }).catch(this._readCapability.reject), this.onProgress = null;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                var S;
                await this._readCapability.promise;
                const {
                  value: B,
                  done: P
                } = await this._reader.read();
                return P ? {
                  value: B,
                  done: P
                } : (this._loaded += B.byteLength, (S = this.onProgress) == null || S.call(this, {
                  loaded: this._loaded
                }), {
                  value: Q(B),
                  done: !1
                });
              }
              cancel(B) {
                var P;
                (P = this._reader) == null || P.cancel(B), this._abortController.abort();
              }
            }
          },
          /* 20 */
          /***/
          (e, L, p) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.createResponseStatusError = G, L.extractFilenameFromHeader = Q, L.validateRangeRequestCapabilities = W, L.validateResponseStatus = X;
            var n = p(1), t = p(21), l = p(6);
            function W({
              getResponseHeader: N,
              isHttp: H,
              rangeChunkSize: B,
              disableRange: P
            }) {
              const S = {
                allowRangeRequests: !1,
                suggestedLength: void 0
              }, r = parseInt(N("Content-Length"), 10);
              return !Number.isInteger(r) || (S.suggestedLength = r, r <= 2 * B) || P || !H || N("Accept-Ranges") !== "bytes" || (N("Content-Encoding") || "identity") !== "identity" || (S.allowRangeRequests = !0), S;
            }
            function Q(N) {
              const H = N("Content-Disposition");
              if (H) {
                let B = (0, t.getFilenameFromContentDispositionHeader)(H);
                if (B.includes("%"))
                  try {
                    B = decodeURIComponent(B);
                  } catch {
                  }
                if ((0, l.isPdfFile)(B))
                  return B;
              }
              return null;
            }
            function G(N, H) {
              return N === 404 || N === 0 && H.startsWith("file:") ? new n.MissingPDFException('Missing PDF "' + H + '".') : new n.UnexpectedResponseException(`Unexpected server response (${N}) while retrieving PDF "${H}".`, N);
            }
            function X(N) {
              return N === 200 || N === 206;
            }
          },
          /* 21 */
          /***/
          (e, L, p) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.getFilenameFromContentDispositionHeader = t;
            var n = p(1);
            function t(l) {
              let W = !0, Q = G("filename\\*", "i").exec(l);
              if (Q) {
                Q = Q[1];
                let r = B(Q);
                return r = unescape(r), r = P(r), r = S(r), N(r);
              }
              if (Q = H(l), Q) {
                const r = S(Q);
                return N(r);
              }
              if (Q = G("filename", "i").exec(l), Q) {
                Q = Q[1];
                let r = B(Q);
                return r = S(r), N(r);
              }
              function G(r, u) {
                return new RegExp("(?:^|;)\\s*" + r + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', u);
              }
              function X(r, u) {
                if (r) {
                  if (!/^[\x00-\xFF]+$/.test(u))
                    return u;
                  try {
                    const m = new TextDecoder(r, {
                      fatal: !0
                    }), s = (0, n.stringToBytes)(u);
                    u = m.decode(s), W = !1;
                  } catch {
                  }
                }
                return u;
              }
              function N(r) {
                return W && /[\x80-\xff]/.test(r) && (r = X("utf-8", r), W && (r = X("iso-8859-1", r))), r;
              }
              function H(r) {
                const u = [];
                let m;
                const s = G("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                for (; (m = s.exec(r)) !== null; ) {
                  let [, i, o, b] = m;
                  if (i = parseInt(i, 10), i in u) {
                    if (i === 0)
                      break;
                    continue;
                  }
                  u[i] = [o, b];
                }
                const w = [];
                for (let i = 0; i < u.length && i in u; ++i) {
                  let [o, b] = u[i];
                  b = B(b), o && (b = unescape(b), i === 0 && (b = P(b))), w.push(b);
                }
                return w.join("");
              }
              function B(r) {
                if (r.startsWith('"')) {
                  const u = r.slice(1).split('\\"');
                  for (let m = 0; m < u.length; ++m) {
                    const s = u[m].indexOf('"');
                    s !== -1 && (u[m] = u[m].slice(0, s), u.length = m + 1), u[m] = u[m].replaceAll(/\\(.)/g, "$1");
                  }
                  r = u.join('"');
                }
                return r;
              }
              function P(r) {
                const u = r.indexOf("'");
                if (u === -1)
                  return r;
                const m = r.slice(0, u), w = r.slice(u + 1).replace(/^[^']*'/, "");
                return X(m, w);
              }
              function S(r) {
                return !r.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(r) ? r : r.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(u, m, s, w) {
                  if (s === "q" || s === "Q")
                    return w = w.replaceAll("_", " "), w = w.replaceAll(/=([0-9a-fA-F]{2})/g, function(i, o) {
                      return String.fromCharCode(parseInt(o, 16));
                    }), X(m, w);
                  try {
                    w = atob(w);
                  } catch {
                  }
                  return X(m, w);
                });
              }
              return "";
            }
          },
          /* 22 */
          /***/
          (e, L, p) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.PDFNetworkStream = void 0;
            var n = p(1), t = p(20);
            const l = 200, W = 206;
            function Q(B) {
              const P = B.response;
              return typeof P != "string" ? P : (0, n.stringToBytes)(P).buffer;
            }
            class G {
              constructor(P, S = {}) {
                this.url = P, this.isHttp = /^https?:/i.test(P), this.httpHeaders = this.isHttp && S.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = S.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
              }
              requestRange(P, S, r) {
                const u = {
                  begin: P,
                  end: S
                };
                for (const m in r)
                  u[m] = r[m];
                return this.request(u);
              }
              requestFull(P) {
                return this.request(P);
              }
              request(P) {
                const S = new XMLHttpRequest(), r = this.currXhrId++, u = this.pendingRequests[r] = {
                  xhr: S
                };
                S.open("GET", this.url), S.withCredentials = this.withCredentials;
                for (const m in this.httpHeaders) {
                  const s = this.httpHeaders[m];
                  s !== void 0 && S.setRequestHeader(m, s);
                }
                return this.isHttp && "begin" in P && "end" in P ? (S.setRequestHeader("Range", `bytes=${P.begin}-${P.end - 1}`), u.expectedStatus = W) : u.expectedStatus = l, S.responseType = "arraybuffer", P.onError && (S.onerror = function(m) {
                  P.onError(S.status);
                }), S.onreadystatechange = this.onStateChange.bind(this, r), S.onprogress = this.onProgress.bind(this, r), u.onHeadersReceived = P.onHeadersReceived, u.onDone = P.onDone, u.onError = P.onError, u.onProgress = P.onProgress, S.send(null), r;
              }
              onProgress(P, S) {
                var u;
                const r = this.pendingRequests[P];
                r && ((u = r.onProgress) == null || u.call(r, S));
              }
              onStateChange(P, S) {
                var i, o, b;
                const r = this.pendingRequests[P];
                if (!r)
                  return;
                const u = r.xhr;
                if (u.readyState >= 2 && r.onHeadersReceived && (r.onHeadersReceived(), delete r.onHeadersReceived), u.readyState !== 4 || !(P in this.pendingRequests))
                  return;
                if (delete this.pendingRequests[P], u.status === 0 && this.isHttp) {
                  (i = r.onError) == null || i.call(r, u.status);
                  return;
                }
                const m = u.status || l;
                if (!(m === l && r.expectedStatus === W) && m !== r.expectedStatus) {
                  (o = r.onError) == null || o.call(r, u.status);
                  return;
                }
                const w = Q(u);
                if (m === W) {
                  const g = u.getResponseHeader("Content-Range"), c = /bytes (\d+)-(\d+)\/(\d+)/.exec(g);
                  r.onDone({
                    begin: parseInt(c[1], 10),
                    chunk: w
                  });
                } else w ? r.onDone({
                  begin: 0,
                  chunk: w
                }) : (b = r.onError) == null || b.call(r, u.status);
              }
              getRequestXhr(P) {
                return this.pendingRequests[P].xhr;
              }
              isPendingRequest(P) {
                return P in this.pendingRequests;
              }
              abortRequest(P) {
                const S = this.pendingRequests[P].xhr;
                delete this.pendingRequests[P], S.abort();
              }
            }
            class X {
              constructor(P) {
                this._source = P, this._manager = new G(P.url, {
                  httpHeaders: P.httpHeaders,
                  withCredentials: P.withCredentials
                }), this._rangeChunkSize = P.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
              }
              _onRangeRequestReaderClosed(P) {
                const S = this._rangeRequestReaders.indexOf(P);
                S >= 0 && this._rangeRequestReaders.splice(S, 1);
              }
              getFullReader() {
                return (0, n.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new N(this._manager, this._source), this._fullRequestReader;
              }
              getRangeReader(P, S) {
                const r = new H(this._manager, P, S);
                return r.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(r), r;
              }
              cancelAllRequests(P) {
                var S;
                (S = this._fullRequestReader) == null || S.cancel(P);
                for (const r of this._rangeRequestReaders.slice(0))
                  r.cancel(P);
              }
            }
            L.PDFNetworkStream = X;
            class N {
              constructor(P, S) {
                this._manager = P;
                const r = {
                  onHeadersReceived: this._onHeadersReceived.bind(this),
                  onDone: this._onDone.bind(this),
                  onError: this._onError.bind(this),
                  onProgress: this._onProgress.bind(this)
                };
                this._url = S.url, this._fullRequestId = P.requestFull(r), this._headersReceivedCapability = new n.PromiseCapability(), this._disableRange = S.disableRange || !1, this._contentLength = S.length, this._rangeChunkSize = S.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
              }
              _onHeadersReceived() {
                const P = this._fullRequestId, S = this._manager.getRequestXhr(P), r = (s) => S.getResponseHeader(s), {
                  allowRangeRequests: u,
                  suggestedLength: m
                } = (0, t.validateRangeRequestCapabilities)({
                  getResponseHeader: r,
                  isHttp: this._manager.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                u && (this._isRangeSupported = !0), this._contentLength = m || this._contentLength, this._filename = (0, t.extractFilenameFromHeader)(r), this._isRangeSupported && this._manager.abortRequest(P), this._headersReceivedCapability.resolve();
              }
              _onDone(P) {
                if (P && (this._requests.length > 0 ? this._requests.shift().resolve({
                  value: P.chunk,
                  done: !1
                }) : this._cachedChunks.push(P.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
                  for (const S of this._requests)
                    S.resolve({
                      value: void 0,
                      done: !0
                    });
                  this._requests.length = 0;
                }
              }
              _onError(P) {
                this._storedError = (0, t.createResponseStatusError)(P, this._url), this._headersReceivedCapability.reject(this._storedError);
                for (const S of this._requests)
                  S.reject(this._storedError);
                this._requests.length = 0, this._cachedChunks.length = 0;
              }
              _onProgress(P) {
                var S;
                (S = this.onProgress) == null || S.call(this, {
                  loaded: P.loaded,
                  total: P.lengthComputable ? P.total : this._contentLength
                });
              }
              get filename() {
                return this._filename;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              get contentLength() {
                return this._contentLength;
              }
              get headersReady() {
                return this._headersReceivedCapability.promise;
              }
              async read() {
                if (this._storedError)
                  throw this._storedError;
                if (this._cachedChunks.length > 0)
                  return {
                    value: this._cachedChunks.shift(),
                    done: !1
                  };
                if (this._done)
                  return {
                    value: void 0,
                    done: !0
                  };
                const P = new n.PromiseCapability();
                return this._requests.push(P), P.promise;
              }
              cancel(P) {
                this._done = !0, this._headersReceivedCapability.reject(P);
                for (const S of this._requests)
                  S.resolve({
                    value: void 0,
                    done: !0
                  });
                this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
              }
            }
            class H {
              constructor(P, S, r) {
                this._manager = P;
                const u = {
                  onDone: this._onDone.bind(this),
                  onError: this._onError.bind(this),
                  onProgress: this._onProgress.bind(this)
                };
                this._url = P.url, this._requestId = P.requestRange(S, r, u), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
              }
              _close() {
                var P;
                (P = this.onClosed) == null || P.call(this, this);
              }
              _onDone(P) {
                const S = P.chunk;
                this._requests.length > 0 ? this._requests.shift().resolve({
                  value: S,
                  done: !1
                }) : this._queuedChunk = S, this._done = !0;
                for (const r of this._requests)
                  r.resolve({
                    value: void 0,
                    done: !0
                  });
                this._requests.length = 0, this._close();
              }
              _onError(P) {
                this._storedError = (0, t.createResponseStatusError)(P, this._url);
                for (const S of this._requests)
                  S.reject(this._storedError);
                this._requests.length = 0, this._queuedChunk = null;
              }
              _onProgress(P) {
                var S;
                this.isStreamingSupported || (S = this.onProgress) == null || S.call(this, {
                  loaded: P.loaded
                });
              }
              get isStreamingSupported() {
                return !1;
              }
              async read() {
                if (this._storedError)
                  throw this._storedError;
                if (this._queuedChunk !== null) {
                  const S = this._queuedChunk;
                  return this._queuedChunk = null, {
                    value: S,
                    done: !1
                  };
                }
                if (this._done)
                  return {
                    value: void 0,
                    done: !0
                  };
                const P = new n.PromiseCapability();
                return this._requests.push(P), P.promise;
              }
              cancel(P) {
                this._done = !0;
                for (const S of this._requests)
                  S.resolve({
                    value: void 0,
                    done: !0
                  });
                this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
              }
            }
          },
          /* 23 */
          /***/
          (e, L, p) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.PDFNodeStream = void 0;
            var n = p(1), t = p(20);
            const l = /^file:\/\/\/[a-zA-Z]:\//;
            function W(r) {
              const u = require$$5, m = u.parse(r);
              return m.protocol === "file:" || m.host ? m : /^[a-z]:[/\\]/i.test(r) ? u.parse(`file:///${r}`) : (m.host || (m.protocol = "file:"), m);
            }
            class Q {
              constructor(u) {
                this.source = u, this.url = W(u.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && u.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
              }
              get _progressiveDataLength() {
                var u;
                return ((u = this._fullRequestReader) == null ? void 0 : u._loaded) ?? 0;
              }
              getFullReader() {
                return (0, n.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new P(this) : new H(this), this._fullRequestReader;
              }
              getRangeReader(u, m) {
                if (m <= this._progressiveDataLength)
                  return null;
                const s = this.isFsUrl ? new S(this, u, m) : new B(this, u, m);
                return this._rangeRequestReaders.push(s), s;
              }
              cancelAllRequests(u) {
                var m;
                (m = this._fullRequestReader) == null || m.cancel(u);
                for (const s of this._rangeRequestReaders.slice(0))
                  s.cancel(u);
              }
            }
            L.PDFNodeStream = Q;
            class G {
              constructor(u) {
                this._url = u.url, this._done = !1, this._storedError = null, this.onProgress = null;
                const m = u.source;
                this._contentLength = m.length, this._loaded = 0, this._filename = null, this._disableRange = m.disableRange || !1, this._rangeChunkSize = m.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !m.disableStream, this._isRangeSupported = !m.disableRange, this._readableStream = null, this._readCapability = new n.PromiseCapability(), this._headersCapability = new n.PromiseCapability();
              }
              get headersReady() {
                return this._headersCapability.promise;
              }
              get filename() {
                return this._filename;
              }
              get contentLength() {
                return this._contentLength;
              }
              get isRangeSupported() {
                return this._isRangeSupported;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                var s;
                if (await this._readCapability.promise, this._done)
                  return {
                    value: void 0,
                    done: !0
                  };
                if (this._storedError)
                  throw this._storedError;
                const u = this._readableStream.read();
                return u === null ? (this._readCapability = new n.PromiseCapability(), this.read()) : (this._loaded += u.length, (s = this.onProgress) == null || s.call(this, {
                  loaded: this._loaded,
                  total: this._contentLength
                }), {
                  value: new Uint8Array(u).buffer,
                  done: !1
                });
              }
              cancel(u) {
                if (!this._readableStream) {
                  this._error(u);
                  return;
                }
                this._readableStream.destroy(u);
              }
              _error(u) {
                this._storedError = u, this._readCapability.resolve();
              }
              _setReadableStream(u) {
                this._readableStream = u, u.on("readable", () => {
                  this._readCapability.resolve();
                }), u.on("end", () => {
                  u.destroy(), this._done = !0, this._readCapability.resolve();
                }), u.on("error", (m) => {
                  this._error(m);
                }), !this._isStreamingSupported && this._isRangeSupported && this._error(new n.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
              }
            }
            class X {
              constructor(u) {
                this._url = u.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = new n.PromiseCapability();
                const m = u.source;
                this._isStreamingSupported = !m.disableStream;
              }
              get isStreamingSupported() {
                return this._isStreamingSupported;
              }
              async read() {
                var s;
                if (await this._readCapability.promise, this._done)
                  return {
                    value: void 0,
                    done: !0
                  };
                if (this._storedError)
                  throw this._storedError;
                const u = this._readableStream.read();
                return u === null ? (this._readCapability = new n.PromiseCapability(), this.read()) : (this._loaded += u.length, (s = this.onProgress) == null || s.call(this, {
                  loaded: this._loaded
                }), {
                  value: new Uint8Array(u).buffer,
                  done: !1
                });
              }
              cancel(u) {
                if (!this._readableStream) {
                  this._error(u);
                  return;
                }
                this._readableStream.destroy(u);
              }
              _error(u) {
                this._storedError = u, this._readCapability.resolve();
              }
              _setReadableStream(u) {
                this._readableStream = u, u.on("readable", () => {
                  this._readCapability.resolve();
                }), u.on("end", () => {
                  u.destroy(), this._done = !0, this._readCapability.resolve();
                }), u.on("error", (m) => {
                  this._error(m);
                }), this._storedError && this._readableStream.destroy(this._storedError);
              }
            }
            function N(r, u) {
              return {
                protocol: r.protocol,
                auth: r.auth,
                host: r.hostname,
                port: r.port,
                path: r.path,
                method: "GET",
                headers: u
              };
            }
            class H extends G {
              constructor(u) {
                super(u);
                const m = (s) => {
                  if (s.statusCode === 404) {
                    const b = new n.MissingPDFException(`Missing PDF "${this._url}".`);
                    this._storedError = b, this._headersCapability.reject(b);
                    return;
                  }
                  this._headersCapability.resolve(), this._setReadableStream(s);
                  const w = (b) => this._readableStream.headers[b.toLowerCase()], {
                    allowRangeRequests: i,
                    suggestedLength: o
                  } = (0, t.validateRangeRequestCapabilities)({
                    getResponseHeader: w,
                    isHttp: u.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  this._isRangeSupported = i, this._contentLength = o || this._contentLength, this._filename = (0, t.extractFilenameFromHeader)(w);
                };
                if (this._request = null, this._url.protocol === "http:") {
                  const s = require$$5;
                  this._request = s.request(N(this._url, u.httpHeaders), m);
                } else {
                  const s = require$$5;
                  this._request = s.request(N(this._url, u.httpHeaders), m);
                }
                this._request.on("error", (s) => {
                  this._storedError = s, this._headersCapability.reject(s);
                }), this._request.end();
              }
            }
            class B extends X {
              constructor(u, m, s) {
                super(u), this._httpHeaders = {};
                for (const i in u.httpHeaders) {
                  const o = u.httpHeaders[i];
                  o !== void 0 && (this._httpHeaders[i] = o);
                }
                this._httpHeaders.Range = `bytes=${m}-${s - 1}`;
                const w = (i) => {
                  if (i.statusCode === 404) {
                    const o = new n.MissingPDFException(`Missing PDF "${this._url}".`);
                    this._storedError = o;
                    return;
                  }
                  this._setReadableStream(i);
                };
                if (this._request = null, this._url.protocol === "http:") {
                  const i = require$$5;
                  this._request = i.request(N(this._url, this._httpHeaders), w);
                } else {
                  const i = require$$5;
                  this._request = i.request(N(this._url, this._httpHeaders), w);
                }
                this._request.on("error", (i) => {
                  this._storedError = i;
                }), this._request.end();
              }
            }
            class P extends G {
              constructor(u) {
                super(u);
                let m = decodeURIComponent(this._url.path);
                l.test(this._url.href) && (m = m.replace(/^\//, ""));
                const s = require$$5;
                s.lstat(m, (w, i) => {
                  if (w) {
                    w.code === "ENOENT" && (w = new n.MissingPDFException(`Missing PDF "${m}".`)), this._storedError = w, this._headersCapability.reject(w);
                    return;
                  }
                  this._contentLength = i.size, this._setReadableStream(s.createReadStream(m)), this._headersCapability.resolve();
                });
              }
            }
            class S extends X {
              constructor(u, m, s) {
                super(u);
                let w = decodeURIComponent(this._url.path);
                l.test(this._url.href) && (w = w.replace(/^\//, ""));
                const i = require$$5;
                this._setReadableStream(i.createReadStream(w, {
                  start: m,
                  end: s - 1
                }));
              }
            }
          },
          /* 24 */
          /***/
          (e, L, p) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.SVGGraphics = void 0;
            var n = p(6), t = p(1);
            const l = {
              fontStyle: "normal",
              fontWeight: "normal",
              fillColor: "#000000"
            }, W = "http://www.w3.org/XML/1998/namespace", Q = "http://www.w3.org/1999/xlink", G = ["butt", "round", "square"], X = ["miter", "round", "bevel"], N = function(i, o = "", b = !1) {
              if (URL.createObjectURL && typeof Blob < "u" && !b)
                return URL.createObjectURL(new Blob([i], {
                  type: o
                }));
              const g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
              let c = `data:${o};base64,`;
              for (let v = 0, k = i.length; v < k; v += 3) {
                const a = i[v] & 255, f = i[v + 1] & 255, C = i[v + 2] & 255, R = a >> 2, M = (a & 3) << 4 | f >> 4, I = v + 1 < k ? (f & 15) << 2 | C >> 6 : 64, E = v + 2 < k ? C & 63 : 64;
                c += g[R] + g[M] + g[I] + g[E];
              }
              return c;
            }, H = function() {
              const i = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]), o = 12, b = new Int32Array(256);
              for (let C = 0; C < 256; C++) {
                let R = C;
                for (let M = 0; M < 8; M++)
                  R = R & 1 ? 3988292384 ^ R >> 1 & 2147483647 : R >> 1 & 2147483647;
                b[C] = R;
              }
              function g(C, R, M) {
                let I = -1;
                for (let E = R; E < M; E++) {
                  const T = (I ^ C[E]) & 255, y = b[T];
                  I = I >>> 8 ^ y;
                }
                return I ^ -1;
              }
              function c(C, R, M, I) {
                let E = I;
                const T = R.length;
                M[E] = T >> 24 & 255, M[E + 1] = T >> 16 & 255, M[E + 2] = T >> 8 & 255, M[E + 3] = T & 255, E += 4, M[E] = C.charCodeAt(0) & 255, M[E + 1] = C.charCodeAt(1) & 255, M[E + 2] = C.charCodeAt(2) & 255, M[E + 3] = C.charCodeAt(3) & 255, E += 4, M.set(R, E), E += R.length;
                const y = g(M, I + 4, E);
                M[E] = y >> 24 & 255, M[E + 1] = y >> 16 & 255, M[E + 2] = y >> 8 & 255, M[E + 3] = y & 255;
              }
              function v(C, R, M) {
                let I = 1, E = 0;
                for (let T = R; T < M; ++T)
                  I = (I + (C[T] & 255)) % 65521, E = (E + I) % 65521;
                return E << 16 | I;
              }
              function k(C) {
                if (!t.isNodeJS)
                  return a(C);
                try {
                  const R = parseInt(process.versions.node) >= 8 ? C : Buffer.from(C), M = require$$5.deflateSync(R, {
                    level: 9
                  });
                  return M instanceof Uint8Array ? M : new Uint8Array(M);
                } catch (R) {
                  (0, t.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + R);
                }
                return a(C);
              }
              function a(C) {
                let R = C.length;
                const M = 65535, I = Math.ceil(R / M), E = new Uint8Array(2 + R + I * 5 + 4);
                let T = 0;
                E[T++] = 120, E[T++] = 156;
                let y = 0;
                for (; R > M; )
                  E[T++] = 0, E[T++] = 255, E[T++] = 255, E[T++] = 0, E[T++] = 0, E.set(C.subarray(y, y + M), T), T += M, y += M, R -= M;
                E[T++] = 1, E[T++] = R & 255, E[T++] = R >> 8 & 255, E[T++] = ~R & 65535 & 255, E[T++] = (~R & 65535) >> 8 & 255, E.set(C.subarray(y), T), T += C.length - y;
                const D = v(C, 0, C.length);
                return E[T++] = D >> 24 & 255, E[T++] = D >> 16 & 255, E[T++] = D >> 8 & 255, E[T++] = D & 255, E;
              }
              function f(C, R, M, I) {
                const E = C.width, T = C.height;
                let y, D, j;
                const A = C.data;
                switch (R) {
                  case t.ImageKind.GRAYSCALE_1BPP:
                    D = 0, y = 1, j = E + 7 >> 3;
                    break;
                  case t.ImageKind.RGB_24BPP:
                    D = 2, y = 8, j = E * 3;
                    break;
                  case t.ImageKind.RGBA_32BPP:
                    D = 6, y = 8, j = E * 4;
                    break;
                  default:
                    throw new Error("invalid format");
                }
                const d = new Uint8Array((1 + j) * T);
                let _ = 0, F = 0;
                for (let be = 0; be < T; ++be)
                  d[_++] = 0, d.set(A.subarray(F, F + j), _), F += j, _ += j;
                if (R === t.ImageKind.GRAYSCALE_1BPP && I) {
                  _ = 0;
                  for (let be = 0; be < T; be++) {
                    _++;
                    for (let le = 0; le < j; le++)
                      d[_++] ^= 255;
                  }
                }
                const U = new Uint8Array([E >> 24 & 255, E >> 16 & 255, E >> 8 & 255, E & 255, T >> 24 & 255, T >> 16 & 255, T >> 8 & 255, T & 255, y, D, 0, 0, 0]), V = k(d), $ = i.length + o * 3 + U.length + V.length, re = new Uint8Array($);
                let ge = 0;
                return re.set(i, ge), ge += i.length, c("IHDR", U, re, ge), ge += o + U.length, c("IDATA", V, re, ge), ge += o + V.length, c("IEND", new Uint8Array(0), re, ge), N(re, "image/png", M);
              }
              return function(R, M, I) {
                const E = R.kind === void 0 ? t.ImageKind.GRAYSCALE_1BPP : R.kind;
                return f(R, E, M, I);
              };
            }();
            class B {
              constructor() {
                this.fontSizeScale = 1, this.fontWeight = l.fontWeight, this.fontSize = 0, this.textMatrix = t.IDENTITY_MATRIX, this.fontMatrix = t.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = t.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = l.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "";
              }
              clone() {
                return Object.create(this);
              }
              setCurrentPoint(o, b) {
                this.x = o, this.y = b;
              }
            }
            function P(i) {
              let o = [];
              const b = [];
              for (const g of i) {
                if (g.fn === "save") {
                  o.push({
                    fnId: 92,
                    fn: "group",
                    items: []
                  }), b.push(o), o = o.at(-1).items;
                  continue;
                }
                g.fn === "restore" ? o = b.pop() : o.push(g);
              }
              return o;
            }
            function S(i) {
              if (Number.isInteger(i))
                return i.toString();
              const o = i.toFixed(10);
              let b = o.length - 1;
              if (o[b] !== "0")
                return o;
              do
                b--;
              while (o[b] === "0");
              return o.substring(0, o[b] === "." ? b : b + 1);
            }
            function r(i) {
              if (i[4] === 0 && i[5] === 0) {
                if (i[1] === 0 && i[2] === 0)
                  return i[0] === 1 && i[3] === 1 ? "" : `scale(${S(i[0])} ${S(i[3])})`;
                if (i[0] === i[3] && i[1] === -i[2]) {
                  const o = Math.acos(i[0]) * 180 / Math.PI;
                  return `rotate(${S(o)})`;
                }
              } else if (i[0] === 1 && i[1] === 0 && i[2] === 0 && i[3] === 1)
                return `translate(${S(i[4])} ${S(i[5])})`;
              return `matrix(${S(i[0])} ${S(i[1])} ${S(i[2])} ${S(i[3])} ${S(i[4])} ${S(i[5])})`;
            }
            let u = 0, m = 0, s = 0;
            class w {
              constructor(o, b, g = !1) {
                (0, n.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new n.DOMSVGFactory(), this.current = new B(), this.transformMatrix = t.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = o, this.objs = b, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!g, this._operatorIdMapping = [];
                for (const c in t.OPS)
                  this._operatorIdMapping[t.OPS[c]] = c;
              }
              getObject(o, b = null) {
                return typeof o == "string" ? o.startsWith("g_") ? this.commonObjs.get(o) : this.objs.get(o) : b;
              }
              save() {
                this.transformStack.push(this.transformMatrix);
                const o = this.current;
                this.extraStack.push(o), this.current = o.clone();
              }
              restore() {
                this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null;
              }
              group(o) {
                this.save(), this.executeOpTree(o), this.restore();
              }
              loadDependencies(o) {
                const b = o.fnArray, g = o.argsArray;
                for (let c = 0, v = b.length; c < v; c++)
                  if (b[c] === t.OPS.dependency)
                    for (const k of g[c]) {
                      const a = k.startsWith("g_") ? this.commonObjs : this.objs, f = new Promise((C) => {
                        a.get(k, C);
                      });
                      this.current.dependencies.push(f);
                    }
                return Promise.all(this.current.dependencies);
              }
              transform(o, b, g, c, v, k) {
                const a = [o, b, g, c, v, k];
                this.transformMatrix = t.Util.transform(this.transformMatrix, a), this.tgrp = null;
              }
              getSVG(o, b) {
                this.viewport = b;
                const g = this._initialize(b);
                return this.loadDependencies(o).then(() => (this.transformMatrix = t.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(o)), g));
              }
              convertOpList(o) {
                const b = this._operatorIdMapping, g = o.argsArray, c = o.fnArray, v = [];
                for (let k = 0, a = c.length; k < a; k++) {
                  const f = c[k];
                  v.push({
                    fnId: f,
                    fn: b[f],
                    args: g[k]
                  });
                }
                return P(v);
              }
              executeOpTree(o) {
                for (const b of o) {
                  const g = b.fn, c = b.fnId, v = b.args;
                  switch (c | 0) {
                    case t.OPS.beginText:
                      this.beginText();
                      break;
                    case t.OPS.dependency:
                      break;
                    case t.OPS.setLeading:
                      this.setLeading(v);
                      break;
                    case t.OPS.setLeadingMoveText:
                      this.setLeadingMoveText(v[0], v[1]);
                      break;
                    case t.OPS.setFont:
                      this.setFont(v);
                      break;
                    case t.OPS.showText:
                      this.showText(v[0]);
                      break;
                    case t.OPS.showSpacedText:
                      this.showText(v[0]);
                      break;
                    case t.OPS.endText:
                      this.endText();
                      break;
                    case t.OPS.moveText:
                      this.moveText(v[0], v[1]);
                      break;
                    case t.OPS.setCharSpacing:
                      this.setCharSpacing(v[0]);
                      break;
                    case t.OPS.setWordSpacing:
                      this.setWordSpacing(v[0]);
                      break;
                    case t.OPS.setHScale:
                      this.setHScale(v[0]);
                      break;
                    case t.OPS.setTextMatrix:
                      this.setTextMatrix(v[0], v[1], v[2], v[3], v[4], v[5]);
                      break;
                    case t.OPS.setTextRise:
                      this.setTextRise(v[0]);
                      break;
                    case t.OPS.setTextRenderingMode:
                      this.setTextRenderingMode(v[0]);
                      break;
                    case t.OPS.setLineWidth:
                      this.setLineWidth(v[0]);
                      break;
                    case t.OPS.setLineJoin:
                      this.setLineJoin(v[0]);
                      break;
                    case t.OPS.setLineCap:
                      this.setLineCap(v[0]);
                      break;
                    case t.OPS.setMiterLimit:
                      this.setMiterLimit(v[0]);
                      break;
                    case t.OPS.setFillRGBColor:
                      this.setFillRGBColor(v[0], v[1], v[2]);
                      break;
                    case t.OPS.setStrokeRGBColor:
                      this.setStrokeRGBColor(v[0], v[1], v[2]);
                      break;
                    case t.OPS.setStrokeColorN:
                      this.setStrokeColorN(v);
                      break;
                    case t.OPS.setFillColorN:
                      this.setFillColorN(v);
                      break;
                    case t.OPS.shadingFill:
                      this.shadingFill(v[0]);
                      break;
                    case t.OPS.setDash:
                      this.setDash(v[0], v[1]);
                      break;
                    case t.OPS.setRenderingIntent:
                      this.setRenderingIntent(v[0]);
                      break;
                    case t.OPS.setFlatness:
                      this.setFlatness(v[0]);
                      break;
                    case t.OPS.setGState:
                      this.setGState(v[0]);
                      break;
                    case t.OPS.fill:
                      this.fill();
                      break;
                    case t.OPS.eoFill:
                      this.eoFill();
                      break;
                    case t.OPS.stroke:
                      this.stroke();
                      break;
                    case t.OPS.fillStroke:
                      this.fillStroke();
                      break;
                    case t.OPS.eoFillStroke:
                      this.eoFillStroke();
                      break;
                    case t.OPS.clip:
                      this.clip("nonzero");
                      break;
                    case t.OPS.eoClip:
                      this.clip("evenodd");
                      break;
                    case t.OPS.paintSolidColorImageMask:
                      this.paintSolidColorImageMask();
                      break;
                    case t.OPS.paintImageXObject:
                      this.paintImageXObject(v[0]);
                      break;
                    case t.OPS.paintInlineImageXObject:
                      this.paintInlineImageXObject(v[0]);
                      break;
                    case t.OPS.paintImageMaskXObject:
                      this.paintImageMaskXObject(v[0]);
                      break;
                    case t.OPS.paintFormXObjectBegin:
                      this.paintFormXObjectBegin(v[0], v[1]);
                      break;
                    case t.OPS.paintFormXObjectEnd:
                      this.paintFormXObjectEnd();
                      break;
                    case t.OPS.closePath:
                      this.closePath();
                      break;
                    case t.OPS.closeStroke:
                      this.closeStroke();
                      break;
                    case t.OPS.closeFillStroke:
                      this.closeFillStroke();
                      break;
                    case t.OPS.closeEOFillStroke:
                      this.closeEOFillStroke();
                      break;
                    case t.OPS.nextLine:
                      this.nextLine();
                      break;
                    case t.OPS.transform:
                      this.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
                      break;
                    case t.OPS.constructPath:
                      this.constructPath(v[0], v[1]);
                      break;
                    case t.OPS.endPath:
                      this.endPath();
                      break;
                    case 92:
                      this.group(b.items);
                      break;
                    default:
                      (0, t.warn)(`Unimplemented operator ${g}`);
                      break;
                  }
                }
              }
              setWordSpacing(o) {
                this.current.wordSpacing = o;
              }
              setCharSpacing(o) {
                this.current.charSpacing = o;
              }
              nextLine() {
                this.moveText(0, this.current.leading);
              }
              setTextMatrix(o, b, g, c, v, k) {
                const a = this.current;
                a.textMatrix = a.lineMatrix = [o, b, g, c, v, k], a.textMatrixScale = Math.hypot(o, b), a.x = a.lineX = 0, a.y = a.lineY = 0, a.xcoords = [], a.ycoords = [], a.tspan = this.svgFactory.createElement("svg:tspan"), a.tspan.setAttributeNS(null, "font-family", a.fontFamily), a.tspan.setAttributeNS(null, "font-size", `${S(a.fontSize)}px`), a.tspan.setAttributeNS(null, "y", S(-a.y)), a.txtElement = this.svgFactory.createElement("svg:text"), a.txtElement.append(a.tspan);
              }
              beginText() {
                const o = this.current;
                o.x = o.lineX = 0, o.y = o.lineY = 0, o.textMatrix = t.IDENTITY_MATRIX, o.lineMatrix = t.IDENTITY_MATRIX, o.textMatrixScale = 1, o.tspan = this.svgFactory.createElement("svg:tspan"), o.txtElement = this.svgFactory.createElement("svg:text"), o.txtgrp = this.svgFactory.createElement("svg:g"), o.xcoords = [], o.ycoords = [];
              }
              moveText(o, b) {
                const g = this.current;
                g.x = g.lineX += o, g.y = g.lineY += b, g.xcoords = [], g.ycoords = [], g.tspan = this.svgFactory.createElement("svg:tspan"), g.tspan.setAttributeNS(null, "font-family", g.fontFamily), g.tspan.setAttributeNS(null, "font-size", `${S(g.fontSize)}px`), g.tspan.setAttributeNS(null, "y", S(-g.y));
              }
              showText(o) {
                const b = this.current, g = b.font, c = b.fontSize;
                if (c === 0)
                  return;
                const v = b.fontSizeScale, k = b.charSpacing, a = b.wordSpacing, f = b.fontDirection, C = b.textHScale * f, R = g.vertical, M = R ? 1 : -1, I = g.defaultVMetrics, E = c * b.fontMatrix[0];
                let T = 0;
                for (const j of o) {
                  if (j === null) {
                    T += f * a;
                    continue;
                  } else if (typeof j == "number") {
                    T += M * j * c / 1e3;
                    continue;
                  }
                  const A = (j.isSpace ? a : 0) + k, d = j.fontChar;
                  let _, F, U = j.width;
                  if (R) {
                    let $;
                    const re = j.vmetric || I;
                    $ = j.vmetric ? re[1] : U * 0.5, $ = -$ * E;
                    const ge = re[2] * E;
                    U = re ? -re[0] : U, _ = $ / v, F = (T + ge) / v;
                  } else
                    _ = T / v, F = 0;
                  (j.isInFont || g.missingFile) && (b.xcoords.push(b.x + _), R && b.ycoords.push(-b.y + F), b.tspan.textContent += d);
                  const V = R ? U * E - A * f : U * E + A * f;
                  T += V;
                }
                b.tspan.setAttributeNS(null, "x", b.xcoords.map(S).join(" ")), R ? b.tspan.setAttributeNS(null, "y", b.ycoords.map(S).join(" ")) : b.tspan.setAttributeNS(null, "y", S(-b.y)), R ? b.y -= T : b.x += T * C, b.tspan.setAttributeNS(null, "font-family", b.fontFamily), b.tspan.setAttributeNS(null, "font-size", `${S(b.fontSize)}px`), b.fontStyle !== l.fontStyle && b.tspan.setAttributeNS(null, "font-style", b.fontStyle), b.fontWeight !== l.fontWeight && b.tspan.setAttributeNS(null, "font-weight", b.fontWeight);
                const y = b.textRenderingMode & t.TextRenderingMode.FILL_STROKE_MASK;
                if (y === t.TextRenderingMode.FILL || y === t.TextRenderingMode.FILL_STROKE ? (b.fillColor !== l.fillColor && b.tspan.setAttributeNS(null, "fill", b.fillColor), b.fillAlpha < 1 && b.tspan.setAttributeNS(null, "fill-opacity", b.fillAlpha)) : b.textRenderingMode === t.TextRenderingMode.ADD_TO_PATH ? b.tspan.setAttributeNS(null, "fill", "transparent") : b.tspan.setAttributeNS(null, "fill", "none"), y === t.TextRenderingMode.STROKE || y === t.TextRenderingMode.FILL_STROKE) {
                  const j = 1 / (b.textMatrixScale || 1);
                  this._setStrokeAttributes(b.tspan, j);
                }
                let D = b.textMatrix;
                b.textRise !== 0 && (D = D.slice(), D[5] += b.textRise), b.txtElement.setAttributeNS(null, "transform", `${r(D)} scale(${S(C)}, -1)`), b.txtElement.setAttributeNS(W, "xml:space", "preserve"), b.txtElement.append(b.tspan), b.txtgrp.append(b.txtElement), this._ensureTransformGroup().append(b.txtElement);
              }
              setLeadingMoveText(o, b) {
                this.setLeading(-b), this.moveText(o, b);
              }
              addFontStyle(o) {
                if (!o.data)
                  throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.append(this.cssStyle));
                const b = N(o.data, o.mimetype, this.forceDataSchema);
                this.cssStyle.textContent += `@font-face { font-family: "${o.loadedName}"; src: url(${b}); }
`;
              }
              setFont(o) {
                const b = this.current, g = this.commonObjs.get(o[0]);
                let c = o[1];
                b.font = g, this.embedFonts && !g.missingFile && !this.embeddedFonts[g.loadedName] && (this.addFontStyle(g), this.embeddedFonts[g.loadedName] = g), b.fontMatrix = g.fontMatrix || t.FONT_IDENTITY_MATRIX;
                let v = "normal";
                g.black ? v = "900" : g.bold && (v = "bold");
                const k = g.italic ? "italic" : "normal";
                c < 0 ? (c = -c, b.fontDirection = -1) : b.fontDirection = 1, b.fontSize = c, b.fontFamily = g.loadedName, b.fontWeight = v, b.fontStyle = k, b.tspan = this.svgFactory.createElement("svg:tspan"), b.tspan.setAttributeNS(null, "y", S(-b.y)), b.xcoords = [], b.ycoords = [];
              }
              endText() {
                var b;
                const o = this.current;
                o.textRenderingMode & t.TextRenderingMode.ADD_TO_PATH_FLAG && ((b = o.txtElement) != null && b.hasChildNodes()) && (o.element = o.txtElement, this.clip("nonzero"), this.endPath());
              }
              setLineWidth(o) {
                o > 0 && (this.current.lineWidth = o);
              }
              setLineCap(o) {
                this.current.lineCap = G[o];
              }
              setLineJoin(o) {
                this.current.lineJoin = X[o];
              }
              setMiterLimit(o) {
                this.current.miterLimit = o;
              }
              setStrokeAlpha(o) {
                this.current.strokeAlpha = o;
              }
              setStrokeRGBColor(o, b, g) {
                this.current.strokeColor = t.Util.makeHexColor(o, b, g);
              }
              setFillAlpha(o) {
                this.current.fillAlpha = o;
              }
              setFillRGBColor(o, b, g) {
                this.current.fillColor = t.Util.makeHexColor(o, b, g), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
              }
              setStrokeColorN(o) {
                this.current.strokeColor = this._makeColorN_Pattern(o);
              }
              setFillColorN(o) {
                this.current.fillColor = this._makeColorN_Pattern(o);
              }
              shadingFill(o) {
                const {
                  width: b,
                  height: g
                } = this.viewport, c = t.Util.inverseTransform(this.transformMatrix), [v, k, a, f] = t.Util.getAxialAlignedBoundingBox([0, 0, b, g], c), C = this.svgFactory.createElement("svg:rect");
                C.setAttributeNS(null, "x", v), C.setAttributeNS(null, "y", k), C.setAttributeNS(null, "width", a - v), C.setAttributeNS(null, "height", f - k), C.setAttributeNS(null, "fill", this._makeShadingPattern(o)), this.current.fillAlpha < 1 && C.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(C);
              }
              _makeColorN_Pattern(o) {
                return o[0] === "TilingPattern" ? this._makeTilingPattern(o) : this._makeShadingPattern(o);
              }
              _makeTilingPattern(o) {
                const b = o[1], g = o[2], c = o[3] || t.IDENTITY_MATRIX, [v, k, a, f] = o[4], C = o[5], R = o[6], M = o[7], I = `shading${s++}`, [E, T, y, D] = t.Util.normalizeRect([...t.Util.applyTransform([v, k], c), ...t.Util.applyTransform([a, f], c)]), [j, A] = t.Util.singularValueDecompose2dScale(c), d = C * j, _ = R * A, F = this.svgFactory.createElement("svg:pattern");
                F.setAttributeNS(null, "id", I), F.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), F.setAttributeNS(null, "width", d), F.setAttributeNS(null, "height", _), F.setAttributeNS(null, "x", `${E}`), F.setAttributeNS(null, "y", `${T}`);
                const U = this.svg, V = this.transformMatrix, $ = this.current.fillColor, re = this.current.strokeColor, ge = this.svgFactory.create(y - E, D - T);
                if (this.svg = ge, this.transformMatrix = c, M === 2) {
                  const be = t.Util.makeHexColor(...b);
                  this.current.fillColor = be, this.current.strokeColor = be;
                }
                return this.executeOpTree(this.convertOpList(g)), this.svg = U, this.transformMatrix = V, this.current.fillColor = $, this.current.strokeColor = re, F.append(ge.childNodes[0]), this.defs.append(F), `url(#${I})`;
              }
              _makeShadingPattern(o) {
                switch (typeof o == "string" && (o = this.objs.get(o)), o[0]) {
                  case "RadialAxial":
                    const b = `shading${s++}`, g = o[3];
                    let c;
                    switch (o[1]) {
                      case "axial":
                        const v = o[4], k = o[5];
                        c = this.svgFactory.createElement("svg:linearGradient"), c.setAttributeNS(null, "id", b), c.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), c.setAttributeNS(null, "x1", v[0]), c.setAttributeNS(null, "y1", v[1]), c.setAttributeNS(null, "x2", k[0]), c.setAttributeNS(null, "y2", k[1]);
                        break;
                      case "radial":
                        const a = o[4], f = o[5], C = o[6], R = o[7];
                        c = this.svgFactory.createElement("svg:radialGradient"), c.setAttributeNS(null, "id", b), c.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), c.setAttributeNS(null, "cx", f[0]), c.setAttributeNS(null, "cy", f[1]), c.setAttributeNS(null, "r", R), c.setAttributeNS(null, "fx", a[0]), c.setAttributeNS(null, "fy", a[1]), c.setAttributeNS(null, "fr", C);
                        break;
                      default:
                        throw new Error(`Unknown RadialAxial type: ${o[1]}`);
                    }
                    for (const v of g) {
                      const k = this.svgFactory.createElement("svg:stop");
                      k.setAttributeNS(null, "offset", v[0]), k.setAttributeNS(null, "stop-color", v[1]), c.append(k);
                    }
                    return this.defs.append(c), `url(#${b})`;
                  case "Mesh":
                    return (0, t.warn)("Unimplemented pattern Mesh"), null;
                  case "Dummy":
                    return "hotpink";
                  default:
                    throw new Error(`Unknown IR type: ${o[0]}`);
                }
              }
              setDash(o, b) {
                this.current.dashArray = o, this.current.dashPhase = b;
              }
              constructPath(o, b) {
                const g = this.current;
                let c = g.x, v = g.y, k = [], a = 0;
                for (const f of o)
                  switch (f | 0) {
                    case t.OPS.rectangle:
                      c = b[a++], v = b[a++];
                      const C = b[a++], R = b[a++], M = c + C, I = v + R;
                      k.push("M", S(c), S(v), "L", S(M), S(v), "L", S(M), S(I), "L", S(c), S(I), "Z");
                      break;
                    case t.OPS.moveTo:
                      c = b[a++], v = b[a++], k.push("M", S(c), S(v));
                      break;
                    case t.OPS.lineTo:
                      c = b[a++], v = b[a++], k.push("L", S(c), S(v));
                      break;
                    case t.OPS.curveTo:
                      c = b[a + 4], v = b[a + 5], k.push("C", S(b[a]), S(b[a + 1]), S(b[a + 2]), S(b[a + 3]), S(c), S(v)), a += 6;
                      break;
                    case t.OPS.curveTo2:
                      k.push("C", S(c), S(v), S(b[a]), S(b[a + 1]), S(b[a + 2]), S(b[a + 3])), c = b[a + 2], v = b[a + 3], a += 4;
                      break;
                    case t.OPS.curveTo3:
                      c = b[a + 2], v = b[a + 3], k.push("C", S(b[a]), S(b[a + 1]), S(c), S(v), S(c), S(v)), a += 4;
                      break;
                    case t.OPS.closePath:
                      k.push("Z");
                      break;
                  }
                k = k.join(" "), g.path && o.length > 0 && o[0] !== t.OPS.rectangle && o[0] !== t.OPS.moveTo ? k = g.path.getAttributeNS(null, "d") + k : (g.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append(g.path)), g.path.setAttributeNS(null, "d", k), g.path.setAttributeNS(null, "fill", "none"), g.element = g.path, g.setCurrentPoint(c, v);
              }
              endPath() {
                const o = this.current;
                if (o.path = null, !this.pendingClip)
                  return;
                if (!o.element) {
                  this.pendingClip = null;
                  return;
                }
                const b = `clippath${u++}`, g = this.svgFactory.createElement("svg:clipPath");
                g.setAttributeNS(null, "id", b), g.setAttributeNS(null, "transform", r(this.transformMatrix));
                const c = o.element.cloneNode(!0);
                if (this.pendingClip === "evenodd" ? c.setAttributeNS(null, "clip-rule", "evenodd") : c.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, g.append(c), this.defs.append(g), o.activeClipUrl) {
                  o.clipGroup = null;
                  for (const v of this.extraStack)
                    v.clipGroup = null;
                  g.setAttributeNS(null, "clip-path", o.activeClipUrl);
                }
                o.activeClipUrl = `url(#${b})`, this.tgrp = null;
              }
              clip(o) {
                this.pendingClip = o;
              }
              closePath() {
                const o = this.current;
                if (o.path) {
                  const b = `${o.path.getAttributeNS(null, "d")}Z`;
                  o.path.setAttributeNS(null, "d", b);
                }
              }
              setLeading(o) {
                this.current.leading = -o;
              }
              setTextRise(o) {
                this.current.textRise = o;
              }
              setTextRenderingMode(o) {
                this.current.textRenderingMode = o;
              }
              setHScale(o) {
                this.current.textHScale = o / 100;
              }
              setRenderingIntent(o) {
              }
              setFlatness(o) {
              }
              setGState(o) {
                for (const [b, g] of o)
                  switch (b) {
                    case "LW":
                      this.setLineWidth(g);
                      break;
                    case "LC":
                      this.setLineCap(g);
                      break;
                    case "LJ":
                      this.setLineJoin(g);
                      break;
                    case "ML":
                      this.setMiterLimit(g);
                      break;
                    case "D":
                      this.setDash(g[0], g[1]);
                      break;
                    case "RI":
                      this.setRenderingIntent(g);
                      break;
                    case "FL":
                      this.setFlatness(g);
                      break;
                    case "Font":
                      this.setFont(g);
                      break;
                    case "CA":
                      this.setStrokeAlpha(g);
                      break;
                    case "ca":
                      this.setFillAlpha(g);
                      break;
                    default:
                      (0, t.warn)(`Unimplemented graphic state operator ${b}`);
                      break;
                  }
              }
              fill() {
                const o = this.current;
                o.element && (o.element.setAttributeNS(null, "fill", o.fillColor), o.element.setAttributeNS(null, "fill-opacity", o.fillAlpha), this.endPath());
              }
              stroke() {
                const o = this.current;
                o.element && (this._setStrokeAttributes(o.element), o.element.setAttributeNS(null, "fill", "none"), this.endPath());
              }
              _setStrokeAttributes(o, b = 1) {
                const g = this.current;
                let c = g.dashArray;
                b !== 1 && c.length > 0 && (c = c.map(function(v) {
                  return b * v;
                })), o.setAttributeNS(null, "stroke", g.strokeColor), o.setAttributeNS(null, "stroke-opacity", g.strokeAlpha), o.setAttributeNS(null, "stroke-miterlimit", S(g.miterLimit)), o.setAttributeNS(null, "stroke-linecap", g.lineCap), o.setAttributeNS(null, "stroke-linejoin", g.lineJoin), o.setAttributeNS(null, "stroke-width", S(b * g.lineWidth) + "px"), o.setAttributeNS(null, "stroke-dasharray", c.map(S).join(" ")), o.setAttributeNS(null, "stroke-dashoffset", S(b * g.dashPhase) + "px");
              }
              eoFill() {
                var o;
                (o = this.current.element) == null || o.setAttributeNS(null, "fill-rule", "evenodd"), this.fill();
              }
              fillStroke() {
                this.stroke(), this.fill();
              }
              eoFillStroke() {
                var o;
                (o = this.current.element) == null || o.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke();
              }
              closeStroke() {
                this.closePath(), this.stroke();
              }
              closeFillStroke() {
                this.closePath(), this.fillStroke();
              }
              closeEOFillStroke() {
                this.closePath(), this.eoFillStroke();
              }
              paintSolidColorImageMask() {
                const o = this.svgFactory.createElement("svg:rect");
                o.setAttributeNS(null, "x", "0"), o.setAttributeNS(null, "y", "0"), o.setAttributeNS(null, "width", "1px"), o.setAttributeNS(null, "height", "1px"), o.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(o);
              }
              paintImageXObject(o) {
                const b = this.getObject(o);
                if (!b) {
                  (0, t.warn)(`Dependent image with object ID ${o} is not ready yet`);
                  return;
                }
                this.paintInlineImageXObject(b);
              }
              paintInlineImageXObject(o, b) {
                const g = o.width, c = o.height, v = H(o, this.forceDataSchema, !!b), k = this.svgFactory.createElement("svg:rect");
                k.setAttributeNS(null, "x", "0"), k.setAttributeNS(null, "y", "0"), k.setAttributeNS(null, "width", S(g)), k.setAttributeNS(null, "height", S(c)), this.current.element = k, this.clip("nonzero");
                const a = this.svgFactory.createElement("svg:image");
                a.setAttributeNS(Q, "xlink:href", v), a.setAttributeNS(null, "x", "0"), a.setAttributeNS(null, "y", S(-c)), a.setAttributeNS(null, "width", S(g) + "px"), a.setAttributeNS(null, "height", S(c) + "px"), a.setAttributeNS(null, "transform", `scale(${S(1 / g)} ${S(-1 / c)})`), b ? b.append(a) : this._ensureTransformGroup().append(a);
              }
              paintImageMaskXObject(o) {
                const b = this.getObject(o.data, o);
                if (b.bitmap) {
                  (0, t.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");
                  return;
                }
                const g = this.current, c = b.width, v = b.height, k = g.fillColor;
                g.maskId = `mask${m++}`;
                const a = this.svgFactory.createElement("svg:mask");
                a.setAttributeNS(null, "id", g.maskId);
                const f = this.svgFactory.createElement("svg:rect");
                f.setAttributeNS(null, "x", "0"), f.setAttributeNS(null, "y", "0"), f.setAttributeNS(null, "width", S(c)), f.setAttributeNS(null, "height", S(v)), f.setAttributeNS(null, "fill", k), f.setAttributeNS(null, "mask", `url(#${g.maskId})`), this.defs.append(a), this._ensureTransformGroup().append(f), this.paintInlineImageXObject(b, a);
              }
              paintFormXObjectBegin(o, b) {
                if (Array.isArray(o) && o.length === 6 && this.transform(o[0], o[1], o[2], o[3], o[4], o[5]), b) {
                  const g = b[2] - b[0], c = b[3] - b[1], v = this.svgFactory.createElement("svg:rect");
                  v.setAttributeNS(null, "x", b[0]), v.setAttributeNS(null, "y", b[1]), v.setAttributeNS(null, "width", S(g)), v.setAttributeNS(null, "height", S(c)), this.current.element = v, this.clip("nonzero"), this.endPath();
                }
              }
              paintFormXObjectEnd() {
              }
              _initialize(o) {
                const b = this.svgFactory.create(o.width, o.height), g = this.svgFactory.createElement("svg:defs");
                b.append(g), this.defs = g;
                const c = this.svgFactory.createElement("svg:g");
                return c.setAttributeNS(null, "transform", r(o.transform)), b.append(c), this.svg = c, b;
              }
              _ensureClipGroup() {
                if (!this.current.clipGroup) {
                  const o = this.svgFactory.createElement("svg:g");
                  o.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(o), this.current.clipGroup = o;
                }
                return this.current.clipGroup;
              }
              _ensureTransformGroup() {
                return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", r(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)), this.tgrp;
              }
            }
            L.SVGGraphics = w;
          },
          /* 25 */
          /***/
          (e, L) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.XfaText = void 0;
            class p {
              static textContent(t) {
                const l = [], W = {
                  items: l,
                  styles: /* @__PURE__ */ Object.create(null)
                };
                function Q(G) {
                  var H;
                  if (!G)
                    return;
                  let X = null;
                  const N = G.name;
                  if (N === "#text")
                    X = G.value;
                  else if (p.shouldBuildText(N))
                    (H = G == null ? void 0 : G.attributes) != null && H.textContent ? X = G.attributes.textContent : G.value && (X = G.value);
                  else return;
                  if (X !== null && l.push({
                    str: X
                  }), !!G.children)
                    for (const B of G.children)
                      Q(B);
                }
                return Q(t), W;
              }
              static shouldBuildText(t) {
                return !(t === "textarea" || t === "input" || t === "option" || t === "select");
              }
            }
            L.XfaText = p;
          },
          /* 26 */
          /***/
          (e, L, p) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.TextLayerRenderTask = void 0, L.renderTextLayer = r, L.updateTextLayer = u;
            var n = p(1), t = p(6);
            const l = 1e5, W = 30, Q = 0.8, G = /* @__PURE__ */ new Map();
            function X(m, s) {
              let w;
              if (s && n.FeatureTest.isOffscreenCanvasSupported)
                w = new OffscreenCanvas(m, m).getContext("2d", {
                  alpha: !1
                });
              else {
                const i = document.createElement("canvas");
                i.width = i.height = m, w = i.getContext("2d", {
                  alpha: !1
                });
              }
              return w;
            }
            function N(m, s) {
              const w = G.get(m);
              if (w)
                return w;
              const i = X(W, s);
              i.font = `${W}px ${m}`;
              const o = i.measureText("");
              let b = o.fontBoundingBoxAscent, g = Math.abs(o.fontBoundingBoxDescent);
              if (b) {
                const v = b / (b + g);
                return G.set(m, v), i.canvas.width = i.canvas.height = 0, v;
              }
              i.strokeStyle = "red", i.clearRect(0, 0, W, W), i.strokeText("g", 0, 0);
              let c = i.getImageData(0, 0, W, W).data;
              g = 0;
              for (let v = c.length - 1 - 3; v >= 0; v -= 4)
                if (c[v] > 0) {
                  g = Math.ceil(v / 4 / W);
                  break;
                }
              i.clearRect(0, 0, W, W), i.strokeText("A", 0, W), c = i.getImageData(0, 0, W, W).data, b = 0;
              for (let v = 0, k = c.length; v < k; v += 4)
                if (c[v] > 0) {
                  b = W - Math.floor(v / 4 / W);
                  break;
                }
              if (i.canvas.width = i.canvas.height = 0, b) {
                const v = b / (b + g);
                return G.set(m, v), v;
              }
              return G.set(m, Q), Q;
            }
            function H(m, s, w) {
              const i = document.createElement("span"), o = {
                angle: 0,
                canvasWidth: 0,
                hasText: s.str !== "",
                hasEOL: s.hasEOL,
                fontSize: 0
              };
              m._textDivs.push(i);
              const b = n.Util.transform(m._transform, s.transform);
              let g = Math.atan2(b[1], b[0]);
              const c = w[s.fontName];
              c.vertical && (g += Math.PI / 2);
              const v = Math.hypot(b[2], b[3]), k = v * N(c.fontFamily, m._isOffscreenCanvasSupported);
              let a, f;
              g === 0 ? (a = b[4], f = b[5] - k) : (a = b[4] + k * Math.sin(g), f = b[5] - k * Math.cos(g));
              const C = "calc(var(--scale-factor)*", R = i.style;
              m._container === m._rootContainer ? (R.left = `${(100 * a / m._pageWidth).toFixed(2)}%`, R.top = `${(100 * f / m._pageHeight).toFixed(2)}%`) : (R.left = `${C}${a.toFixed(2)}px)`, R.top = `${C}${f.toFixed(2)}px)`), R.fontSize = `${C}${v.toFixed(2)}px)`, R.fontFamily = c.fontFamily, o.fontSize = v, i.setAttribute("role", "presentation"), i.textContent = s.str, i.dir = s.dir, m._fontInspectorEnabled && (i.dataset.fontName = s.fontName), g !== 0 && (o.angle = g * (180 / Math.PI));
              let M = !1;
              if (s.str.length > 1)
                M = !0;
              else if (s.str !== " " && s.transform[0] !== s.transform[3]) {
                const I = Math.abs(s.transform[0]), E = Math.abs(s.transform[3]);
                I !== E && Math.max(I, E) / Math.min(I, E) > 1.5 && (M = !0);
              }
              M && (o.canvasWidth = c.vertical ? s.height : s.width), m._textDivProperties.set(i, o), m._isReadableStream && m._layoutText(i);
            }
            function B(m) {
              const {
                div: s,
                scale: w,
                properties: i,
                ctx: o,
                prevFontSize: b,
                prevFontFamily: g
              } = m, {
                style: c
              } = s;
              let v = "";
              if (i.canvasWidth !== 0 && i.hasText) {
                const {
                  fontFamily: k
                } = c, {
                  canvasWidth: a,
                  fontSize: f
                } = i;
                (b !== f || g !== k) && (o.font = `${f * w}px ${k}`, m.prevFontSize = f, m.prevFontFamily = k);
                const {
                  width: C
                } = o.measureText(s.textContent);
                C > 0 && (v = `scaleX(${a * w / C})`);
              }
              i.angle !== 0 && (v = `rotate(${i.angle}deg) ${v}`), v.length > 0 && (c.transform = v);
            }
            function P(m) {
              if (m._canceled)
                return;
              const s = m._textDivs, w = m._capability;
              if (s.length > l) {
                w.resolve();
                return;
              }
              if (!m._isReadableStream)
                for (const o of s)
                  m._layoutText(o);
              w.resolve();
            }
            class S {
              constructor({
                textContentSource: s,
                container: w,
                viewport: i,
                textDivs: o,
                textDivProperties: b,
                textContentItemsStr: g,
                isOffscreenCanvasSupported: c
              }) {
                var C;
                this._textContentSource = s, this._isReadableStream = s instanceof ReadableStream, this._container = this._rootContainer = w, this._textDivs = o || [], this._textContentItemsStr = g || [], this._isOffscreenCanvasSupported = c, this._fontInspectorEnabled = !!((C = globalThis.FontInspector) != null && C.enabled), this._reader = null, this._textDivProperties = b || /* @__PURE__ */ new WeakMap(), this._canceled = !1, this._capability = new n.PromiseCapability(), this._layoutTextParams = {
                  prevFontSize: null,
                  prevFontFamily: null,
                  div: null,
                  scale: i.scale * (globalThis.devicePixelRatio || 1),
                  properties: null,
                  ctx: X(0, c)
                };
                const {
                  pageWidth: v,
                  pageHeight: k,
                  pageX: a,
                  pageY: f
                } = i.rawDims;
                this._transform = [1, 0, 0, -1, -a, f + k], this._pageWidth = v, this._pageHeight = k, (0, t.setLayerDimensions)(w, i), this._capability.promise.finally(() => {
                  this._layoutTextParams = null;
                }).catch(() => {
                });
              }
              get promise() {
                return this._capability.promise;
              }
              cancel() {
                this._canceled = !0, this._reader && (this._reader.cancel(new n.AbortException("TextLayer task cancelled.")).catch(() => {
                }), this._reader = null), this._capability.reject(new n.AbortException("TextLayer task cancelled."));
              }
              _processItems(s, w) {
                for (const i of s) {
                  if (i.str === void 0) {
                    if (i.type === "beginMarkedContentProps" || i.type === "beginMarkedContent") {
                      const o = this._container;
                      this._container = document.createElement("span"), this._container.classList.add("markedContent"), i.id !== null && this._container.setAttribute("id", `${i.id}`), o.append(this._container);
                    } else i.type === "endMarkedContent" && (this._container = this._container.parentNode);
                    continue;
                  }
                  this._textContentItemsStr.push(i.str), H(this, i, w);
                }
              }
              _layoutText(s) {
                const w = this._layoutTextParams.properties = this._textDivProperties.get(s);
                if (this._layoutTextParams.div = s, B(this._layoutTextParams), w.hasText && this._container.append(s), w.hasEOL) {
                  const i = document.createElement("br");
                  i.setAttribute("role", "presentation"), this._container.append(i);
                }
              }
              _render() {
                const s = new n.PromiseCapability();
                let w = /* @__PURE__ */ Object.create(null);
                if (this._isReadableStream) {
                  const i = () => {
                    this._reader.read().then(({
                      value: o,
                      done: b
                    }) => {
                      if (b) {
                        s.resolve();
                        return;
                      }
                      Object.assign(w, o.styles), this._processItems(o.items, w), i();
                    }, s.reject);
                  };
                  this._reader = this._textContentSource.getReader(), i();
                } else if (this._textContentSource) {
                  const {
                    items: i,
                    styles: o
                  } = this._textContentSource;
                  this._processItems(i, o), s.resolve();
                } else
                  throw new Error('No "textContentSource" parameter specified.');
                s.promise.then(() => {
                  w = null, P(this);
                }, this._capability.reject);
              }
            }
            L.TextLayerRenderTask = S;
            function r(m) {
              !m.textContentSource && (m.textContent || m.textContentStream) && ((0, t.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead."), m.textContentSource = m.textContent || m.textContentStream);
              const {
                container: s,
                viewport: w
              } = m, i = getComputedStyle(s), o = i.getPropertyValue("visibility"), b = parseFloat(i.getPropertyValue("--scale-factor"));
              o === "visible" && (!b || Math.abs(b - w.scale) > 1e-5) && console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");
              const g = new S(m);
              return g._render(), g;
            }
            function u({
              container: m,
              viewport: s,
              textDivs: w,
              textDivProperties: i,
              isOffscreenCanvasSupported: o,
              mustRotate: b = !0,
              mustRescale: g = !0
            }) {
              if (b && (0, t.setLayerDimensions)(m, {
                rotation: s.rotation
              }), g) {
                const c = X(0, o), k = {
                  prevFontSize: null,
                  prevFontFamily: null,
                  div: null,
                  scale: s.scale * (globalThis.devicePixelRatio || 1),
                  properties: null,
                  ctx: c
                };
                for (const a of w)
                  k.properties = i.get(a), k.div = a, B(k);
              }
            }
          },
          /* 27 */
          /***/
          (e, L, p) => {
            var N, H, B, P, S, r, u, m, s, w, i, _i, Sa, Si, yi;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.AnnotationEditorLayer = void 0;
            var n = p(1), t = p(4), l = p(28), W = p(33), Q = p(6), G = p(34);
            const v = class v {
              constructor({
                uiManager: a,
                pageIndex: f,
                div: C,
                accessibilityManager: R,
                annotationLayer: M,
                viewport: I,
                l10n: E
              }) {
                Ne(this, i);
                Ne(this, N);
                Ne(this, H, !1);
                Ne(this, B, null);
                Ne(this, P, this.pointerup.bind(this));
                Ne(this, S, this.pointerdown.bind(this));
                Ne(this, r, /* @__PURE__ */ new Map());
                Ne(this, u, !1);
                Ne(this, m, !1);
                Ne(this, s, !1);
                Ne(this, w);
                const T = [l.FreeTextEditor, W.InkEditor, G.StampEditor];
                if (!v._initialized) {
                  v._initialized = !0;
                  for (const y of T)
                    y.initialize(E);
                }
                a.registerEditorTypes(T), je(this, w, a), this.pageIndex = f, this.div = C, je(this, N, R), je(this, B, M), this.viewport = I, x(this, w).addLayer(this);
              }
              get isEmpty() {
                return x(this, r).size === 0;
              }
              updateToolbar(a) {
                x(this, w).updateToolbar(a);
              }
              updateMode(a = x(this, w).getMode()) {
                Te(this, i, yi).call(this), a === n.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), a !== n.AnnotationEditorType.NONE && (this.div.classList.toggle("freeTextEditing", a === n.AnnotationEditorType.FREETEXT), this.div.classList.toggle("inkEditing", a === n.AnnotationEditorType.INK), this.div.classList.toggle("stampEditing", a === n.AnnotationEditorType.STAMP), this.div.hidden = !1);
              }
              addInkEditorIfNeeded(a) {
                if (!a && x(this, w).getMode() !== n.AnnotationEditorType.INK)
                  return;
                if (!a) {
                  for (const C of x(this, r).values())
                    if (C.isEmpty()) {
                      C.setInBackground();
                      return;
                    }
                }
                Te(this, i, Sa).call(this, {
                  offsetX: 0,
                  offsetY: 0
                }, !1).setInBackground();
              }
              setEditingState(a) {
                x(this, w).setEditingState(a);
              }
              addCommands(a) {
                x(this, w).addCommands(a);
              }
              enable() {
                this.div.style.pointerEvents = "auto";
                const a = /* @__PURE__ */ new Set();
                for (const C of x(this, r).values())
                  C.enableEditing(), C.annotationElementId && a.add(C.annotationElementId);
                if (!x(this, B))
                  return;
                const f = x(this, B).getEditableAnnotations();
                for (const C of f) {
                  if (C.hide(), x(this, w).isDeletedAnnotationElement(C.data.id) || a.has(C.data.id))
                    continue;
                  const R = this.deserialize(C);
                  R && (this.addOrRebuild(R), R.enableEditing());
                }
              }
              disable() {
                var f;
                je(this, s, !0), this.div.style.pointerEvents = "none";
                const a = /* @__PURE__ */ new Set();
                for (const C of x(this, r).values()) {
                  if (C.disableEditing(), !C.annotationElementId || C.serialize() !== null) {
                    a.add(C.annotationElementId);
                    continue;
                  }
                  (f = this.getEditableAnnotation(C.annotationElementId)) == null || f.show(), C.remove();
                }
                if (x(this, B)) {
                  const C = x(this, B).getEditableAnnotations();
                  for (const R of C) {
                    const {
                      id: M
                    } = R.data;
                    a.has(M) || x(this, w).isDeletedAnnotationElement(M) || R.show();
                  }
                }
                Te(this, i, yi).call(this), this.isEmpty && (this.div.hidden = !0), je(this, s, !1);
              }
              getEditableAnnotation(a) {
                var f;
                return ((f = x(this, B)) == null ? void 0 : f.getEditableAnnotation(a)) || null;
              }
              setActiveEditor(a) {
                x(this, w).getActive() !== a && x(this, w).setActiveEditor(a);
              }
              enableClick() {
                this.div.addEventListener("pointerdown", x(this, S)), this.div.addEventListener("pointerup", x(this, P));
              }
              disableClick() {
                this.div.removeEventListener("pointerdown", x(this, S)), this.div.removeEventListener("pointerup", x(this, P));
              }
              attach(a) {
                x(this, r).set(a.id, a);
                const {
                  annotationElementId: f
                } = a;
                f && x(this, w).isDeletedAnnotationElement(f) && x(this, w).removeDeletedAnnotationElement(a);
              }
              detach(a) {
                var f;
                x(this, r).delete(a.id), (f = x(this, N)) == null || f.removePointerInTextLayer(a.contentDiv), !x(this, s) && a.annotationElementId && x(this, w).addDeletedAnnotationElement(a);
              }
              remove(a) {
                this.detach(a), x(this, w).removeEditor(a), a.div.contains(document.activeElement) && setTimeout(() => {
                  x(this, w).focusMainContainer();
                }, 0), a.div.remove(), a.isAttachedToDOM = !1, x(this, m) || this.addInkEditorIfNeeded(!1);
              }
              changeParent(a) {
                var f;
                a.parent !== this && (a.annotationElementId && (x(this, w).addDeletedAnnotationElement(a.annotationElementId), t.AnnotationEditor.deleteAnnotationElement(a), a.annotationElementId = null), this.attach(a), (f = a.parent) == null || f.detach(a), a.setParent(this), a.div && a.isAttachedToDOM && (a.div.remove(), this.div.append(a.div)));
              }
              add(a) {
                if (this.changeParent(a), x(this, w).addEditor(a), this.attach(a), !a.isAttachedToDOM) {
                  const f = a.render();
                  this.div.append(f), a.isAttachedToDOM = !0;
                }
                a.fixAndSetPosition(), a.onceAdded(), x(this, w).addToAnnotationStorage(a);
              }
              moveEditorInDOM(a) {
                var C;
                if (!a.isAttachedToDOM)
                  return;
                const {
                  activeElement: f
                } = document;
                a.div.contains(f) && (a._focusEventsAllowed = !1, setTimeout(() => {
                  a.div.contains(document.activeElement) ? a._focusEventsAllowed = !0 : (a.div.addEventListener("focusin", () => {
                    a._focusEventsAllowed = !0;
                  }, {
                    once: !0
                  }), f.focus());
                }, 0)), a._structTreeParentId = (C = x(this, N)) == null ? void 0 : C.moveElementInDOM(this.div, a.div, a.contentDiv, !0);
              }
              addOrRebuild(a) {
                a.needsToBeRebuilt() ? a.rebuild() : this.add(a);
              }
              addUndoableEditor(a) {
                const f = () => a._uiManager.rebuild(a), C = () => {
                  a.remove();
                };
                this.addCommands({
                  cmd: f,
                  undo: C,
                  mustExec: !1
                });
              }
              getNextId() {
                return x(this, w).getId();
              }
              pasteEditor(a, f) {
                x(this, w).updateToolbar(a), x(this, w).updateMode(a);
                const {
                  offsetX: C,
                  offsetY: R
                } = Te(this, i, Si).call(this), M = this.getNextId(), I = Te(this, i, _i).call(this, {
                  parent: this,
                  id: M,
                  x: C,
                  y: R,
                  uiManager: x(this, w),
                  isCentered: !0,
                  ...f
                });
                I && this.add(I);
              }
              deserialize(a) {
                switch (a.annotationType ?? a.annotationEditorType) {
                  case n.AnnotationEditorType.FREETEXT:
                    return l.FreeTextEditor.deserialize(a, this, x(this, w));
                  case n.AnnotationEditorType.INK:
                    return W.InkEditor.deserialize(a, this, x(this, w));
                  case n.AnnotationEditorType.STAMP:
                    return G.StampEditor.deserialize(a, this, x(this, w));
                }
                return null;
              }
              addNewEditor() {
                Te(this, i, Sa).call(this, Te(this, i, Si).call(this), !0);
              }
              setSelected(a) {
                x(this, w).setSelected(a);
              }
              toggleSelected(a) {
                x(this, w).toggleSelected(a);
              }
              isSelected(a) {
                return x(this, w).isSelected(a);
              }
              unselect(a) {
                x(this, w).unselect(a);
              }
              pointerup(a) {
                const {
                  isMac: f
                } = n.FeatureTest.platform;
                if (!(a.button !== 0 || a.ctrlKey && f) && a.target === this.div && x(this, u)) {
                  if (je(this, u, !1), !x(this, H)) {
                    je(this, H, !0);
                    return;
                  }
                  if (x(this, w).getMode() === n.AnnotationEditorType.STAMP) {
                    x(this, w).unselectAll();
                    return;
                  }
                  Te(this, i, Sa).call(this, a, !1);
                }
              }
              pointerdown(a) {
                if (x(this, u)) {
                  je(this, u, !1);
                  return;
                }
                const {
                  isMac: f
                } = n.FeatureTest.platform;
                if (a.button !== 0 || a.ctrlKey && f || a.target !== this.div)
                  return;
                je(this, u, !0);
                const C = x(this, w).getActive();
                je(this, H, !C || C.isEmpty());
              }
              findNewParent(a, f, C) {
                const R = x(this, w).findParent(f, C);
                return R === null || R === this ? !1 : (R.changeParent(a), !0);
              }
              destroy() {
                var a, f;
                ((a = x(this, w).getActive()) == null ? void 0 : a.parent) === this && (x(this, w).commitOrRemove(), x(this, w).setActiveEditor(null));
                for (const C of x(this, r).values())
                  (f = x(this, N)) == null || f.removePointerInTextLayer(C.contentDiv), C.setParent(null), C.isAttachedToDOM = !1, C.div.remove();
                this.div = null, x(this, r).clear(), x(this, w).removeLayer(this);
              }
              render({
                viewport: a
              }) {
                this.viewport = a, (0, Q.setLayerDimensions)(this.div, a);
                for (const f of x(this, w).getEditors(this.pageIndex))
                  this.add(f);
                this.updateMode();
              }
              update({
                viewport: a
              }) {
                x(this, w).commitOrRemove(), this.viewport = a, (0, Q.setLayerDimensions)(this.div, {
                  rotation: a.rotation
                }), this.updateMode();
              }
              get pageDimensions() {
                const {
                  pageWidth: a,
                  pageHeight: f
                } = this.viewport.rawDims;
                return [a, f];
              }
            };
            N = new WeakMap(), H = new WeakMap(), B = new WeakMap(), P = new WeakMap(), S = new WeakMap(), r = new WeakMap(), u = new WeakMap(), m = new WeakMap(), s = new WeakMap(), w = new WeakMap(), i = new WeakSet(), _i = function(a) {
              switch (x(this, w).getMode()) {
                case n.AnnotationEditorType.FREETEXT:
                  return new l.FreeTextEditor(a);
                case n.AnnotationEditorType.INK:
                  return new W.InkEditor(a);
                case n.AnnotationEditorType.STAMP:
                  return new G.StampEditor(a);
              }
              return null;
            }, Sa = function(a, f) {
              const C = this.getNextId(), R = Te(this, i, _i).call(this, {
                parent: this,
                id: C,
                x: a.offsetX,
                y: a.offsetY,
                uiManager: x(this, w),
                isCentered: f
              });
              return R && this.add(R), R;
            }, Si = function() {
              const {
                x: a,
                y: f,
                width: C,
                height: R
              } = this.div.getBoundingClientRect(), M = Math.max(0, a), I = Math.max(0, f), E = Math.min(window.innerWidth, a + C), T = Math.min(window.innerHeight, f + R), y = (M + E) / 2 - a, D = (I + T) / 2 - f, [j, A] = this.viewport.rotation % 180 === 0 ? [y, D] : [D, y];
              return {
                offsetX: j,
                offsetY: A
              };
            }, yi = function() {
              je(this, m, !0);
              for (const a of x(this, r).values())
                a.isEmpty() && a.remove();
              je(this, m, !1);
            }, Tn(v, "_initialized", !1);
            let X = v;
            L.AnnotationEditorLayer = X;
          },
          /* 28 */
          /***/
          (e, L, p) => {
            var G, X, N, H, B, P, S, r, u, m, so, co, lo, na, wi, uo, Pi;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.FreeTextEditor = void 0;
            var n = p(1), t = p(5), l = p(4), W = p(29);
            const v = class v extends l.AnnotationEditor {
              constructor(f) {
                super({
                  ...f,
                  name: "freeTextEditor"
                });
                Ne(this, m);
                Ne(this, G, this.editorDivBlur.bind(this));
                Ne(this, X, this.editorDivFocus.bind(this));
                Ne(this, N, this.editorDivInput.bind(this));
                Ne(this, H, this.editorDivKeydown.bind(this));
                Ne(this, B);
                Ne(this, P, "");
                Ne(this, S, `${this.id}-editor`);
                Ne(this, r);
                Ne(this, u, null);
                je(this, B, f.color || v._defaultColor || l.AnnotationEditor._defaultLineColor), je(this, r, f.fontSize || v._defaultFontSize);
              }
              static get _keyboardManager() {
                const f = v.prototype, C = (I) => I.isEmpty(), R = t.AnnotationEditorUIManager.TRANSLATE_SMALL, M = t.AnnotationEditorUIManager.TRANSLATE_BIG;
                return (0, n.shadow)(this, "_keyboardManager", new t.KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], f.commitOrRemove, {
                  bubbles: !0
                }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], f.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], f._translateEmpty, {
                  args: [-R, 0],
                  checker: C
                }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], f._translateEmpty, {
                  args: [-M, 0],
                  checker: C
                }], [["ArrowRight", "mac+ArrowRight"], f._translateEmpty, {
                  args: [R, 0],
                  checker: C
                }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], f._translateEmpty, {
                  args: [M, 0],
                  checker: C
                }], [["ArrowUp", "mac+ArrowUp"], f._translateEmpty, {
                  args: [0, -R],
                  checker: C
                }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], f._translateEmpty, {
                  args: [0, -M],
                  checker: C
                }], [["ArrowDown", "mac+ArrowDown"], f._translateEmpty, {
                  args: [0, R],
                  checker: C
                }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], f._translateEmpty, {
                  args: [0, M],
                  checker: C
                }]]));
              }
              static initialize(f) {
                l.AnnotationEditor.initialize(f, {
                  strings: ["free_text2_default_content", "editor_free_text2_aria_label"]
                });
                const C = getComputedStyle(document.documentElement);
                this._internalPadding = parseFloat(C.getPropertyValue("--freetext-padding"));
              }
              static updateDefaultParams(f, C) {
                switch (f) {
                  case n.AnnotationEditorParamsType.FREETEXT_SIZE:
                    v._defaultFontSize = C;
                    break;
                  case n.AnnotationEditorParamsType.FREETEXT_COLOR:
                    v._defaultColor = C;
                    break;
                }
              }
              updateParams(f, C) {
                switch (f) {
                  case n.AnnotationEditorParamsType.FREETEXT_SIZE:
                    Te(this, m, so).call(this, C);
                    break;
                  case n.AnnotationEditorParamsType.FREETEXT_COLOR:
                    Te(this, m, co).call(this, C);
                    break;
                }
              }
              static get defaultPropertiesToUpdate() {
                return [[n.AnnotationEditorParamsType.FREETEXT_SIZE, v._defaultFontSize], [n.AnnotationEditorParamsType.FREETEXT_COLOR, v._defaultColor || l.AnnotationEditor._defaultLineColor]];
              }
              get propertiesToUpdate() {
                return [[n.AnnotationEditorParamsType.FREETEXT_SIZE, x(this, r)], [n.AnnotationEditorParamsType.FREETEXT_COLOR, x(this, B)]];
              }
              _translateEmpty(f, C) {
                this._uiManager.translateSelectedEditors(f, C, !0);
              }
              getInitialTranslation() {
                const f = this.parentScale;
                return [-v._internalPadding * f, -(v._internalPadding + x(this, r)) * f];
              }
              rebuild() {
                this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
              }
              enableEditMode() {
                this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(n.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.editorDiv.addEventListener("keydown", x(this, H)), this.editorDiv.addEventListener("focus", x(this, X)), this.editorDiv.addEventListener("blur", x(this, G)), this.editorDiv.addEventListener("input", x(this, N)));
              }
              disableEditMode() {
                this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", x(this, S)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", x(this, H)), this.editorDiv.removeEventListener("focus", x(this, X)), this.editorDiv.removeEventListener("blur", x(this, G)), this.editorDiv.removeEventListener("input", x(this, N)), this.div.focus({
                  preventScroll: !0
                }), this.isEditing = !1, this.parent.div.classList.add("freeTextEditing"));
              }
              focusin(f) {
                this._focusEventsAllowed && (super.focusin(f), f.target !== this.editorDiv && this.editorDiv.focus());
              }
              onceAdded() {
                var f;
                if (this.width) {
                  Te(this, m, Pi).call(this);
                  return;
                }
                this.enableEditMode(), this.editorDiv.focus(), (f = this._initialOptions) != null && f.isCentered && this.center(), this._initialOptions = null;
              }
              isEmpty() {
                return !this.editorDiv || this.editorDiv.innerText.trim() === "";
              }
              remove() {
                this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freeTextEditing")), super.remove();
              }
              commit() {
                if (!this.isInEditMode())
                  return;
                super.commit(), this.disableEditMode();
                const f = x(this, P), C = je(this, P, Te(this, m, lo).call(this).trimEnd());
                if (f === C)
                  return;
                const R = (M) => {
                  if (je(this, P, M), !M) {
                    this.remove();
                    return;
                  }
                  Te(this, m, wi).call(this), this._uiManager.rebuild(this), Te(this, m, na).call(this);
                };
                this.addCommands({
                  cmd: () => {
                    R(C);
                  },
                  undo: () => {
                    R(f);
                  },
                  mustExec: !1
                }), Te(this, m, na).call(this);
              }
              shouldGetKeyboardEvents() {
                return this.isInEditMode();
              }
              enterInEditMode() {
                this.enableEditMode(), this.editorDiv.focus();
              }
              dblclick(f) {
                this.enterInEditMode();
              }
              keydown(f) {
                f.target === this.div && f.key === "Enter" && (this.enterInEditMode(), f.preventDefault());
              }
              editorDivKeydown(f) {
                v._keyboardManager.exec(this, f);
              }
              editorDivFocus(f) {
                this.isEditing = !0;
              }
              editorDivBlur(f) {
                this.isEditing = !1;
              }
              editorDivInput(f) {
                this.parent.div.classList.toggle("freeTextEditing", this.isEmpty());
              }
              disableEditing() {
                this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
              }
              enableEditing() {
                this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
              }
              render() {
                if (this.div)
                  return this.div;
                let f, C;
                this.width && (f = this.x, C = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", x(this, S)), this.enableEditing(), l.AnnotationEditor._l10nPromise.get("editor_free_text2_aria_label").then((M) => {
                  var I;
                  return (I = this.editorDiv) == null ? void 0 : I.setAttribute("aria-label", M);
                }), l.AnnotationEditor._l10nPromise.get("free_text2_default_content").then((M) => {
                  var I;
                  return (I = this.editorDiv) == null ? void 0 : I.setAttribute("default-content", M);
                }), this.editorDiv.contentEditable = !0;
                const {
                  style: R
                } = this.editorDiv;
                if (R.fontSize = `calc(${x(this, r)}px * var(--scale-factor))`, R.color = x(this, B), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, t.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
                  const [M, I] = this.parentDimensions;
                  if (this.annotationElementId) {
                    const {
                      position: E
                    } = x(this, u);
                    let [T, y] = this.getInitialTranslation();
                    [T, y] = this.pageTranslationToScreen(T, y);
                    const [D, j] = this.pageDimensions, [A, d] = this.pageTranslation;
                    let _, F;
                    switch (this.rotation) {
                      case 0:
                        _ = f + (E[0] - A) / D, F = C + this.height - (E[1] - d) / j;
                        break;
                      case 90:
                        _ = f + (E[0] - A) / D, F = C - (E[1] - d) / j, [T, y] = [y, -T];
                        break;
                      case 180:
                        _ = f - this.width + (E[0] - A) / D, F = C - (E[1] - d) / j, [T, y] = [-T, -y];
                        break;
                      case 270:
                        _ = f + (E[0] - A - this.height * j) / D, F = C + (E[1] - d - this.width * D) / j, [T, y] = [-y, T];
                        break;
                    }
                    this.setAt(_ * M, F * I, T, y);
                  } else
                    this.setAt(f * M, C * I, this.width * M, this.height * I);
                  Te(this, m, wi).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
                } else
                  this._isDraggable = !1, this.editorDiv.contentEditable = !0;
                return this.div;
              }
              get contentDiv() {
                return this.editorDiv;
              }
              static deserialize(f, C, R) {
                let M = null;
                if (f instanceof W.FreeTextAnnotationElement) {
                  const {
                    data: {
                      defaultAppearanceData: {
                        fontSize: E,
                        fontColor: T
                      },
                      rect: y,
                      rotation: D,
                      id: j
                    },
                    textContent: A,
                    textPosition: d,
                    parent: {
                      page: {
                        pageNumber: _
                      }
                    }
                  } = f;
                  if (!A || A.length === 0)
                    return null;
                  M = f = {
                    annotationType: n.AnnotationEditorType.FREETEXT,
                    color: Array.from(T),
                    fontSize: E,
                    value: A.join(`
`),
                    position: d,
                    pageIndex: _ - 1,
                    rect: y,
                    rotation: D,
                    id: j,
                    deleted: !1
                  };
                }
                const I = super.deserialize(f, C, R);
                return je(I, r, f.fontSize), je(I, B, n.Util.makeHexColor(...f.color)), je(I, P, f.value), I.annotationElementId = f.id || null, je(I, u, M), I;
              }
              serialize(f = !1) {
                if (this.isEmpty())
                  return null;
                if (this.deleted)
                  return {
                    pageIndex: this.pageIndex,
                    id: this.annotationElementId,
                    deleted: !0
                  };
                const C = v._internalPadding * this.parentScale, R = this.getRect(C, C), M = l.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : x(this, B)), I = {
                  annotationType: n.AnnotationEditorType.FREETEXT,
                  color: M,
                  fontSize: x(this, r),
                  value: x(this, P),
                  pageIndex: this.pageIndex,
                  rect: R,
                  rotation: this.rotation,
                  structTreeParentId: this._structTreeParentId
                };
                return f ? I : this.annotationElementId && !Te(this, m, uo).call(this, I) ? null : (I.id = this.annotationElementId, I);
              }
            };
            G = new WeakMap(), X = new WeakMap(), N = new WeakMap(), H = new WeakMap(), B = new WeakMap(), P = new WeakMap(), S = new WeakMap(), r = new WeakMap(), u = new WeakMap(), m = new WeakSet(), so = function(f) {
              const C = (M) => {
                this.editorDiv.style.fontSize = `calc(${M}px * var(--scale-factor))`, this.translate(0, -(M - x(this, r)) * this.parentScale), je(this, r, M), Te(this, m, na).call(this);
              }, R = x(this, r);
              this.addCommands({
                cmd: () => {
                  C(f);
                },
                undo: () => {
                  C(R);
                },
                mustExec: !0,
                type: n.AnnotationEditorParamsType.FREETEXT_SIZE,
                overwriteIfSameType: !0,
                keepUndo: !0
              });
            }, co = function(f) {
              const C = x(this, B);
              this.addCommands({
                cmd: () => {
                  je(this, B, this.editorDiv.style.color = f);
                },
                undo: () => {
                  je(this, B, this.editorDiv.style.color = C);
                },
                mustExec: !0,
                type: n.AnnotationEditorParamsType.FREETEXT_COLOR,
                overwriteIfSameType: !0,
                keepUndo: !0
              });
            }, lo = function() {
              const f = this.editorDiv.getElementsByTagName("div");
              if (f.length === 0)
                return this.editorDiv.innerText;
              const C = [];
              for (const R of f)
                C.push(R.innerText.replace(/\r\n?|\n/, ""));
              return C.join(`
`);
            }, na = function() {
              const [f, C] = this.parentDimensions;
              let R;
              if (this.isAttachedToDOM)
                R = this.div.getBoundingClientRect();
              else {
                const {
                  currentLayer: M,
                  div: I
                } = this, E = I.style.display;
                I.style.display = "hidden", M.div.append(this.div), R = I.getBoundingClientRect(), I.remove(), I.style.display = E;
              }
              this.rotation % 180 === this.parentRotation % 180 ? (this.width = R.width / f, this.height = R.height / C) : (this.width = R.height / f, this.height = R.width / C), this.fixAndSetPosition();
            }, wi = function() {
              if (this.editorDiv.replaceChildren(), !!x(this, P))
                for (const f of x(this, P).split(`
`)) {
                  const C = document.createElement("div");
                  C.append(f ? document.createTextNode(f) : document.createElement("br")), this.editorDiv.append(C);
                }
            }, uo = function(f) {
              const {
                value: C,
                fontSize: R,
                color: M,
                rect: I,
                pageIndex: E
              } = x(this, u);
              return f.value !== C || f.fontSize !== R || f.rect.some((T, y) => Math.abs(T - I[y]) >= 1) || f.color.some((T, y) => T !== M[y]) || f.pageIndex !== E;
            }, Pi = function(f = !1) {
              if (!this.annotationElementId)
                return;
              if (Te(this, m, na).call(this), !f && (this.width === 0 || this.height === 0)) {
                setTimeout(() => Te(this, m, Pi).call(this, !0), 0);
                return;
              }
              const C = v._internalPadding * this.parentScale;
              x(this, u).rect = this.getRect(C, C);
            }, Tn(v, "_freeTextDefaultContent", ""), Tn(v, "_internalPadding", 0), Tn(v, "_defaultColor", null), Tn(v, "_defaultFontSize", 10), Tn(v, "_type", "freetext");
            let Q = v;
            L.FreeTextEditor = Q;
          },
          /* 29 */
          /***/
          (e, L, p) => {
            var F, V, Ir, ho, ge, be, le, fe, Ae, qe, ye, ce, q, Z, pe, me, _e, Be, ke, de, $e, Ge, fo, ya, Ci, ki, Xe, ct, xt, We, Ce, Re, lt, Mi, Et, oe, He, at, mo, Ri;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.StampAnnotationElement = L.InkAnnotationElement = L.FreeTextAnnotationElement = L.AnnotationLayer = void 0;
            var n = p(1), t = p(6), l = p(3), W = p(30), Q = p(31), G = p(32);
            const X = 1e3, N = 9, H = /* @__PURE__ */ new WeakSet();
            function B(dt) {
              return {
                width: dt[2] - dt[0],
                height: dt[3] - dt[1]
              };
            }
            class P {
              static create(ie) {
                switch (ie.data.annotationType) {
                  case n.AnnotationType.LINK:
                    return new r(ie);
                  case n.AnnotationType.TEXT:
                    return new u(ie);
                  case n.AnnotationType.WIDGET:
                    switch (ie.data.fieldType) {
                      case "Tx":
                        return new s(ie);
                      case "Btn":
                        return ie.data.radioButton ? new o(ie) : ie.data.checkBox ? new i(ie) : new b(ie);
                      case "Ch":
                        return new g(ie);
                      case "Sig":
                        return new w(ie);
                    }
                    return new m(ie);
                  case n.AnnotationType.POPUP:
                    return new c(ie);
                  case n.AnnotationType.FREETEXT:
                    return new k(ie);
                  case n.AnnotationType.LINE:
                    return new a(ie);
                  case n.AnnotationType.SQUARE:
                    return new f(ie);
                  case n.AnnotationType.CIRCLE:
                    return new C(ie);
                  case n.AnnotationType.POLYLINE:
                    return new R(ie);
                  case n.AnnotationType.CARET:
                    return new I(ie);
                  case n.AnnotationType.INK:
                    return new E(ie);
                  case n.AnnotationType.POLYGON:
                    return new M(ie);
                  case n.AnnotationType.HIGHLIGHT:
                    return new T(ie);
                  case n.AnnotationType.UNDERLINE:
                    return new y(ie);
                  case n.AnnotationType.SQUIGGLY:
                    return new D(ie);
                  case n.AnnotationType.STRIKEOUT:
                    return new j(ie);
                  case n.AnnotationType.STAMP:
                    return new A(ie);
                  case n.AnnotationType.FILEATTACHMENT:
                    return new d(ie);
                  default:
                    return new S(ie);
                }
              }
            }
            const U = class U {
              constructor(ie, {
                isRenderable: te = !1,
                ignoreBorder: we = !1,
                createQuadrilaterals: De = !1
              } = {}) {
                Ne(this, F, !1);
                this.isRenderable = te, this.data = ie.data, this.layer = ie.layer, this.linkService = ie.linkService, this.downloadManager = ie.downloadManager, this.imageResourcesPath = ie.imageResourcesPath, this.renderForms = ie.renderForms, this.svgFactory = ie.svgFactory, this.annotationStorage = ie.annotationStorage, this.enableScripting = ie.enableScripting, this.hasJSActions = ie.hasJSActions, this._fieldObjects = ie.fieldObjects, this.parent = ie.parent, te && (this.container = this._createContainer(we)), De && this._createQuadrilaterals();
              }
              static _hasPopupData({
                titleObj: ie,
                contentsObj: te,
                richText: we
              }) {
                return !!(ie != null && ie.str || te != null && te.str || we != null && we.str);
              }
              get hasPopupData() {
                return U._hasPopupData(this.data);
              }
              _createContainer(ie) {
                const {
                  data: te,
                  parent: {
                    page: we,
                    viewport: De
                  }
                } = this, Ve = document.createElement("section");
                Ve.setAttribute("data-annotation-id", te.id), this instanceof m || (Ve.tabIndex = X), Ve.style.zIndex = this.parent.zIndex++, this.data.popupRef && Ve.setAttribute("aria-haspopup", "dialog"), te.noRotate && Ve.classList.add("norotate");
                const {
                  pageWidth: Ye,
                  pageHeight: Je,
                  pageX: Pt,
                  pageY: mt
                } = De.rawDims;
                if (!te.rect || this instanceof c) {
                  const {
                    rotation: zt
                  } = te;
                  return !te.hasOwnCanvas && zt !== 0 && this.setRotation(zt, Ve), Ve;
                }
                const {
                  width: pt,
                  height: Ut
                } = B(te.rect), Ct = n.Util.normalizeRect([te.rect[0], we.view[3] - te.rect[1] + we.view[1], te.rect[2], we.view[3] - te.rect[3] + we.view[1]]);
                if (!ie && te.borderStyle.width > 0) {
                  Ve.style.borderWidth = `${te.borderStyle.width}px`;
                  const zt = te.borderStyle.horizontalCornerRadius, Xt = te.borderStyle.verticalCornerRadius;
                  if (zt > 0 || Xt > 0) {
                    const gn = `calc(${zt}px * var(--scale-factor)) / calc(${Xt}px * var(--scale-factor))`;
                    Ve.style.borderRadius = gn;
                  } else if (this instanceof o) {
                    const gn = `calc(${pt}px * var(--scale-factor)) / calc(${Ut}px * var(--scale-factor))`;
                    Ve.style.borderRadius = gn;
                  }
                  switch (te.borderStyle.style) {
                    case n.AnnotationBorderStyleType.SOLID:
                      Ve.style.borderStyle = "solid";
                      break;
                    case n.AnnotationBorderStyleType.DASHED:
                      Ve.style.borderStyle = "dashed";
                      break;
                    case n.AnnotationBorderStyleType.BEVELED:
                      (0, n.warn)("Unimplemented border style: beveled");
                      break;
                    case n.AnnotationBorderStyleType.INSET:
                      (0, n.warn)("Unimplemented border style: inset");
                      break;
                    case n.AnnotationBorderStyleType.UNDERLINE:
                      Ve.style.borderBottomStyle = "solid";
                      break;
                  }
                  const sn = te.borderColor || null;
                  sn ? (je(this, F, !0), Ve.style.borderColor = n.Util.makeHexColor(sn[0] | 0, sn[1] | 0, sn[2] | 0)) : Ve.style.borderWidth = 0;
                }
                Ve.style.left = `${100 * (Ct[0] - Pt) / Ye}%`, Ve.style.top = `${100 * (Ct[1] - mt) / Je}%`;
                const {
                  rotation: Mt
                } = te;
                return te.hasOwnCanvas || Mt === 0 ? (Ve.style.width = `${100 * pt / Ye}%`, Ve.style.height = `${100 * Ut / Je}%`) : this.setRotation(Mt, Ve), Ve;
              }
              setRotation(ie, te = this.container) {
                if (!this.data.rect)
                  return;
                const {
                  pageWidth: we,
                  pageHeight: De
                } = this.parent.viewport.rawDims, {
                  width: Ve,
                  height: Ye
                } = B(this.data.rect);
                let Je, Pt;
                ie % 180 === 0 ? (Je = 100 * Ve / we, Pt = 100 * Ye / De) : (Je = 100 * Ye / we, Pt = 100 * Ve / De), te.style.width = `${Je}%`, te.style.height = `${Pt}%`, te.setAttribute("data-main-rotation", (360 - ie) % 360);
              }
              get _commonActions() {
                const ie = (te, we, De) => {
                  const Ve = De.detail[te], Ye = Ve[0], Je = Ve.slice(1);
                  De.target.style[we] = W.ColorConverters[`${Ye}_HTML`](Je), this.annotationStorage.setValue(this.data.id, {
                    [we]: W.ColorConverters[`${Ye}_rgb`](Je)
                  });
                };
                return (0, n.shadow)(this, "_commonActions", {
                  display: (te) => {
                    const {
                      display: we
                    } = te.detail, De = we % 2 === 1;
                    this.container.style.visibility = De ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                      noView: De,
                      noPrint: we === 1 || we === 2
                    });
                  },
                  print: (te) => {
                    this.annotationStorage.setValue(this.data.id, {
                      noPrint: !te.detail.print
                    });
                  },
                  hidden: (te) => {
                    const {
                      hidden: we
                    } = te.detail;
                    this.container.style.visibility = we ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                      noPrint: we,
                      noView: we
                    });
                  },
                  focus: (te) => {
                    setTimeout(() => te.target.focus({
                      preventScroll: !1
                    }), 0);
                  },
                  userName: (te) => {
                    te.target.title = te.detail.userName;
                  },
                  readonly: (te) => {
                    te.target.disabled = te.detail.readonly;
                  },
                  required: (te) => {
                    this._setRequired(te.target, te.detail.required);
                  },
                  bgColor: (te) => {
                    ie("bgColor", "backgroundColor", te);
                  },
                  fillColor: (te) => {
                    ie("fillColor", "backgroundColor", te);
                  },
                  fgColor: (te) => {
                    ie("fgColor", "color", te);
                  },
                  textColor: (te) => {
                    ie("textColor", "color", te);
                  },
                  borderColor: (te) => {
                    ie("borderColor", "borderColor", te);
                  },
                  strokeColor: (te) => {
                    ie("strokeColor", "borderColor", te);
                  },
                  rotation: (te) => {
                    const we = te.detail.rotation;
                    this.setRotation(we), this.annotationStorage.setValue(this.data.id, {
                      rotation: we
                    });
                  }
                });
              }
              _dispatchEventFromSandbox(ie, te) {
                const we = this._commonActions;
                for (const De of Object.keys(te.detail)) {
                  const Ve = ie[De] || we[De];
                  Ve == null || Ve(te);
                }
              }
              _setDefaultPropertiesFromJS(ie) {
                if (!this.enableScripting)
                  return;
                const te = this.annotationStorage.getRawValue(this.data.id);
                if (!te)
                  return;
                const we = this._commonActions;
                for (const [De, Ve] of Object.entries(te)) {
                  const Ye = we[De];
                  if (Ye) {
                    const Je = {
                      detail: {
                        [De]: Ve
                      },
                      target: ie
                    };
                    Ye(Je), delete te[De];
                  }
                }
              }
              _createQuadrilaterals() {
                if (!this.container)
                  return;
                const {
                  quadPoints: ie
                } = this.data;
                if (!ie)
                  return;
                const [te, we, De, Ve] = this.data.rect;
                if (ie.length === 1) {
                  const [, {
                    x: Xt,
                    y: sn
                  }, {
                    x: gn,
                    y: Un
                  }] = ie[0];
                  if (De === Xt && Ve === sn && te === gn && we === Un)
                    return;
                }
                const {
                  style: Ye
                } = this.container;
                let Je;
                if (x(this, F)) {
                  const {
                    borderColor: Xt,
                    borderWidth: sn
                  } = Ye;
                  Ye.borderWidth = 0, Je = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${Xt}" stroke-width="${sn}">`], this.container.classList.add("hasBorder");
                }
                const Pt = De - te, mt = Ve - we, {
                  svgFactory: pt
                } = this, Ut = pt.createElement("svg");
                Ut.classList.add("quadrilateralsContainer"), Ut.setAttribute("width", 0), Ut.setAttribute("height", 0);
                const Ct = pt.createElement("defs");
                Ut.append(Ct);
                const Mt = pt.createElement("clipPath"), zt = `clippath_${this.data.id}`;
                Mt.setAttribute("id", zt), Mt.setAttribute("clipPathUnits", "objectBoundingBox"), Ct.append(Mt);
                for (const [, {
                  x: Xt,
                  y: sn
                }, {
                  x: gn,
                  y: Un
                }] of ie) {
                  const xn = pt.createElement("rect"), lr = (gn - te) / Pt, hr = (Ve - sn) / mt, fr = (Xt - gn) / Pt, Fr = (sn - Un) / mt;
                  xn.setAttribute("x", lr), xn.setAttribute("y", hr), xn.setAttribute("width", fr), xn.setAttribute("height", Fr), Mt.append(xn), Je == null || Je.push(`<rect vector-effect="non-scaling-stroke" x="${lr}" y="${hr}" width="${fr}" height="${Fr}"/>`);
                }
                x(this, F) && (Je.push("</g></svg>')"), Ye.backgroundImage = Je.join("")), this.container.append(Ut), this.container.style.clipPath = `url(#${zt})`;
              }
              _createPopup() {
                const {
                  container: ie,
                  data: te
                } = this;
                ie.setAttribute("aria-haspopup", "dialog");
                const we = new c({
                  data: {
                    color: te.color,
                    titleObj: te.titleObj,
                    modificationDate: te.modificationDate,
                    contentsObj: te.contentsObj,
                    richText: te.richText,
                    parentRect: te.rect,
                    borderStyle: 0,
                    id: `popup_${te.id}`,
                    rotation: te.rotation
                  },
                  parent: this.parent,
                  elements: [this]
                });
                this.parent.div.append(we.render());
              }
              render() {
                (0, n.unreachable)("Abstract method `AnnotationElement.render` called");
              }
              _getElementsByName(ie, te = null) {
                const we = [];
                if (this._fieldObjects) {
                  const De = this._fieldObjects[ie];
                  if (De)
                    for (const {
                      page: Ve,
                      id: Ye,
                      exportValues: Je
                    } of De) {
                      if (Ve === -1 || Ye === te)
                        continue;
                      const Pt = typeof Je == "string" ? Je : null, mt = document.querySelector(`[data-element-id="${Ye}"]`);
                      if (mt && !H.has(mt)) {
                        (0, n.warn)(`_getElementsByName - element not allowed: ${Ye}`);
                        continue;
                      }
                      we.push({
                        id: Ye,
                        exportValue: Pt,
                        domElement: mt
                      });
                    }
                  return we;
                }
                for (const De of document.getElementsByName(ie)) {
                  const {
                    exportValue: Ve
                  } = De, Ye = De.getAttribute("data-element-id");
                  Ye !== te && H.has(De) && we.push({
                    id: Ye,
                    exportValue: Ve,
                    domElement: De
                  });
                }
                return we;
              }
              show() {
                var ie;
                this.container && (this.container.hidden = !1), (ie = this.popup) == null || ie.maybeShow();
              }
              hide() {
                var ie;
                this.container && (this.container.hidden = !0), (ie = this.popup) == null || ie.forceHide();
              }
              getElementsToTriggerPopup() {
                return this.container;
              }
              addHighlightArea() {
                const ie = this.getElementsToTriggerPopup();
                if (Array.isArray(ie))
                  for (const te of ie)
                    te.classList.add("highlightArea");
                else
                  ie.classList.add("highlightArea");
              }
              _editOnDoubleClick() {
                const {
                  annotationEditorType: ie,
                  data: {
                    id: te
                  }
                } = this;
                this.container.addEventListener("dblclick", () => {
                  var we;
                  (we = this.linkService.eventBus) == null || we.dispatch("switchannotationeditormode", {
                    source: this,
                    mode: ie,
                    editId: te
                  });
                });
              }
            };
            F = new WeakMap();
            let S = U;
            class r extends S {
              constructor(te, we = null) {
                super(te, {
                  isRenderable: !0,
                  ignoreBorder: !!(we != null && we.ignoreBorder),
                  createQuadrilaterals: !0
                });
                Ne(this, V);
                this.isTooltipOnly = te.data.isTooltipOnly;
              }
              render() {
                const {
                  data: te,
                  linkService: we
                } = this, De = document.createElement("a");
                De.setAttribute("data-element-id", te.id);
                let Ve = !1;
                return te.url ? (we.addLinkAttributes(De, te.url, te.newWindow), Ve = !0) : te.action ? (this._bindNamedAction(De, te.action), Ve = !0) : te.attachment ? (this._bindAttachment(De, te.attachment), Ve = !0) : te.setOCGState ? (Te(this, V, ho).call(this, De, te.setOCGState), Ve = !0) : te.dest ? (this._bindLink(De, te.dest), Ve = !0) : (te.actions && (te.actions.Action || te.actions["Mouse Up"] || te.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(De, te), Ve = !0), te.resetForm ? (this._bindResetFormAction(De, te.resetForm), Ve = !0) : this.isTooltipOnly && !Ve && (this._bindLink(De, ""), Ve = !0)), this.container.classList.add("linkAnnotation"), Ve && this.container.append(De), this.container;
              }
              _bindLink(te, we) {
                te.href = this.linkService.getDestinationHash(we), te.onclick = () => (we && this.linkService.goToDestination(we), !1), (we || we === "") && Te(this, V, Ir).call(this);
              }
              _bindNamedAction(te, we) {
                te.href = this.linkService.getAnchorUrl(""), te.onclick = () => (this.linkService.executeNamedAction(we), !1), Te(this, V, Ir).call(this);
              }
              _bindAttachment(te, we) {
                te.href = this.linkService.getAnchorUrl(""), te.onclick = () => {
                  var De;
                  return (De = this.downloadManager) == null || De.openOrDownloadData(this.container, we.content, we.filename), !1;
                }, Te(this, V, Ir).call(this);
              }
              _bindJSAction(te, we) {
                te.href = this.linkService.getAnchorUrl("");
                const De = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
                for (const Ve of Object.keys(we.actions)) {
                  const Ye = De.get(Ve);
                  Ye && (te[Ye] = () => {
                    var Je;
                    return (Je = this.linkService.eventBus) == null || Je.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: we.id,
                        name: Ve
                      }
                    }), !1;
                  });
                }
                te.onclick || (te.onclick = () => !1), Te(this, V, Ir).call(this);
              }
              _bindResetFormAction(te, we) {
                const De = te.onclick;
                if (De || (te.href = this.linkService.getAnchorUrl("")), Te(this, V, Ir).call(this), !this._fieldObjects) {
                  (0, n.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), De || (te.onclick = () => !1);
                  return;
                }
                te.onclick = () => {
                  var Ut;
                  De == null || De();
                  const {
                    fields: Ve,
                    refs: Ye,
                    include: Je
                  } = we, Pt = [];
                  if (Ve.length !== 0 || Ye.length !== 0) {
                    const Ct = new Set(Ye);
                    for (const Mt of Ve) {
                      const zt = this._fieldObjects[Mt] || [];
                      for (const {
                        id: Xt
                      } of zt)
                        Ct.add(Xt);
                    }
                    for (const Mt of Object.values(this._fieldObjects))
                      for (const zt of Mt)
                        Ct.has(zt.id) === Je && Pt.push(zt);
                  } else
                    for (const Ct of Object.values(this._fieldObjects))
                      Pt.push(...Ct);
                  const mt = this.annotationStorage, pt = [];
                  for (const Ct of Pt) {
                    const {
                      id: Mt
                    } = Ct;
                    switch (pt.push(Mt), Ct.type) {
                      case "text": {
                        const Xt = Ct.defaultValue || "";
                        mt.setValue(Mt, {
                          value: Xt
                        });
                        break;
                      }
                      case "checkbox":
                      case "radiobutton": {
                        const Xt = Ct.defaultValue === Ct.exportValues;
                        mt.setValue(Mt, {
                          value: Xt
                        });
                        break;
                      }
                      case "combobox":
                      case "listbox": {
                        const Xt = Ct.defaultValue || "";
                        mt.setValue(Mt, {
                          value: Xt
                        });
                        break;
                      }
                      default:
                        continue;
                    }
                    const zt = document.querySelector(`[data-element-id="${Mt}"]`);
                    if (zt) {
                      if (!H.has(zt)) {
                        (0, n.warn)(`_bindResetFormAction - element not allowed: ${Mt}`);
                        continue;
                      }
                    } else continue;
                    zt.dispatchEvent(new Event("resetform"));
                  }
                  return this.enableScripting && ((Ut = this.linkService.eventBus) == null || Ut.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: "app",
                      ids: pt,
                      name: "ResetForm"
                    }
                  })), !1;
                };
              }
            }
            V = new WeakSet(), Ir = function() {
              this.container.setAttribute("data-internal-link", "");
            }, ho = function(te, we) {
              te.href = this.linkService.getAnchorUrl(""), te.onclick = () => (this.linkService.executeSetOCGState(we), !1), Te(this, V, Ir).call(this);
            };
            class u extends S {
              constructor(ie) {
                super(ie, {
                  isRenderable: !0
                });
              }
              render() {
                this.container.classList.add("textAnnotation");
                const ie = document.createElement("img");
                return ie.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", ie.alt = "[{{type}} Annotation]", ie.dataset.l10nId = "text_annotation_type", ie.dataset.l10nArgs = JSON.stringify({
                  type: this.data.name
                }), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(ie), this.container;
              }
            }
            class m extends S {
              render() {
                return this.data.alternativeText && (this.container.title = this.data.alternativeText), this.container;
              }
              showElementAndHideCanvas(ie) {
                var te;
                this.data.hasOwnCanvas && (((te = ie.previousSibling) == null ? void 0 : te.nodeName) === "CANVAS" && (ie.previousSibling.hidden = !0), ie.hidden = !1);
              }
              _getKeyModifier(ie) {
                const {
                  isWin: te,
                  isMac: we
                } = n.FeatureTest.platform;
                return te && ie.ctrlKey || we && ie.metaKey;
              }
              _setEventListener(ie, te, we, De, Ve) {
                we.includes("mouse") ? ie.addEventListener(we, (Ye) => {
                  var Je;
                  (Je = this.linkService.eventBus) == null || Je.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: this.data.id,
                      name: De,
                      value: Ve(Ye),
                      shift: Ye.shiftKey,
                      modifier: this._getKeyModifier(Ye)
                    }
                  });
                }) : ie.addEventListener(we, (Ye) => {
                  var Je;
                  if (we === "blur") {
                    if (!te.focused || !Ye.relatedTarget)
                      return;
                    te.focused = !1;
                  } else if (we === "focus") {
                    if (te.focused)
                      return;
                    te.focused = !0;
                  }
                  Ve && ((Je = this.linkService.eventBus) == null || Je.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: this.data.id,
                      name: De,
                      value: Ve(Ye)
                    }
                  }));
                });
              }
              _setEventListeners(ie, te, we, De) {
                var Ve, Ye, Je;
                for (const [Pt, mt] of we)
                  (mt === "Action" || (Ve = this.data.actions) != null && Ve[mt]) && ((mt === "Focus" || mt === "Blur") && (te || (te = {
                    focused: !1
                  })), this._setEventListener(ie, te, Pt, mt, De), mt === "Focus" && !((Ye = this.data.actions) != null && Ye.Blur) ? this._setEventListener(ie, te, "blur", "Blur", null) : mt === "Blur" && !((Je = this.data.actions) != null && Je.Focus) && this._setEventListener(ie, te, "focus", "Focus", null));
              }
              _setBackgroundColor(ie) {
                const te = this.data.backgroundColor || null;
                ie.style.backgroundColor = te === null ? "transparent" : n.Util.makeHexColor(te[0], te[1], te[2]);
              }
              _setTextStyle(ie) {
                const te = ["left", "center", "right"], {
                  fontColor: we
                } = this.data.defaultAppearanceData, De = this.data.defaultAppearanceData.fontSize || N, Ve = ie.style;
                let Ye;
                const Je = 2, Pt = (mt) => Math.round(10 * mt) / 10;
                if (this.data.multiLine) {
                  const mt = Math.abs(this.data.rect[3] - this.data.rect[1] - Je), pt = Math.round(mt / (n.LINE_FACTOR * De)) || 1, Ut = mt / pt;
                  Ye = Math.min(De, Pt(Ut / n.LINE_FACTOR));
                } else {
                  const mt = Math.abs(this.data.rect[3] - this.data.rect[1] - Je);
                  Ye = Math.min(De, Pt(mt / n.LINE_FACTOR));
                }
                Ve.fontSize = `calc(${Ye}px * var(--scale-factor))`, Ve.color = n.Util.makeHexColor(we[0], we[1], we[2]), this.data.textAlignment !== null && (Ve.textAlign = te[this.data.textAlignment]);
              }
              _setRequired(ie, te) {
                te ? ie.setAttribute("required", !0) : ie.removeAttribute("required"), ie.setAttribute("aria-required", te);
              }
            }
            class s extends m {
              constructor(ie) {
                const te = ie.renderForms || !ie.data.hasAppearance && !!ie.data.fieldValue;
                super(ie, {
                  isRenderable: te
                });
              }
              setPropertyOnSiblings(ie, te, we, De) {
                const Ve = this.annotationStorage;
                for (const Ye of this._getElementsByName(ie.name, ie.id))
                  Ye.domElement && (Ye.domElement[te] = we), Ve.setValue(Ye.id, {
                    [De]: we
                  });
              }
              render() {
                var De, Ve;
                const ie = this.annotationStorage, te = this.data.id;
                this.container.classList.add("textWidgetAnnotation");
                let we = null;
                if (this.renderForms) {
                  const Ye = ie.getValue(te, {
                    value: this.data.fieldValue
                  });
                  let Je = Ye.value || "";
                  const Pt = ie.getValue(te, {
                    charLimit: this.data.maxLen
                  }).charLimit;
                  Pt && Je.length > Pt && (Je = Je.slice(0, Pt));
                  let mt = Ye.formattedValue || ((De = this.data.textContent) == null ? void 0 : De.join(`
`)) || null;
                  mt && this.data.comb && (mt = mt.replaceAll(/\s+/g, ""));
                  const pt = {
                    userValue: Je,
                    formattedValue: mt,
                    lastCommittedValue: null,
                    commitKey: 1,
                    focused: !1
                  };
                  this.data.multiLine ? (we = document.createElement("textarea"), we.textContent = mt ?? Je, this.data.doNotScroll && (we.style.overflowY = "hidden")) : (we = document.createElement("input"), we.type = "text", we.setAttribute("value", mt ?? Je), this.data.doNotScroll && (we.style.overflowX = "hidden")), this.data.hasOwnCanvas && (we.hidden = !0), H.add(we), we.setAttribute("data-element-id", te), we.disabled = this.data.readOnly, we.name = this.data.fieldName, we.tabIndex = X, this._setRequired(we, this.data.required), Pt && (we.maxLength = Pt), we.addEventListener("input", (Ct) => {
                    ie.setValue(te, {
                      value: Ct.target.value
                    }), this.setPropertyOnSiblings(we, "value", Ct.target.value, "value"), pt.formattedValue = null;
                  }), we.addEventListener("resetform", (Ct) => {
                    const Mt = this.data.defaultFieldValue ?? "";
                    we.value = pt.userValue = Mt, pt.formattedValue = null;
                  });
                  let Ut = (Ct) => {
                    const {
                      formattedValue: Mt
                    } = pt;
                    Mt != null && (Ct.target.value = Mt), Ct.target.scrollLeft = 0;
                  };
                  if (this.enableScripting && this.hasJSActions) {
                    we.addEventListener("focus", (Mt) => {
                      if (pt.focused)
                        return;
                      const {
                        target: zt
                      } = Mt;
                      pt.userValue && (zt.value = pt.userValue), pt.lastCommittedValue = zt.value, pt.commitKey = 1, pt.focused = !0;
                    }), we.addEventListener("updatefromsandbox", (Mt) => {
                      this.showElementAndHideCanvas(Mt.target);
                      const zt = {
                        value(Xt) {
                          pt.userValue = Xt.detail.value ?? "", ie.setValue(te, {
                            value: pt.userValue.toString()
                          }), Xt.target.value = pt.userValue;
                        },
                        formattedValue(Xt) {
                          const {
                            formattedValue: sn
                          } = Xt.detail;
                          pt.formattedValue = sn, sn != null && Xt.target !== document.activeElement && (Xt.target.value = sn), ie.setValue(te, {
                            formattedValue: sn
                          });
                        },
                        selRange(Xt) {
                          Xt.target.setSelectionRange(...Xt.detail.selRange);
                        },
                        charLimit: (Xt) => {
                          var xn;
                          const {
                            charLimit: sn
                          } = Xt.detail, {
                            target: gn
                          } = Xt;
                          if (sn === 0) {
                            gn.removeAttribute("maxLength");
                            return;
                          }
                          gn.setAttribute("maxLength", sn);
                          let Un = pt.userValue;
                          !Un || Un.length <= sn || (Un = Un.slice(0, sn), gn.value = pt.userValue = Un, ie.setValue(te, {
                            value: Un
                          }), (xn = this.linkService.eventBus) == null || xn.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id: te,
                              name: "Keystroke",
                              value: Un,
                              willCommit: !0,
                              commitKey: 1,
                              selStart: gn.selectionStart,
                              selEnd: gn.selectionEnd
                            }
                          }));
                        }
                      };
                      this._dispatchEventFromSandbox(zt, Mt);
                    }), we.addEventListener("keydown", (Mt) => {
                      var sn;
                      pt.commitKey = 1;
                      let zt = -1;
                      if (Mt.key === "Escape" ? zt = 0 : Mt.key === "Enter" && !this.data.multiLine ? zt = 2 : Mt.key === "Tab" && (pt.commitKey = 3), zt === -1)
                        return;
                      const {
                        value: Xt
                      } = Mt.target;
                      pt.lastCommittedValue !== Xt && (pt.lastCommittedValue = Xt, pt.userValue = Xt, (sn = this.linkService.eventBus) == null || sn.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: te,
                          name: "Keystroke",
                          value: Xt,
                          willCommit: !0,
                          commitKey: zt,
                          selStart: Mt.target.selectionStart,
                          selEnd: Mt.target.selectionEnd
                        }
                      }));
                    });
                    const Ct = Ut;
                    Ut = null, we.addEventListener("blur", (Mt) => {
                      var Xt;
                      if (!pt.focused || !Mt.relatedTarget)
                        return;
                      pt.focused = !1;
                      const {
                        value: zt
                      } = Mt.target;
                      pt.userValue = zt, pt.lastCommittedValue !== zt && ((Xt = this.linkService.eventBus) == null || Xt.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: te,
                          name: "Keystroke",
                          value: zt,
                          willCommit: !0,
                          commitKey: pt.commitKey,
                          selStart: Mt.target.selectionStart,
                          selEnd: Mt.target.selectionEnd
                        }
                      })), Ct(Mt);
                    }), (Ve = this.data.actions) != null && Ve.Keystroke && we.addEventListener("beforeinput", (Mt) => {
                      var hr;
                      pt.lastCommittedValue = null;
                      const {
                        data: zt,
                        target: Xt
                      } = Mt, {
                        value: sn,
                        selectionStart: gn,
                        selectionEnd: Un
                      } = Xt;
                      let xn = gn, lr = Un;
                      switch (Mt.inputType) {
                        case "deleteWordBackward": {
                          const fr = sn.substring(0, gn).match(/\w*[^\w]*$/);
                          fr && (xn -= fr[0].length);
                          break;
                        }
                        case "deleteWordForward": {
                          const fr = sn.substring(gn).match(/^[^\w]*\w*/);
                          fr && (lr += fr[0].length);
                          break;
                        }
                        case "deleteContentBackward":
                          gn === Un && (xn -= 1);
                          break;
                        case "deleteContentForward":
                          gn === Un && (lr += 1);
                          break;
                      }
                      Mt.preventDefault(), (hr = this.linkService.eventBus) == null || hr.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: te,
                          name: "Keystroke",
                          value: sn,
                          change: zt || "",
                          willCommit: !1,
                          selStart: xn,
                          selEnd: lr
                        }
                      });
                    }), this._setEventListeners(we, pt, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (Mt) => Mt.target.value);
                  }
                  if (Ut && we.addEventListener("blur", Ut), this.data.comb) {
                    const Mt = (this.data.rect[2] - this.data.rect[0]) / Pt;
                    we.classList.add("comb"), we.style.letterSpacing = `calc(${Mt}px * var(--scale-factor) - 1ch)`;
                  }
                } else
                  we = document.createElement("div"), we.textContent = this.data.fieldValue, we.style.verticalAlign = "middle", we.style.display = "table-cell";
                return this._setTextStyle(we), this._setBackgroundColor(we), this._setDefaultPropertiesFromJS(we), this.container.append(we), this.container;
              }
            }
            class w extends m {
              constructor(ie) {
                super(ie, {
                  isRenderable: !!ie.data.hasOwnCanvas
                });
              }
            }
            class i extends m {
              constructor(ie) {
                super(ie, {
                  isRenderable: ie.renderForms
                });
              }
              render() {
                const ie = this.annotationStorage, te = this.data, we = te.id;
                let De = ie.getValue(we, {
                  value: te.exportValue === te.fieldValue
                }).value;
                typeof De == "string" && (De = De !== "Off", ie.setValue(we, {
                  value: De
                })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
                const Ve = document.createElement("input");
                return H.add(Ve), Ve.setAttribute("data-element-id", we), Ve.disabled = te.readOnly, this._setRequired(Ve, this.data.required), Ve.type = "checkbox", Ve.name = te.fieldName, De && Ve.setAttribute("checked", !0), Ve.setAttribute("exportValue", te.exportValue), Ve.tabIndex = X, Ve.addEventListener("change", (Ye) => {
                  const {
                    name: Je,
                    checked: Pt
                  } = Ye.target;
                  for (const mt of this._getElementsByName(Je, we)) {
                    const pt = Pt && mt.exportValue === te.exportValue;
                    mt.domElement && (mt.domElement.checked = pt), ie.setValue(mt.id, {
                      value: pt
                    });
                  }
                  ie.setValue(we, {
                    value: Pt
                  });
                }), Ve.addEventListener("resetform", (Ye) => {
                  const Je = te.defaultFieldValue || "Off";
                  Ye.target.checked = Je === te.exportValue;
                }), this.enableScripting && this.hasJSActions && (Ve.addEventListener("updatefromsandbox", (Ye) => {
                  const Je = {
                    value(Pt) {
                      Pt.target.checked = Pt.detail.value !== "Off", ie.setValue(we, {
                        value: Pt.target.checked
                      });
                    }
                  };
                  this._dispatchEventFromSandbox(Je, Ye);
                }), this._setEventListeners(Ve, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (Ye) => Ye.target.checked)), this._setBackgroundColor(Ve), this._setDefaultPropertiesFromJS(Ve), this.container.append(Ve), this.container;
              }
            }
            class o extends m {
              constructor(ie) {
                super(ie, {
                  isRenderable: ie.renderForms
                });
              }
              render() {
                this.container.classList.add("buttonWidgetAnnotation", "radioButton");
                const ie = this.annotationStorage, te = this.data, we = te.id;
                let De = ie.getValue(we, {
                  value: te.fieldValue === te.buttonValue
                }).value;
                typeof De == "string" && (De = De !== te.buttonValue, ie.setValue(we, {
                  value: De
                }));
                const Ve = document.createElement("input");
                if (H.add(Ve), Ve.setAttribute("data-element-id", we), Ve.disabled = te.readOnly, this._setRequired(Ve, this.data.required), Ve.type = "radio", Ve.name = te.fieldName, De && Ve.setAttribute("checked", !0), Ve.tabIndex = X, Ve.addEventListener("change", (Ye) => {
                  const {
                    name: Je,
                    checked: Pt
                  } = Ye.target;
                  for (const mt of this._getElementsByName(Je, we))
                    ie.setValue(mt.id, {
                      value: !1
                    });
                  ie.setValue(we, {
                    value: Pt
                  });
                }), Ve.addEventListener("resetform", (Ye) => {
                  const Je = te.defaultFieldValue;
                  Ye.target.checked = Je != null && Je === te.buttonValue;
                }), this.enableScripting && this.hasJSActions) {
                  const Ye = te.buttonValue;
                  Ve.addEventListener("updatefromsandbox", (Je) => {
                    const Pt = {
                      value: (mt) => {
                        const pt = Ye === mt.detail.value;
                        for (const Ut of this._getElementsByName(mt.target.name)) {
                          const Ct = pt && Ut.id === we;
                          Ut.domElement && (Ut.domElement.checked = Ct), ie.setValue(Ut.id, {
                            value: Ct
                          });
                        }
                      }
                    };
                    this._dispatchEventFromSandbox(Pt, Je);
                  }), this._setEventListeners(Ve, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (Je) => Je.target.checked);
                }
                return this._setBackgroundColor(Ve), this._setDefaultPropertiesFromJS(Ve), this.container.append(Ve), this.container;
              }
            }
            class b extends r {
              constructor(ie) {
                super(ie, {
                  ignoreBorder: ie.data.hasAppearance
                });
              }
              render() {
                const ie = super.render();
                ie.classList.add("buttonWidgetAnnotation", "pushButton"), this.data.alternativeText && (ie.title = this.data.alternativeText);
                const te = ie.lastChild;
                return this.enableScripting && this.hasJSActions && te && (this._setDefaultPropertiesFromJS(te), te.addEventListener("updatefromsandbox", (we) => {
                  this._dispatchEventFromSandbox({}, we);
                })), ie;
              }
            }
            class g extends m {
              constructor(ie) {
                super(ie, {
                  isRenderable: ie.renderForms
                });
              }
              render() {
                this.container.classList.add("choiceWidgetAnnotation");
                const ie = this.annotationStorage, te = this.data.id, we = ie.getValue(te, {
                  value: this.data.fieldValue
                }), De = document.createElement("select");
                H.add(De), De.setAttribute("data-element-id", te), De.disabled = this.data.readOnly, this._setRequired(De, this.data.required), De.name = this.data.fieldName, De.tabIndex = X;
                let Ve = this.data.combo && this.data.options.length > 0;
                this.data.combo || (De.size = this.data.options.length, this.data.multiSelect && (De.multiple = !0)), De.addEventListener("resetform", (pt) => {
                  const Ut = this.data.defaultFieldValue;
                  for (const Ct of De.options)
                    Ct.selected = Ct.value === Ut;
                });
                for (const pt of this.data.options) {
                  const Ut = document.createElement("option");
                  Ut.textContent = pt.displayValue, Ut.value = pt.exportValue, we.value.includes(pt.exportValue) && (Ut.setAttribute("selected", !0), Ve = !1), De.append(Ut);
                }
                let Ye = null;
                if (Ve) {
                  const pt = document.createElement("option");
                  pt.value = " ", pt.setAttribute("hidden", !0), pt.setAttribute("selected", !0), De.prepend(pt), Ye = () => {
                    pt.remove(), De.removeEventListener("input", Ye), Ye = null;
                  }, De.addEventListener("input", Ye);
                }
                const Je = (pt) => {
                  const Ut = pt ? "value" : "textContent", {
                    options: Ct,
                    multiple: Mt
                  } = De;
                  return Mt ? Array.prototype.filter.call(Ct, (zt) => zt.selected).map((zt) => zt[Ut]) : Ct.selectedIndex === -1 ? null : Ct[Ct.selectedIndex][Ut];
                };
                let Pt = Je(!1);
                const mt = (pt) => {
                  const Ut = pt.target.options;
                  return Array.prototype.map.call(Ut, (Ct) => ({
                    displayValue: Ct.textContent,
                    exportValue: Ct.value
                  }));
                };
                return this.enableScripting && this.hasJSActions ? (De.addEventListener("updatefromsandbox", (pt) => {
                  const Ut = {
                    value(Ct) {
                      Ye == null || Ye();
                      const Mt = Ct.detail.value, zt = new Set(Array.isArray(Mt) ? Mt : [Mt]);
                      for (const Xt of De.options)
                        Xt.selected = zt.has(Xt.value);
                      ie.setValue(te, {
                        value: Je(!0)
                      }), Pt = Je(!1);
                    },
                    multipleSelection(Ct) {
                      De.multiple = !0;
                    },
                    remove(Ct) {
                      const Mt = De.options, zt = Ct.detail.remove;
                      Mt[zt].selected = !1, De.remove(zt), Mt.length > 0 && Array.prototype.findIndex.call(Mt, (sn) => sn.selected) === -1 && (Mt[0].selected = !0), ie.setValue(te, {
                        value: Je(!0),
                        items: mt(Ct)
                      }), Pt = Je(!1);
                    },
                    clear(Ct) {
                      for (; De.length !== 0; )
                        De.remove(0);
                      ie.setValue(te, {
                        value: null,
                        items: []
                      }), Pt = Je(!1);
                    },
                    insert(Ct) {
                      const {
                        index: Mt,
                        displayValue: zt,
                        exportValue: Xt
                      } = Ct.detail.insert, sn = De.children[Mt], gn = document.createElement("option");
                      gn.textContent = zt, gn.value = Xt, sn ? sn.before(gn) : De.append(gn), ie.setValue(te, {
                        value: Je(!0),
                        items: mt(Ct)
                      }), Pt = Je(!1);
                    },
                    items(Ct) {
                      const {
                        items: Mt
                      } = Ct.detail;
                      for (; De.length !== 0; )
                        De.remove(0);
                      for (const zt of Mt) {
                        const {
                          displayValue: Xt,
                          exportValue: sn
                        } = zt, gn = document.createElement("option");
                        gn.textContent = Xt, gn.value = sn, De.append(gn);
                      }
                      De.options.length > 0 && (De.options[0].selected = !0), ie.setValue(te, {
                        value: Je(!0),
                        items: mt(Ct)
                      }), Pt = Je(!1);
                    },
                    indices(Ct) {
                      const Mt = new Set(Ct.detail.indices);
                      for (const zt of Ct.target.options)
                        zt.selected = Mt.has(zt.index);
                      ie.setValue(te, {
                        value: Je(!0)
                      }), Pt = Je(!1);
                    },
                    editable(Ct) {
                      Ct.target.disabled = !Ct.detail.editable;
                    }
                  };
                  this._dispatchEventFromSandbox(Ut, pt);
                }), De.addEventListener("input", (pt) => {
                  var Ct;
                  const Ut = Je(!0);
                  ie.setValue(te, {
                    value: Ut
                  }), pt.preventDefault(), (Ct = this.linkService.eventBus) == null || Ct.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: te,
                      name: "Keystroke",
                      value: Pt,
                      changeEx: Ut,
                      willCommit: !1,
                      commitKey: 1,
                      keyDown: !1
                    }
                  });
                }), this._setEventListeners(De, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (pt) => pt.target.value)) : De.addEventListener("input", function(pt) {
                  ie.setValue(te, {
                    value: Je(!0)
                  });
                }), this.data.combo && this._setTextStyle(De), this._setBackgroundColor(De), this._setDefaultPropertiesFromJS(De), this.container.append(De), this.container;
              }
            }
            class c extends S {
              constructor(ie) {
                const {
                  data: te,
                  elements: we
                } = ie;
                super(ie, {
                  isRenderable: S._hasPopupData(te)
                }), this.elements = we;
              }
              render() {
                this.container.classList.add("popupAnnotation");
                const ie = new v({
                  container: this.container,
                  color: this.data.color,
                  titleObj: this.data.titleObj,
                  modificationDate: this.data.modificationDate,
                  contentsObj: this.data.contentsObj,
                  richText: this.data.richText,
                  rect: this.data.rect,
                  parentRect: this.data.parentRect || null,
                  parent: this.parent,
                  elements: this.elements,
                  open: this.data.open
                }), te = [];
                for (const we of this.elements)
                  we.popup = ie, te.push(we.data.id), we.addHighlightArea();
                return this.container.setAttribute("aria-controls", te.map((we) => `${n.AnnotationPrefix}${we}`).join(",")), this.container;
              }
            }
            class v {
              constructor({
                container: ie,
                color: te,
                elements: we,
                titleObj: De,
                modificationDate: Ve,
                contentsObj: Ye,
                richText: Je,
                parent: Pt,
                rect: mt,
                parentRect: pt,
                open: Ut
              }) {
                Ne(this, Ge);
                Ne(this, ge, null);
                Ne(this, be, Te(this, Ge, fo).bind(this));
                Ne(this, le, Te(this, Ge, ki).bind(this));
                Ne(this, fe, Te(this, Ge, Ci).bind(this));
                Ne(this, Ae, Te(this, Ge, ya).bind(this));
                Ne(this, qe, null);
                Ne(this, ye, null);
                Ne(this, ce, null);
                Ne(this, q, null);
                Ne(this, Z, null);
                Ne(this, pe, null);
                Ne(this, me, !1);
                Ne(this, _e, null);
                Ne(this, Be, null);
                Ne(this, ke, null);
                Ne(this, de, null);
                Ne(this, $e, !1);
                var Mt;
                je(this, ye, ie), je(this, de, De), je(this, ce, Ye), je(this, ke, Je), je(this, Z, Pt), je(this, qe, te), je(this, Be, mt), je(this, pe, pt), je(this, q, we);
                const Ct = t.PDFDateString.toDateObject(Ve);
                Ct && je(this, ge, Pt.l10n.get("annotation_date_string", {
                  date: Ct.toLocaleDateString(),
                  time: Ct.toLocaleTimeString()
                })), this.trigger = we.flatMap((zt) => zt.getElementsToTriggerPopup());
                for (const zt of this.trigger)
                  zt.addEventListener("click", x(this, Ae)), zt.addEventListener("mouseenter", x(this, fe)), zt.addEventListener("mouseleave", x(this, le)), zt.classList.add("popupTriggerArea");
                for (const zt of we)
                  (Mt = zt.container) == null || Mt.addEventListener("keydown", x(this, be));
                x(this, ye).hidden = !0, Ut && Te(this, Ge, ya).call(this);
              }
              render() {
                if (x(this, _e))
                  return;
                const {
                  page: {
                    view: ie
                  },
                  viewport: {
                    rawDims: {
                      pageWidth: te,
                      pageHeight: we,
                      pageX: De,
                      pageY: Ve
                    }
                  }
                } = x(this, Z), Ye = je(this, _e, document.createElement("div"));
                if (Ye.className = "popup", x(this, qe)) {
                  const xn = Ye.style.outlineColor = n.Util.makeHexColor(...x(this, qe));
                  CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? Ye.style.backgroundColor = `color-mix(in srgb, ${xn} 30%, white)` : Ye.style.backgroundColor = n.Util.makeHexColor(...x(this, qe).map((hr) => Math.floor(0.7 * (255 - hr) + hr)));
                }
                const Je = document.createElement("span");
                Je.className = "header";
                const Pt = document.createElement("h1");
                if (Je.append(Pt), {
                  dir: Pt.dir,
                  str: Pt.textContent
                } = x(this, de), Ye.append(Je), x(this, ge)) {
                  const xn = document.createElement("span");
                  xn.classList.add("popupDate"), x(this, ge).then((lr) => {
                    xn.textContent = lr;
                  }), Je.append(xn);
                }
                const mt = x(this, ce), pt = x(this, ke);
                if (pt != null && pt.str && (!(mt != null && mt.str) || mt.str === pt.str))
                  G.XfaLayer.render({
                    xfaHtml: pt.html,
                    intent: "richText",
                    div: Ye
                  }), Ye.lastChild.classList.add("richText", "popupContent");
                else {
                  const xn = this._formatContents(mt);
                  Ye.append(xn);
                }
                let Ut = !!x(this, pe), Ct = Ut ? x(this, pe) : x(this, Be);
                for (const xn of x(this, q))
                  if (!Ct || n.Util.intersect(xn.data.rect, Ct) !== null) {
                    Ct = xn.data.rect, Ut = !0;
                    break;
                  }
                const Mt = n.Util.normalizeRect([Ct[0], ie[3] - Ct[1] + ie[1], Ct[2], ie[3] - Ct[3] + ie[1]]), Xt = Ut ? Ct[2] - Ct[0] + 5 : 0, sn = Mt[0] + Xt, gn = Mt[1], {
                  style: Un
                } = x(this, ye);
                Un.left = `${100 * (sn - De) / te}%`, Un.top = `${100 * (gn - Ve) / we}%`, x(this, ye).append(Ye);
              }
              _formatContents({
                str: ie,
                dir: te
              }) {
                const we = document.createElement("p");
                we.classList.add("popupContent"), we.dir = te;
                const De = ie.split(/(?:\r\n?|\n)/);
                for (let Ve = 0, Ye = De.length; Ve < Ye; ++Ve) {
                  const Je = De[Ve];
                  we.append(document.createTextNode(Je)), Ve < Ye - 1 && we.append(document.createElement("br"));
                }
                return we;
              }
              forceHide() {
                je(this, $e, this.isVisible), x(this, $e) && (x(this, ye).hidden = !0);
              }
              maybeShow() {
                x(this, $e) && (je(this, $e, !1), x(this, ye).hidden = !1);
              }
              get isVisible() {
                return x(this, ye).hidden === !1;
              }
            }
            ge = new WeakMap(), be = new WeakMap(), le = new WeakMap(), fe = new WeakMap(), Ae = new WeakMap(), qe = new WeakMap(), ye = new WeakMap(), ce = new WeakMap(), q = new WeakMap(), Z = new WeakMap(), pe = new WeakMap(), me = new WeakMap(), _e = new WeakMap(), Be = new WeakMap(), ke = new WeakMap(), de = new WeakMap(), $e = new WeakMap(), Ge = new WeakSet(), fo = function(ie) {
              ie.altKey || ie.shiftKey || ie.ctrlKey || ie.metaKey || (ie.key === "Enter" || ie.key === "Escape" && x(this, me)) && Te(this, Ge, ya).call(this);
            }, ya = function() {
              je(this, me, !x(this, me)), x(this, me) ? (Te(this, Ge, Ci).call(this), x(this, ye).addEventListener("click", x(this, Ae)), x(this, ye).addEventListener("keydown", x(this, be))) : (Te(this, Ge, ki).call(this), x(this, ye).removeEventListener("click", x(this, Ae)), x(this, ye).removeEventListener("keydown", x(this, be)));
            }, Ci = function() {
              x(this, _e) || this.render(), this.isVisible ? x(this, me) && x(this, ye).classList.add("focused") : (x(this, ye).hidden = !1, x(this, ye).style.zIndex = parseInt(x(this, ye).style.zIndex) + 1e3);
            }, ki = function() {
              x(this, ye).classList.remove("focused"), !(x(this, me) || !this.isVisible) && (x(this, ye).hidden = !0, x(this, ye).style.zIndex = parseInt(x(this, ye).style.zIndex) - 1e3);
            };
            class k extends S {
              constructor(ie) {
                super(ie, {
                  isRenderable: !0,
                  ignoreBorder: !0
                }), this.textContent = ie.data.textContent, this.textPosition = ie.data.textPosition, this.annotationEditorType = n.AnnotationEditorType.FREETEXT;
              }
              render() {
                if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
                  const ie = document.createElement("div");
                  ie.classList.add("annotationTextContent"), ie.setAttribute("role", "comment");
                  for (const te of this.textContent) {
                    const we = document.createElement("span");
                    we.textContent = te, ie.append(we);
                  }
                  this.container.append(ie);
                }
                return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
              }
            }
            L.FreeTextAnnotationElement = k;
            class a extends S {
              constructor(te) {
                super(te, {
                  isRenderable: !0,
                  ignoreBorder: !0
                });
                Ne(this, Xe, null);
              }
              render() {
                this.container.classList.add("lineAnnotation");
                const te = this.data, {
                  width: we,
                  height: De
                } = B(te.rect), Ve = this.svgFactory.create(we, De, !0), Ye = je(this, Xe, this.svgFactory.createElement("svg:line"));
                return Ye.setAttribute("x1", te.rect[2] - te.lineCoordinates[0]), Ye.setAttribute("y1", te.rect[3] - te.lineCoordinates[1]), Ye.setAttribute("x2", te.rect[2] - te.lineCoordinates[2]), Ye.setAttribute("y2", te.rect[3] - te.lineCoordinates[3]), Ye.setAttribute("stroke-width", te.borderStyle.width || 1), Ye.setAttribute("stroke", "transparent"), Ye.setAttribute("fill", "transparent"), Ve.append(Ye), this.container.append(Ve), !te.popupRef && this.hasPopupData && this._createPopup(), this.container;
              }
              getElementsToTriggerPopup() {
                return x(this, Xe);
              }
              addHighlightArea() {
                this.container.classList.add("highlightArea");
              }
            }
            Xe = new WeakMap();
            class f extends S {
              constructor(te) {
                super(te, {
                  isRenderable: !0,
                  ignoreBorder: !0
                });
                Ne(this, ct, null);
              }
              render() {
                this.container.classList.add("squareAnnotation");
                const te = this.data, {
                  width: we,
                  height: De
                } = B(te.rect), Ve = this.svgFactory.create(we, De, !0), Ye = te.borderStyle.width, Je = je(this, ct, this.svgFactory.createElement("svg:rect"));
                return Je.setAttribute("x", Ye / 2), Je.setAttribute("y", Ye / 2), Je.setAttribute("width", we - Ye), Je.setAttribute("height", De - Ye), Je.setAttribute("stroke-width", Ye || 1), Je.setAttribute("stroke", "transparent"), Je.setAttribute("fill", "transparent"), Ve.append(Je), this.container.append(Ve), !te.popupRef && this.hasPopupData && this._createPopup(), this.container;
              }
              getElementsToTriggerPopup() {
                return x(this, ct);
              }
              addHighlightArea() {
                this.container.classList.add("highlightArea");
              }
            }
            ct = new WeakMap();
            class C extends S {
              constructor(te) {
                super(te, {
                  isRenderable: !0,
                  ignoreBorder: !0
                });
                Ne(this, xt, null);
              }
              render() {
                this.container.classList.add("circleAnnotation");
                const te = this.data, {
                  width: we,
                  height: De
                } = B(te.rect), Ve = this.svgFactory.create(we, De, !0), Ye = te.borderStyle.width, Je = je(this, xt, this.svgFactory.createElement("svg:ellipse"));
                return Je.setAttribute("cx", we / 2), Je.setAttribute("cy", De / 2), Je.setAttribute("rx", we / 2 - Ye / 2), Je.setAttribute("ry", De / 2 - Ye / 2), Je.setAttribute("stroke-width", Ye || 1), Je.setAttribute("stroke", "transparent"), Je.setAttribute("fill", "transparent"), Ve.append(Je), this.container.append(Ve), !te.popupRef && this.hasPopupData && this._createPopup(), this.container;
              }
              getElementsToTriggerPopup() {
                return x(this, xt);
              }
              addHighlightArea() {
                this.container.classList.add("highlightArea");
              }
            }
            xt = new WeakMap();
            class R extends S {
              constructor(te) {
                super(te, {
                  isRenderable: !0,
                  ignoreBorder: !0
                });
                Ne(this, We, null);
                this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
              }
              render() {
                this.container.classList.add(this.containerClassName);
                const te = this.data, {
                  width: we,
                  height: De
                } = B(te.rect), Ve = this.svgFactory.create(we, De, !0);
                let Ye = [];
                for (const Pt of te.vertices) {
                  const mt = Pt.x - te.rect[0], pt = te.rect[3] - Pt.y;
                  Ye.push(mt + "," + pt);
                }
                Ye = Ye.join(" ");
                const Je = je(this, We, this.svgFactory.createElement(this.svgElementName));
                return Je.setAttribute("points", Ye), Je.setAttribute("stroke-width", te.borderStyle.width || 1), Je.setAttribute("stroke", "transparent"), Je.setAttribute("fill", "transparent"), Ve.append(Je), this.container.append(Ve), !te.popupRef && this.hasPopupData && this._createPopup(), this.container;
              }
              getElementsToTriggerPopup() {
                return x(this, We);
              }
              addHighlightArea() {
                this.container.classList.add("highlightArea");
              }
            }
            We = new WeakMap();
            class M extends R {
              constructor(ie) {
                super(ie), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
              }
            }
            class I extends S {
              constructor(ie) {
                super(ie, {
                  isRenderable: !0,
                  ignoreBorder: !0
                });
              }
              render() {
                return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
              }
            }
            class E extends S {
              constructor(te) {
                super(te, {
                  isRenderable: !0,
                  ignoreBorder: !0
                });
                Ne(this, Ce, []);
                this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = n.AnnotationEditorType.INK;
              }
              render() {
                this.container.classList.add(this.containerClassName);
                const te = this.data, {
                  width: we,
                  height: De
                } = B(te.rect), Ve = this.svgFactory.create(we, De, !0);
                for (const Ye of te.inkLists) {
                  let Je = [];
                  for (const mt of Ye) {
                    const pt = mt.x - te.rect[0], Ut = te.rect[3] - mt.y;
                    Je.push(`${pt},${Ut}`);
                  }
                  Je = Je.join(" ");
                  const Pt = this.svgFactory.createElement(this.svgElementName);
                  x(this, Ce).push(Pt), Pt.setAttribute("points", Je), Pt.setAttribute("stroke-width", te.borderStyle.width || 1), Pt.setAttribute("stroke", "transparent"), Pt.setAttribute("fill", "transparent"), !te.popupRef && this.hasPopupData && this._createPopup(), Ve.append(Pt);
                }
                return this.container.append(Ve), this.container;
              }
              getElementsToTriggerPopup() {
                return x(this, Ce);
              }
              addHighlightArea() {
                this.container.classList.add("highlightArea");
              }
            }
            Ce = new WeakMap(), L.InkAnnotationElement = E;
            class T extends S {
              constructor(ie) {
                super(ie, {
                  isRenderable: !0,
                  ignoreBorder: !0,
                  createQuadrilaterals: !0
                });
              }
              render() {
                return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container;
              }
            }
            class y extends S {
              constructor(ie) {
                super(ie, {
                  isRenderable: !0,
                  ignoreBorder: !0,
                  createQuadrilaterals: !0
                });
              }
              render() {
                return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
              }
            }
            class D extends S {
              constructor(ie) {
                super(ie, {
                  isRenderable: !0,
                  ignoreBorder: !0,
                  createQuadrilaterals: !0
                });
              }
              render() {
                return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
              }
            }
            class j extends S {
              constructor(ie) {
                super(ie, {
                  isRenderable: !0,
                  ignoreBorder: !0,
                  createQuadrilaterals: !0
                });
              }
              render() {
                return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
              }
            }
            class A extends S {
              constructor(ie) {
                super(ie, {
                  isRenderable: !0,
                  ignoreBorder: !0
                });
              }
              render() {
                return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
              }
            }
            L.StampAnnotationElement = A;
            class d extends S {
              constructor(te) {
                var Ve;
                super(te, {
                  isRenderable: !0
                });
                Ne(this, lt);
                Ne(this, Re, null);
                const {
                  filename: we,
                  content: De
                } = this.data.file;
                this.filename = (0, t.getFilenameFromUrl)(we, !0), this.content = De, (Ve = this.linkService.eventBus) == null || Ve.dispatch("fileattachmentannotation", {
                  source: this,
                  filename: we,
                  content: De
                });
              }
              render() {
                this.container.classList.add("fileAttachmentAnnotation");
                const {
                  container: te,
                  data: we
                } = this;
                let De;
                we.hasAppearance || we.fillAlpha === 0 ? De = document.createElement("div") : (De = document.createElement("img"), De.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(we.name) ? "paperclip" : "pushpin"}.svg`, we.fillAlpha && we.fillAlpha < 1 && (De.style = `filter: opacity(${Math.round(we.fillAlpha * 100)}%);`)), De.addEventListener("dblclick", Te(this, lt, Mi).bind(this)), je(this, Re, De);
                const {
                  isMac: Ve
                } = n.FeatureTest.platform;
                return te.addEventListener("keydown", (Ye) => {
                  Ye.key === "Enter" && (Ve ? Ye.metaKey : Ye.ctrlKey) && Te(this, lt, Mi).call(this);
                }), !we.popupRef && this.hasPopupData ? this._createPopup() : De.classList.add("popupTriggerArea"), te.append(De), te;
              }
              getElementsToTriggerPopup() {
                return x(this, Re);
              }
              addHighlightArea() {
                this.container.classList.add("highlightArea");
              }
            }
            Re = new WeakMap(), lt = new WeakSet(), Mi = function() {
              var te;
              (te = this.downloadManager) == null || te.openOrDownloadData(this.container, this.content, this.filename);
            };
            class _ {
              constructor({
                div: ie,
                accessibilityManager: te,
                annotationCanvasMap: we,
                l10n: De,
                page: Ve,
                viewport: Ye
              }) {
                Ne(this, at);
                Ne(this, Et, null);
                Ne(this, oe, null);
                Ne(this, He, /* @__PURE__ */ new Map());
                this.div = ie, je(this, Et, te), je(this, oe, we), this.l10n = De, this.page = Ve, this.viewport = Ye, this.zIndex = 0, this.l10n || (this.l10n = Q.NullL10n);
              }
              async render(ie) {
                const {
                  annotations: te
                } = ie, we = this.div;
                (0, t.setLayerDimensions)(we, this.viewport);
                const De = /* @__PURE__ */ new Map(), Ve = {
                  data: null,
                  layer: we,
                  linkService: ie.linkService,
                  downloadManager: ie.downloadManager,
                  imageResourcesPath: ie.imageResourcesPath || "",
                  renderForms: ie.renderForms !== !1,
                  svgFactory: new t.DOMSVGFactory(),
                  annotationStorage: ie.annotationStorage || new l.AnnotationStorage(),
                  enableScripting: ie.enableScripting === !0,
                  hasJSActions: ie.hasJSActions,
                  fieldObjects: ie.fieldObjects,
                  parent: this,
                  elements: null
                };
                for (const Ye of te) {
                  if (Ye.noHTML)
                    continue;
                  const Je = Ye.annotationType === n.AnnotationType.POPUP;
                  if (Je) {
                    const pt = De.get(Ye.id);
                    if (!pt)
                      continue;
                    Ve.elements = pt;
                  } else {
                    const {
                      width: pt,
                      height: Ut
                    } = B(Ye.rect);
                    if (pt <= 0 || Ut <= 0)
                      continue;
                  }
                  Ve.data = Ye;
                  const Pt = P.create(Ve);
                  if (!Pt.isRenderable)
                    continue;
                  if (!Je && Ye.popupRef) {
                    const pt = De.get(Ye.popupRef);
                    pt ? pt.push(Pt) : De.set(Ye.popupRef, [Pt]);
                  }
                  Pt.annotationEditorType > 0 && x(this, He).set(Pt.data.id, Pt);
                  const mt = Pt.render();
                  Ye.hidden && (mt.style.visibility = "hidden"), Te(this, at, mo).call(this, mt, Ye.id);
                }
                Te(this, at, Ri).call(this), await this.l10n.translate(we);
              }
              update({
                viewport: ie
              }) {
                const te = this.div;
                this.viewport = ie, (0, t.setLayerDimensions)(te, {
                  rotation: ie.rotation
                }), Te(this, at, Ri).call(this), te.hidden = !1;
              }
              getEditableAnnotations() {
                return Array.from(x(this, He).values());
              }
              getEditableAnnotation(ie) {
                return x(this, He).get(ie);
              }
            }
            Et = new WeakMap(), oe = new WeakMap(), He = new WeakMap(), at = new WeakSet(), mo = function(ie, te) {
              var De;
              const we = ie.firstChild || ie;
              we.id = `${n.AnnotationPrefix}${te}`, this.div.append(ie), (De = x(this, Et)) == null || De.moveElementInDOM(this.div, ie, we, !1);
            }, Ri = function() {
              if (!x(this, oe))
                return;
              const ie = this.div;
              for (const [te, we] of x(this, oe)) {
                const De = ie.querySelector(`[data-annotation-id="${te}"]`);
                if (!De)
                  continue;
                const {
                  firstChild: Ve
                } = De;
                Ve ? Ve.nodeName === "CANVAS" ? Ve.replaceWith(we) : Ve.before(we) : De.append(we);
              }
              x(this, oe).clear();
            }, L.AnnotationLayer = _;
          },
          /* 30 */
          /***/
          (e, L) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.ColorConverters = void 0;
            function p(l) {
              return Math.floor(Math.max(0, Math.min(1, l)) * 255).toString(16).padStart(2, "0");
            }
            function n(l) {
              return Math.max(0, Math.min(255, 255 * l));
            }
            class t {
              static CMYK_G([W, Q, G, X]) {
                return ["G", 1 - Math.min(1, 0.3 * W + 0.59 * G + 0.11 * Q + X)];
              }
              static G_CMYK([W]) {
                return ["CMYK", 0, 0, 0, 1 - W];
              }
              static G_RGB([W]) {
                return ["RGB", W, W, W];
              }
              static G_rgb([W]) {
                return W = n(W), [W, W, W];
              }
              static G_HTML([W]) {
                const Q = p(W);
                return `#${Q}${Q}${Q}`;
              }
              static RGB_G([W, Q, G]) {
                return ["G", 0.3 * W + 0.59 * Q + 0.11 * G];
              }
              static RGB_rgb(W) {
                return W.map(n);
              }
              static RGB_HTML(W) {
                return `#${W.map(p).join("")}`;
              }
              static T_HTML() {
                return "#00000000";
              }
              static T_rgb() {
                return [null];
              }
              static CMYK_RGB([W, Q, G, X]) {
                return ["RGB", 1 - Math.min(1, W + X), 1 - Math.min(1, G + X), 1 - Math.min(1, Q + X)];
              }
              static CMYK_rgb([W, Q, G, X]) {
                return [n(1 - Math.min(1, W + X)), n(1 - Math.min(1, G + X)), n(1 - Math.min(1, Q + X))];
              }
              static CMYK_HTML(W) {
                const Q = this.CMYK_RGB(W).slice(1);
                return this.RGB_HTML(Q);
              }
              static RGB_CMYK([W, Q, G]) {
                const X = 1 - W, N = 1 - Q, H = 1 - G, B = Math.min(X, N, H);
                return ["CMYK", X, N, H, B];
              }
            }
            L.ColorConverters = t;
          },
          /* 31 */
          /***/
          (e, L) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.NullL10n = void 0, L.getL10nFallback = n;
            const p = {
              of_pages: "of {{pagesCount}}",
              page_of_pages: "({{pageNumber}} of {{pagesCount}})",
              document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
              document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
              document_properties_date_string: "{{date}}, {{time}}",
              document_properties_page_size_unit_inches: "in",
              document_properties_page_size_unit_millimeters: "mm",
              document_properties_page_size_orientation_portrait: "portrait",
              document_properties_page_size_orientation_landscape: "landscape",
              document_properties_page_size_name_a3: "A3",
              document_properties_page_size_name_a4: "A4",
              document_properties_page_size_name_letter: "Letter",
              document_properties_page_size_name_legal: "Legal",
              document_properties_page_size_dimension_string: "{{width}} × {{height}} {{unit}} ({{orientation}})",
              document_properties_page_size_dimension_name_string: "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",
              document_properties_linearized_yes: "Yes",
              document_properties_linearized_no: "No",
              additional_layers: "Additional Layers",
              page_landmark: "Page {{page}}",
              thumb_page_title: "Page {{page}}",
              thumb_page_canvas: "Thumbnail of Page {{page}}",
              find_reached_top: "Reached top of document, continued from bottom",
              find_reached_bottom: "Reached end of document, continued from top",
              "find_match_count[one]": "{{current}} of {{total}} match",
              "find_match_count[other]": "{{current}} of {{total}} matches",
              "find_match_count_limit[one]": "More than {{limit}} match",
              "find_match_count_limit[other]": "More than {{limit}} matches",
              find_not_found: "Phrase not found",
              page_scale_width: "Page Width",
              page_scale_fit: "Page Fit",
              page_scale_auto: "Automatic Zoom",
              page_scale_actual: "Actual Size",
              page_scale_percent: "{{scale}}%",
              loading_error: "An error occurred while loading the PDF.",
              invalid_file_error: "Invalid or corrupted PDF file.",
              missing_file_error: "Missing PDF file.",
              unexpected_response_error: "Unexpected server response.",
              rendering_error: "An error occurred while rendering the page.",
              annotation_date_string: "{{date}}, {{time}}",
              printing_not_supported: "Warning: Printing is not fully supported by this browser.",
              printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
              web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.",
              free_text2_default_content: "Start typing…",
              editor_free_text2_aria_label: "Text Editor",
              editor_ink2_aria_label: "Draw Editor",
              editor_ink_canvas_aria_label: "User-created image",
              editor_alt_text_button_label: "Alt text",
              editor_alt_text_edit_button_label: "Edit alt text",
              editor_alt_text_decorative_tooltip: "Marked as decorative"
            };
            p.print_progress_percent = "{{progress}}%";
            function n(W, Q) {
              switch (W) {
                case "find_match_count":
                  W = `find_match_count[${Q.total === 1 ? "one" : "other"}]`;
                  break;
                case "find_match_count_limit":
                  W = `find_match_count_limit[${Q.limit === 1 ? "one" : "other"}]`;
                  break;
              }
              return p[W] || "";
            }
            function t(W, Q) {
              return Q ? W.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (G, X) => X in Q ? Q[X] : "{{" + X + "}}") : W;
            }
            const l = {
              async getLanguage() {
                return "en-us";
              },
              async getDirection() {
                return "ltr";
              },
              async get(W, Q = null, G = n(W, Q)) {
                return t(G, Q);
              },
              async translate(W) {
              }
            };
            L.NullL10n = l;
          },
          /* 32 */
          /***/
          (e, L, p) => {
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.XfaLayer = void 0;
            var n = p(25);
            class t {
              static setupStorage(W, Q, G, X, N) {
                const H = X.getValue(Q, {
                  value: null
                });
                switch (G.name) {
                  case "textarea":
                    if (H.value !== null && (W.textContent = H.value), N === "print")
                      break;
                    W.addEventListener("input", (B) => {
                      X.setValue(Q, {
                        value: B.target.value
                      });
                    });
                    break;
                  case "input":
                    if (G.attributes.type === "radio" || G.attributes.type === "checkbox") {
                      if (H.value === G.attributes.xfaOn ? W.setAttribute("checked", !0) : H.value === G.attributes.xfaOff && W.removeAttribute("checked"), N === "print")
                        break;
                      W.addEventListener("change", (B) => {
                        X.setValue(Q, {
                          value: B.target.checked ? B.target.getAttribute("xfaOn") : B.target.getAttribute("xfaOff")
                        });
                      });
                    } else {
                      if (H.value !== null && W.setAttribute("value", H.value), N === "print")
                        break;
                      W.addEventListener("input", (B) => {
                        X.setValue(Q, {
                          value: B.target.value
                        });
                      });
                    }
                    break;
                  case "select":
                    if (H.value !== null) {
                      W.setAttribute("value", H.value);
                      for (const B of G.children)
                        B.attributes.value === H.value ? B.attributes.selected = !0 : B.attributes.hasOwnProperty("selected") && delete B.attributes.selected;
                    }
                    W.addEventListener("input", (B) => {
                      const P = B.target.options, S = P.selectedIndex === -1 ? "" : P[P.selectedIndex].value;
                      X.setValue(Q, {
                        value: S
                      });
                    });
                    break;
                }
              }
              static setAttributes({
                html: W,
                element: Q,
                storage: G = null,
                intent: X,
                linkService: N
              }) {
                const {
                  attributes: H
                } = Q, B = W instanceof HTMLAnchorElement;
                H.type === "radio" && (H.name = `${H.name}-${X}`);
                for (const [P, S] of Object.entries(H))
                  if (S != null)
                    switch (P) {
                      case "class":
                        S.length && W.setAttribute(P, S.join(" "));
                        break;
                      case "dataId":
                        break;
                      case "id":
                        W.setAttribute("data-element-id", S);
                        break;
                      case "style":
                        Object.assign(W.style, S);
                        break;
                      case "textContent":
                        W.textContent = S;
                        break;
                      default:
                        (!B || P !== "href" && P !== "newWindow") && W.setAttribute(P, S);
                    }
                B && N.addLinkAttributes(W, H.href, H.newWindow), G && H.dataId && this.setupStorage(W, H.dataId, Q, G);
              }
              static render(W) {
                var r;
                const Q = W.annotationStorage, G = W.linkService, X = W.xfaHtml, N = W.intent || "display", H = document.createElement(X.name);
                X.attributes && this.setAttributes({
                  html: H,
                  element: X,
                  intent: N,
                  linkService: G
                });
                const B = [[X, -1, H]], P = W.div;
                if (P.append(H), W.viewport) {
                  const u = `matrix(${W.viewport.transform.join(",")})`;
                  P.style.transform = u;
                }
                N !== "richText" && P.setAttribute("class", "xfaLayer xfaFont");
                const S = [];
                for (; B.length > 0; ) {
                  const [u, m, s] = B.at(-1);
                  if (m + 1 === u.children.length) {
                    B.pop();
                    continue;
                  }
                  const w = u.children[++B.at(-1)[1]];
                  if (w === null)
                    continue;
                  const {
                    name: i
                  } = w;
                  if (i === "#text") {
                    const b = document.createTextNode(w.value);
                    S.push(b), s.append(b);
                    continue;
                  }
                  const o = (r = w == null ? void 0 : w.attributes) != null && r.xmlns ? document.createElementNS(w.attributes.xmlns, i) : document.createElement(i);
                  if (s.append(o), w.attributes && this.setAttributes({
                    html: o,
                    element: w,
                    storage: Q,
                    intent: N,
                    linkService: G
                  }), w.children && w.children.length > 0)
                    B.push([w, -1, o]);
                  else if (w.value) {
                    const b = document.createTextNode(w.value);
                    n.XfaText.shouldBuildText(i) && S.push(b), o.append(b);
                  }
                }
                for (const u of P.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
                  u.setAttribute("readOnly", !0);
                return {
                  textDivs: S
                };
              }
              static update(W) {
                const Q = `matrix(${W.viewport.transform.join(",")})`;
                W.div.style.transform = Q, W.div.hidden = !1;
              }
            }
            L.XfaLayer = t;
          },
          /* 33 */
          /***/
          (e, L, p) => {
            var X, N, H, B, P, S, r, u, m, s, w, i, o, b, g, po, go, vo, bo, Ti, Eo, Ai, _o, So, yo, wo, Po, Cr, xi, wa, Pa, qr, Li, Ca, V, Co, Ii, ko, Mo, Fi, ka, Wr;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.InkEditor = void 0;
            var n = p(1), t = p(4), l = p(29), W = p(6), Q = p(5);
            const qe = class qe extends t.AnnotationEditor {
              constructor(q) {
                super({
                  ...q,
                  name: "inkEditor"
                });
                Ne(this, g);
                Ne(this, X, 0);
                Ne(this, N, 0);
                Ne(this, H, this.canvasPointermove.bind(this));
                Ne(this, B, this.canvasPointerleave.bind(this));
                Ne(this, P, this.canvasPointerup.bind(this));
                Ne(this, S, this.canvasPointerdown.bind(this));
                Ne(this, r, new Path2D());
                Ne(this, u, !1);
                Ne(this, m, !1);
                Ne(this, s, !1);
                Ne(this, w, null);
                Ne(this, i, 0);
                Ne(this, o, 0);
                Ne(this, b, null);
                this.color = q.color || null, this.thickness = q.thickness || null, this.opacity = q.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
              }
              static initialize(q) {
                t.AnnotationEditor.initialize(q, {
                  strings: ["editor_ink_canvas_aria_label", "editor_ink2_aria_label"]
                });
              }
              static updateDefaultParams(q, Z) {
                switch (q) {
                  case n.AnnotationEditorParamsType.INK_THICKNESS:
                    qe._defaultThickness = Z;
                    break;
                  case n.AnnotationEditorParamsType.INK_COLOR:
                    qe._defaultColor = Z;
                    break;
                  case n.AnnotationEditorParamsType.INK_OPACITY:
                    qe._defaultOpacity = Z / 100;
                    break;
                }
              }
              updateParams(q, Z) {
                switch (q) {
                  case n.AnnotationEditorParamsType.INK_THICKNESS:
                    Te(this, g, po).call(this, Z);
                    break;
                  case n.AnnotationEditorParamsType.INK_COLOR:
                    Te(this, g, go).call(this, Z);
                    break;
                  case n.AnnotationEditorParamsType.INK_OPACITY:
                    Te(this, g, vo).call(this, Z);
                    break;
                }
              }
              static get defaultPropertiesToUpdate() {
                return [[n.AnnotationEditorParamsType.INK_THICKNESS, qe._defaultThickness], [n.AnnotationEditorParamsType.INK_COLOR, qe._defaultColor || t.AnnotationEditor._defaultLineColor], [n.AnnotationEditorParamsType.INK_OPACITY, Math.round(qe._defaultOpacity * 100)]];
              }
              get propertiesToUpdate() {
                return [[n.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || qe._defaultThickness], [n.AnnotationEditorParamsType.INK_COLOR, this.color || qe._defaultColor || t.AnnotationEditor._defaultLineColor], [n.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? qe._defaultOpacity))]];
              }
              rebuild() {
                this.parent && (super.rebuild(), this.div !== null && (this.canvas || (Te(this, g, wa).call(this), Te(this, g, Pa).call(this)), this.isAttachedToDOM || (this.parent.add(this), Te(this, g, qr).call(this)), Te(this, g, Wr).call(this)));
              }
              remove() {
                this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, x(this, w).disconnect(), je(this, w, null), super.remove());
              }
              setParent(q) {
                !this.parent && q ? this._uiManager.removeShouldRescale(this) : this.parent && q === null && this._uiManager.addShouldRescale(this), super.setParent(q);
              }
              onScaleChanging() {
                const [q, Z] = this.parentDimensions, pe = this.width * q, me = this.height * Z;
                this.setDimensions(pe, me);
              }
              enableEditMode() {
                x(this, u) || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", x(this, S)));
              }
              disableEditMode() {
                !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", x(this, S)));
              }
              onceAdded() {
                this._isDraggable = !this.isEmpty();
              }
              isEmpty() {
                return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
              }
              commit() {
                x(this, u) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), je(this, u, !0), this.div.classList.add("disabled"), Te(this, g, Wr).call(this, !0), this.makeResizable(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
                  preventScroll: !0
                }));
              }
              focusin(q) {
                this._focusEventsAllowed && (super.focusin(q), this.enableEditMode());
              }
              canvasPointerdown(q) {
                q.button !== 0 || !this.isInEditMode() || x(this, u) || (this.setInForeground(), q.preventDefault(), q.type !== "mouse" && this.div.focus(), Te(this, g, Eo).call(this, q.offsetX, q.offsetY));
              }
              canvasPointermove(q) {
                q.preventDefault(), Te(this, g, Ai).call(this, q.offsetX, q.offsetY);
              }
              canvasPointerup(q) {
                q.preventDefault(), Te(this, g, xi).call(this, q);
              }
              canvasPointerleave(q) {
                Te(this, g, xi).call(this, q);
              }
              get isResizable() {
                return !this.isEmpty() && x(this, u);
              }
              render() {
                if (this.div)
                  return this.div;
                let q, Z;
                this.width && (q = this.x, Z = this.y), super.render(), t.AnnotationEditor._l10nPromise.get("editor_ink2_aria_label").then((ke) => {
                  var de;
                  return (de = this.div) == null ? void 0 : de.setAttribute("aria-label", ke);
                });
                const [pe, me, _e, Be] = Te(this, g, bo).call(this);
                if (this.setAt(pe, me, 0, 0), this.setDims(_e, Be), Te(this, g, wa).call(this), this.width) {
                  const [ke, de] = this.parentDimensions;
                  this.setAspectRatio(this.width * ke, this.height * de), this.setAt(q * ke, Z * de, this.width * ke, this.height * de), je(this, s, !0), Te(this, g, qr).call(this), this.setDims(this.width * ke, this.height * de), Te(this, g, Cr).call(this), this.div.classList.add("disabled");
                } else
                  this.div.classList.add("editing"), this.enableEditMode();
                return Te(this, g, Pa).call(this), this.div;
              }
              setDimensions(q, Z) {
                const pe = Math.round(q), me = Math.round(Z);
                if (x(this, i) === pe && x(this, o) === me)
                  return;
                je(this, i, pe), je(this, o, me), this.canvas.style.visibility = "hidden";
                const [_e, Be] = this.parentDimensions;
                this.width = q / _e, this.height = Z / Be, this.fixAndSetPosition(), x(this, u) && Te(this, g, Li).call(this, q, Z), Te(this, g, qr).call(this), Te(this, g, Cr).call(this), this.canvas.style.visibility = "visible", this.fixDims();
              }
              static deserialize(q, Z, pe) {
                var Xe, ct, xt;
                if (q instanceof l.InkAnnotationElement)
                  return null;
                const me = super.deserialize(q, Z, pe);
                me.thickness = q.thickness, me.color = n.Util.makeHexColor(...q.color), me.opacity = q.opacity;
                const [_e, Be] = me.pageDimensions, ke = me.width * _e, de = me.height * Be, $e = me.parentScale, Ge = q.thickness / 2;
                je(me, u, !0), je(me, i, Math.round(ke)), je(me, o, Math.round(de));
                const {
                  paths: st,
                  rect: it,
                  rotation: _t
                } = q;
                for (let {
                  bezier: We
                } of st) {
                  We = Te(Xe = qe, V, ko).call(Xe, We, it, _t);
                  const Ce = [];
                  me.paths.push(Ce);
                  let Re = $e * (We[0] - Ge), lt = $e * (We[1] - Ge);
                  for (let Et = 2, oe = We.length; Et < oe; Et += 6) {
                    const He = $e * (We[Et] - Ge), at = $e * (We[Et + 1] - Ge), St = $e * (We[Et + 2] - Ge), yt = $e * (We[Et + 3] - Ge), dt = $e * (We[Et + 4] - Ge), ie = $e * (We[Et + 5] - Ge);
                    Ce.push([[Re, lt], [He, at], [St, yt], [dt, ie]]), Re = dt, lt = ie;
                  }
                  const bt = Te(this, V, Co).call(this, Ce);
                  me.bezierPath2D.push(bt);
                }
                const tt = Te(ct = me, g, Fi).call(ct);
                return je(me, N, Math.max(t.AnnotationEditor.MIN_SIZE, tt[2] - tt[0])), je(me, X, Math.max(t.AnnotationEditor.MIN_SIZE, tt[3] - tt[1])), Te(xt = me, g, Li).call(xt, ke, de), me;
              }
              serialize() {
                if (this.isEmpty())
                  return null;
                const q = this.getRect(0, 0), Z = t.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
                return {
                  annotationType: n.AnnotationEditorType.INK,
                  color: Z,
                  thickness: this.thickness,
                  opacity: this.opacity,
                  paths: Te(this, g, Mo).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, q),
                  pageIndex: this.pageIndex,
                  rect: q,
                  rotation: this.rotation,
                  structTreeParentId: this._structTreeParentId
                };
              }
            };
            X = new WeakMap(), N = new WeakMap(), H = new WeakMap(), B = new WeakMap(), P = new WeakMap(), S = new WeakMap(), r = new WeakMap(), u = new WeakMap(), m = new WeakMap(), s = new WeakMap(), w = new WeakMap(), i = new WeakMap(), o = new WeakMap(), b = new WeakMap(), g = new WeakSet(), po = function(q) {
              const Z = this.thickness;
              this.addCommands({
                cmd: () => {
                  this.thickness = q, Te(this, g, Wr).call(this);
                },
                undo: () => {
                  this.thickness = Z, Te(this, g, Wr).call(this);
                },
                mustExec: !0,
                type: n.AnnotationEditorParamsType.INK_THICKNESS,
                overwriteIfSameType: !0,
                keepUndo: !0
              });
            }, go = function(q) {
              const Z = this.color;
              this.addCommands({
                cmd: () => {
                  this.color = q, Te(this, g, Cr).call(this);
                },
                undo: () => {
                  this.color = Z, Te(this, g, Cr).call(this);
                },
                mustExec: !0,
                type: n.AnnotationEditorParamsType.INK_COLOR,
                overwriteIfSameType: !0,
                keepUndo: !0
              });
            }, vo = function(q) {
              q /= 100;
              const Z = this.opacity;
              this.addCommands({
                cmd: () => {
                  this.opacity = q, Te(this, g, Cr).call(this);
                },
                undo: () => {
                  this.opacity = Z, Te(this, g, Cr).call(this);
                },
                mustExec: !0,
                type: n.AnnotationEditorParamsType.INK_OPACITY,
                overwriteIfSameType: !0,
                keepUndo: !0
              });
            }, bo = function() {
              const {
                parentRotation: q,
                parentDimensions: [Z, pe]
              } = this;
              switch (q) {
                case 90:
                  return [0, pe, pe, Z];
                case 180:
                  return [Z, pe, Z, pe];
                case 270:
                  return [Z, 0, pe, Z];
                default:
                  return [0, 0, Z, pe];
              }
            }, Ti = function() {
              const {
                ctx: q,
                color: Z,
                opacity: pe,
                thickness: me,
                parentScale: _e,
                scaleFactor: Be
              } = this;
              q.lineWidth = me * _e / Be, q.lineCap = "round", q.lineJoin = "round", q.miterLimit = 10, q.strokeStyle = `${Z}${(0, Q.opacityToHex)(pe)}`;
            }, Eo = function(q, Z) {
              this.canvas.addEventListener("contextmenu", W.noContextMenu), this.canvas.addEventListener("pointerleave", x(this, B)), this.canvas.addEventListener("pointermove", x(this, H)), this.canvas.addEventListener("pointerup", x(this, P)), this.canvas.removeEventListener("pointerdown", x(this, S)), this.isEditing = !0, x(this, s) || (je(this, s, !0), Te(this, g, qr).call(this), this.thickness || (this.thickness = qe._defaultThickness), this.color || (this.color = qe._defaultColor || t.AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = qe._defaultOpacity)), this.currentPath.push([q, Z]), je(this, m, !1), Te(this, g, Ti).call(this), je(this, b, () => {
                Te(this, g, yo).call(this), x(this, b) && window.requestAnimationFrame(x(this, b));
              }), window.requestAnimationFrame(x(this, b));
            }, Ai = function(q, Z) {
              const [pe, me] = this.currentPath.at(-1);
              if (this.currentPath.length > 1 && q === pe && Z === me)
                return;
              const _e = this.currentPath;
              let Be = x(this, r);
              if (_e.push([q, Z]), je(this, m, !0), _e.length <= 2) {
                Be.moveTo(..._e[0]), Be.lineTo(q, Z);
                return;
              }
              _e.length === 3 && (je(this, r, Be = new Path2D()), Be.moveTo(..._e[0])), Te(this, g, wo).call(this, Be, ..._e.at(-3), ..._e.at(-2), q, Z);
            }, _o = function() {
              if (this.currentPath.length === 0)
                return;
              const q = this.currentPath.at(-1);
              x(this, r).lineTo(...q);
            }, So = function(q, Z) {
              je(this, b, null), q = Math.min(Math.max(q, 0), this.canvas.width), Z = Math.min(Math.max(Z, 0), this.canvas.height), Te(this, g, Ai).call(this, q, Z), Te(this, g, _o).call(this);
              let pe;
              if (this.currentPath.length !== 1)
                pe = Te(this, g, Po).call(this);
              else {
                const de = [q, Z];
                pe = [[de, de.slice(), de.slice(), de]];
              }
              const me = x(this, r), _e = this.currentPath;
              this.currentPath = [], je(this, r, new Path2D());
              const Be = () => {
                this.allRawPaths.push(_e), this.paths.push(pe), this.bezierPath2D.push(me), this.rebuild();
              }, ke = () => {
                this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (Te(this, g, wa).call(this), Te(this, g, Pa).call(this)), Te(this, g, Wr).call(this));
              };
              this.addCommands({
                cmd: Be,
                undo: ke,
                mustExec: !0
              });
            }, yo = function() {
              if (!x(this, m))
                return;
              je(this, m, !1);
              const q = Math.ceil(this.thickness * this.parentScale), Z = this.currentPath.slice(-3), pe = Z.map((Be) => Be[0]), me = Z.map((Be) => Be[1]);
              Math.min(...pe) - q, Math.max(...pe) + q, Math.min(...me) - q, Math.max(...me) + q;
              const {
                ctx: _e
              } = this;
              _e.save(), _e.clearRect(0, 0, this.canvas.width, this.canvas.height);
              for (const Be of this.bezierPath2D)
                _e.stroke(Be);
              _e.stroke(x(this, r)), _e.restore();
            }, wo = function(q, Z, pe, me, _e, Be, ke) {
              const de = (Z + me) / 2, $e = (pe + _e) / 2, Ge = (me + Be) / 2, st = (_e + ke) / 2;
              q.bezierCurveTo(de + 2 * (me - de) / 3, $e + 2 * (_e - $e) / 3, Ge + 2 * (me - Ge) / 3, st + 2 * (_e - st) / 3, Ge, st);
            }, Po = function() {
              const q = this.currentPath;
              if (q.length <= 2)
                return [[q[0], q[0], q.at(-1), q.at(-1)]];
              const Z = [];
              let pe, [me, _e] = q[0];
              for (pe = 1; pe < q.length - 2; pe++) {
                const [it, _t] = q[pe], [tt, Xe] = q[pe + 1], ct = (it + tt) / 2, xt = (_t + Xe) / 2, We = [me + 2 * (it - me) / 3, _e + 2 * (_t - _e) / 3], Ce = [ct + 2 * (it - ct) / 3, xt + 2 * (_t - xt) / 3];
                Z.push([[me, _e], We, Ce, [ct, xt]]), [me, _e] = [ct, xt];
              }
              const [Be, ke] = q[pe], [de, $e] = q[pe + 1], Ge = [me + 2 * (Be - me) / 3, _e + 2 * (ke - _e) / 3], st = [de + 2 * (Be - de) / 3, $e + 2 * (ke - $e) / 3];
              return Z.push([[me, _e], Ge, st, [de, $e]]), Z;
            }, Cr = function() {
              if (this.isEmpty()) {
                Te(this, g, Ca).call(this);
                return;
              }
              Te(this, g, Ti).call(this);
              const {
                canvas: q,
                ctx: Z
              } = this;
              Z.setTransform(1, 0, 0, 1, 0, 0), Z.clearRect(0, 0, q.width, q.height), Te(this, g, Ca).call(this);
              for (const pe of this.bezierPath2D)
                Z.stroke(pe);
            }, xi = function(q) {
              this.canvas.removeEventListener("pointerleave", x(this, B)), this.canvas.removeEventListener("pointermove", x(this, H)), this.canvas.removeEventListener("pointerup", x(this, P)), this.canvas.addEventListener("pointerdown", x(this, S)), setTimeout(() => {
                this.canvas.removeEventListener("contextmenu", W.noContextMenu);
              }, 10), Te(this, g, So).call(this, q.offsetX, q.offsetY), this.addToAnnotationStorage(), this.setInBackground();
            }, wa = function() {
              this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", t.AnnotationEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((q) => {
                var Z;
                return (Z = this.canvas) == null ? void 0 : Z.setAttribute("aria-label", q);
              }), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
            }, Pa = function() {
              je(this, w, new ResizeObserver((q) => {
                const Z = q[0].contentRect;
                Z.width && Z.height && this.setDimensions(Z.width, Z.height);
              })), x(this, w).observe(this.div);
            }, qr = function() {
              if (!x(this, s))
                return;
              const [q, Z] = this.parentDimensions;
              this.canvas.width = Math.ceil(this.width * q), this.canvas.height = Math.ceil(this.height * Z), Te(this, g, Ca).call(this);
            }, Li = function(q, Z) {
              const pe = Te(this, g, ka).call(this), me = (q - pe) / x(this, N), _e = (Z - pe) / x(this, X);
              this.scaleFactor = Math.min(me, _e);
            }, Ca = function() {
              const q = Te(this, g, ka).call(this) / 2;
              this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + q, this.translationY * this.scaleFactor + q);
            }, V = new WeakSet(), Co = function(q) {
              const Z = new Path2D();
              for (let pe = 0, me = q.length; pe < me; pe++) {
                const [_e, Be, ke, de] = q[pe];
                pe === 0 && Z.moveTo(..._e), Z.bezierCurveTo(Be[0], Be[1], ke[0], ke[1], de[0], de[1]);
              }
              return Z;
            }, Ii = function(q, Z, pe) {
              const [me, _e, Be, ke] = Z;
              switch (pe) {
                case 0:
                  for (let de = 0, $e = q.length; de < $e; de += 2)
                    q[de] += me, q[de + 1] = ke - q[de + 1];
                  break;
                case 90:
                  for (let de = 0, $e = q.length; de < $e; de += 2) {
                    const Ge = q[de];
                    q[de] = q[de + 1] + me, q[de + 1] = Ge + _e;
                  }
                  break;
                case 180:
                  for (let de = 0, $e = q.length; de < $e; de += 2)
                    q[de] = Be - q[de], q[de + 1] += _e;
                  break;
                case 270:
                  for (let de = 0, $e = q.length; de < $e; de += 2) {
                    const Ge = q[de];
                    q[de] = Be - q[de + 1], q[de + 1] = ke - Ge;
                  }
                  break;
                default:
                  throw new Error("Invalid rotation");
              }
              return q;
            }, ko = function(q, Z, pe) {
              const [me, _e, Be, ke] = Z;
              switch (pe) {
                case 0:
                  for (let de = 0, $e = q.length; de < $e; de += 2)
                    q[de] -= me, q[de + 1] = ke - q[de + 1];
                  break;
                case 90:
                  for (let de = 0, $e = q.length; de < $e; de += 2) {
                    const Ge = q[de];
                    q[de] = q[de + 1] - _e, q[de + 1] = Ge - me;
                  }
                  break;
                case 180:
                  for (let de = 0, $e = q.length; de < $e; de += 2)
                    q[de] = Be - q[de], q[de + 1] -= _e;
                  break;
                case 270:
                  for (let de = 0, $e = q.length; de < $e; de += 2) {
                    const Ge = q[de];
                    q[de] = ke - q[de + 1], q[de + 1] = Be - Ge;
                  }
                  break;
                default:
                  throw new Error("Invalid rotation");
              }
              return q;
            }, Mo = function(q, Z, pe, me) {
              var $e, Ge;
              const _e = [], Be = this.thickness / 2, ke = q * Z + Be, de = q * pe + Be;
              for (const st of this.paths) {
                const it = [], _t = [];
                for (let tt = 0, Xe = st.length; tt < Xe; tt++) {
                  const [ct, xt, We, Ce] = st[tt], Re = q * ct[0] + ke, lt = q * ct[1] + de, bt = q * xt[0] + ke, Et = q * xt[1] + de, oe = q * We[0] + ke, He = q * We[1] + de, at = q * Ce[0] + ke, St = q * Ce[1] + de;
                  tt === 0 && (it.push(Re, lt), _t.push(Re, lt)), it.push(bt, Et, oe, He, at, St), _t.push(bt, Et), tt === Xe - 1 && _t.push(at, St);
                }
                _e.push({
                  bezier: Te($e = qe, V, Ii).call($e, it, me, this.rotation),
                  points: Te(Ge = qe, V, Ii).call(Ge, _t, me, this.rotation)
                });
              }
              return _e;
            }, Fi = function() {
              let q = 1 / 0, Z = -1 / 0, pe = 1 / 0, me = -1 / 0;
              for (const _e of this.paths)
                for (const [Be, ke, de, $e] of _e) {
                  const Ge = n.Util.bezierBoundingBox(...Be, ...ke, ...de, ...$e);
                  q = Math.min(q, Ge[0]), pe = Math.min(pe, Ge[1]), Z = Math.max(Z, Ge[2]), me = Math.max(me, Ge[3]);
                }
              return [q, pe, Z, me];
            }, ka = function() {
              return x(this, u) ? Math.ceil(this.thickness * this.parentScale) : 0;
            }, Wr = function(q = !1) {
              if (this.isEmpty())
                return;
              if (!x(this, u)) {
                Te(this, g, Cr).call(this);
                return;
              }
              const Z = Te(this, g, Fi).call(this), pe = Te(this, g, ka).call(this);
              je(this, N, Math.max(t.AnnotationEditor.MIN_SIZE, Z[2] - Z[0])), je(this, X, Math.max(t.AnnotationEditor.MIN_SIZE, Z[3] - Z[1]));
              const me = Math.ceil(pe + x(this, N) * this.scaleFactor), _e = Math.ceil(pe + x(this, X) * this.scaleFactor), [Be, ke] = this.parentDimensions;
              this.width = me / Be, this.height = _e / ke, this.setAspectRatio(me, _e);
              const de = this.translationX, $e = this.translationY;
              this.translationX = -Z[0], this.translationY = -Z[1], Te(this, g, qr).call(this), Te(this, g, Cr).call(this), je(this, i, me), je(this, o, _e), this.setDims(me, _e);
              const Ge = q ? pe / this.scaleFactor / 2 : 0;
              this.translate(de - this.translationX - Ge, $e - this.translationY - Ge);
            }, Ne(qe, V), Tn(qe, "_defaultColor", null), Tn(qe, "_defaultOpacity", 1), Tn(qe, "_defaultThickness", 1), Tn(qe, "_type", "ink");
            let G = qe;
            L.InkEditor = G;
          },
          /* 34 */
          /***/
          (e, L, p) => {
            var G, X, N, H, B, P, S, r, u, m, s, ra, aa, Ma, Di, Ro, To, Oi, Ra, Ao;
            Object.defineProperty(L, "__esModule", {
              value: !0
            }), L.StampEditor = void 0;
            var n = p(1), t = p(4), l = p(6), W = p(29);
            const f = class f extends t.AnnotationEditor {
              constructor(M) {
                super({
                  ...M,
                  name: "stampEditor"
                });
                Ne(this, s);
                Ne(this, G, null);
                Ne(this, X, null);
                Ne(this, N, null);
                Ne(this, H, null);
                Ne(this, B, null);
                Ne(this, P, null);
                Ne(this, S, null);
                Ne(this, r, null);
                Ne(this, u, !1);
                Ne(this, m, !1);
                je(this, H, M.bitmapUrl), je(this, B, M.bitmapFile);
              }
              static initialize(M) {
                t.AnnotationEditor.initialize(M);
              }
              static get supportedTypes() {
                const M = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
                return (0, n.shadow)(this, "supportedTypes", M.map((I) => `image/${I}`));
              }
              static get supportedTypesStr() {
                return (0, n.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
              }
              static isHandlingMimeForPasting(M) {
                return this.supportedTypes.includes(M);
              }
              static paste(M, I) {
                I.pasteEditor(n.AnnotationEditorType.STAMP, {
                  bitmapFile: M.getAsFile()
                });
              }
              remove() {
                var M, I;
                x(this, X) && (je(this, G, null), this._uiManager.imageManager.deleteId(x(this, X)), (M = x(this, P)) == null || M.remove(), je(this, P, null), (I = x(this, S)) == null || I.disconnect(), je(this, S, null)), super.remove();
              }
              rebuild() {
                if (!this.parent) {
                  x(this, X) && Te(this, s, Ma).call(this);
                  return;
                }
                super.rebuild(), this.div !== null && (x(this, X) && Te(this, s, Ma).call(this), this.isAttachedToDOM || this.parent.add(this));
              }
              onceAdded() {
                this._isDraggable = !0, this.div.focus();
              }
              isEmpty() {
                return !(x(this, N) || x(this, G) || x(this, H) || x(this, B));
              }
              get isResizable() {
                return !0;
              }
              render() {
                if (this.div)
                  return this.div;
                let M, I;
                if (this.width && (M = this.x, I = this.y), super.render(), this.div.hidden = !0, x(this, G) ? Te(this, s, Di).call(this) : Te(this, s, Ma).call(this), this.width) {
                  const [E, T] = this.parentDimensions;
                  this.setAt(M * E, I * T, this.width * E, this.height * T);
                }
                return this.div;
              }
              static deserialize(M, I, E) {
                if (M instanceof W.StampAnnotationElement)
                  return null;
                const T = super.deserialize(M, I, E), {
                  rect: y,
                  bitmapUrl: D,
                  bitmapId: j,
                  isSvg: A,
                  accessibilityData: d
                } = M;
                j && E.imageManager.isValidId(j) ? je(T, X, j) : je(T, H, D), je(T, u, A);
                const [_, F] = T.pageDimensions;
                return T.width = (y[2] - y[0]) / _, T.height = (y[3] - y[1]) / F, d && (T.altTextData = d), T;
              }
              serialize(M = !1, I = null) {
                if (this.isEmpty())
                  return null;
                const E = {
                  annotationType: n.AnnotationEditorType.STAMP,
                  bitmapId: x(this, X),
                  pageIndex: this.pageIndex,
                  rect: this.getRect(0, 0),
                  rotation: this.rotation,
                  isSvg: x(this, u),
                  structTreeParentId: this._structTreeParentId
                };
                if (M)
                  return E.bitmapUrl = Te(this, s, Ra).call(this, !0), E.accessibilityData = this.altTextData, E;
                const {
                  decorative: T,
                  altText: y
                } = this.altTextData;
                if (!T && y && (E.accessibilityData = {
                  type: "Figure",
                  alt: y
                }), I === null)
                  return E;
                I.stamps || (I.stamps = /* @__PURE__ */ new Map());
                const D = x(this, u) ? (E.rect[2] - E.rect[0]) * (E.rect[3] - E.rect[1]) : null;
                if (!I.stamps.has(x(this, X)))
                  I.stamps.set(x(this, X), {
                    area: D,
                    serialized: E
                  }), E.bitmap = Te(this, s, Ra).call(this, !1);
                else if (x(this, u)) {
                  const j = I.stamps.get(x(this, X));
                  D > j.area && (j.area = D, j.serialized.bitmap.close(), j.serialized.bitmap = Te(this, s, Ra).call(this, !1));
                }
                return E;
              }
            };
            G = new WeakMap(), X = new WeakMap(), N = new WeakMap(), H = new WeakMap(), B = new WeakMap(), P = new WeakMap(), S = new WeakMap(), r = new WeakMap(), u = new WeakMap(), m = new WeakMap(), s = new WeakSet(), ra = function(M, I = !1) {
              if (!M) {
                this.remove();
                return;
              }
              je(this, G, M.bitmap), I || (je(this, X, M.id), je(this, u, M.isSvg)), Te(this, s, Di).call(this);
            }, aa = function() {
              je(this, N, null), this._uiManager.enableWaiting(!1), x(this, P) && this.div.focus();
            }, Ma = function() {
              if (x(this, X)) {
                this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(x(this, X)).then((I) => Te(this, s, ra).call(this, I, !0)).finally(() => Te(this, s, aa).call(this));
                return;
              }
              if (x(this, H)) {
                const I = x(this, H);
                je(this, H, null), this._uiManager.enableWaiting(!0), je(this, N, this._uiManager.imageManager.getFromUrl(I).then((E) => Te(this, s, ra).call(this, E)).finally(() => Te(this, s, aa).call(this)));
                return;
              }
              if (x(this, B)) {
                const I = x(this, B);
                je(this, B, null), this._uiManager.enableWaiting(!0), je(this, N, this._uiManager.imageManager.getFromFile(I).then((E) => Te(this, s, ra).call(this, E)).finally(() => Te(this, s, aa).call(this)));
                return;
              }
              const M = document.createElement("input");
              M.type = "file", M.accept = f.supportedTypesStr, je(this, N, new Promise((I) => {
                M.addEventListener("change", async () => {
                  if (!M.files || M.files.length === 0)
                    this.remove();
                  else {
                    this._uiManager.enableWaiting(!0);
                    const E = await this._uiManager.imageManager.getFromFile(M.files[0]);
                    Te(this, s, ra).call(this, E);
                  }
                  I();
                }), M.addEventListener("cancel", () => {
                  this.remove(), I();
                });
              }).finally(() => Te(this, s, aa).call(this))), M.click();
            }, Di = function() {
              const {
                div: M
              } = this;
              let {
                width: I,
                height: E
              } = x(this, G);
              const [T, y] = this.pageDimensions, D = 0.75;
              if (this.width)
                I = this.width * T, E = this.height * y;
              else if (I > D * T || E > D * y) {
                const _ = Math.min(D * T / I, D * y / E);
                I *= _, E *= _;
              }
              const [j, A] = this.parentDimensions;
              this.setDims(I * j / T, E * A / y), this._uiManager.enableWaiting(!1);
              const d = je(this, P, document.createElement("canvas"));
              M.append(d), M.hidden = !1, Te(this, s, Oi).call(this, I, E), Te(this, s, Ao).call(this), x(this, m) || (this.parent.addUndoableEditor(this), je(this, m, !0)), this._uiManager._eventBus.dispatch("reporttelemetry", {
                source: this,
                details: {
                  type: "editing",
                  subtype: this.editorType,
                  data: {
                    action: "inserted_image"
                  }
                }
              }), this.addAltTextButton();
            }, Ro = function(M, I) {
              var D;
              const [E, T] = this.parentDimensions;
              this.width = M / E, this.height = I / T, this.setDims(M, I), (D = this._initialOptions) != null && D.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, x(this, r) !== null && clearTimeout(x(this, r)), je(this, r, setTimeout(() => {
                je(this, r, null), Te(this, s, Oi).call(this, M, I);
              }, 200));
            }, To = function(M, I) {
              const {
                width: E,
                height: T
              } = x(this, G);
              let y = E, D = T, j = x(this, G);
              for (; y > 2 * M || D > 2 * I; ) {
                const A = y, d = D;
                y > 2 * M && (y = y >= 16384 ? Math.floor(y / 2) - 1 : Math.ceil(y / 2)), D > 2 * I && (D = D >= 16384 ? Math.floor(D / 2) - 1 : Math.ceil(D / 2));
                const _ = new OffscreenCanvas(y, D);
                _.getContext("2d").drawImage(j, 0, 0, A, d, 0, 0, y, D), j = _.transferToImageBitmap();
              }
              return j;
            }, Oi = function(M, I) {
              M = Math.ceil(M), I = Math.ceil(I);
              const E = x(this, P);
              if (!E || E.width === M && E.height === I)
                return;
              E.width = M, E.height = I;
              const T = x(this, u) ? x(this, G) : Te(this, s, To).call(this, M, I), y = E.getContext("2d");
              y.filter = this._uiManager.hcmFilter, y.drawImage(T, 0, 0, T.width, T.height, 0, 0, M, I);
            }, Ra = function(M) {
              if (M) {
                if (x(this, u)) {
                  const T = this._uiManager.imageManager.getSvgUrl(x(this, X));
                  if (T)
                    return T;
                }
                const I = document.createElement("canvas");
                return {
                  width: I.width,
                  height: I.height
                } = x(this, G), I.getContext("2d").drawImage(x(this, G), 0, 0), I.toDataURL();
              }
              if (x(this, u)) {
                const [I, E] = this.pageDimensions, T = Math.round(this.width * I * l.PixelsPerInch.PDF_TO_CSS_UNITS), y = Math.round(this.height * E * l.PixelsPerInch.PDF_TO_CSS_UNITS), D = new OffscreenCanvas(T, y);
                return D.getContext("2d").drawImage(x(this, G), 0, 0, x(this, G).width, x(this, G).height, 0, 0, T, y), D.transferToImageBitmap();
              }
              return structuredClone(x(this, G));
            }, Ao = function() {
              je(this, S, new ResizeObserver((M) => {
                const I = M[0].contentRect;
                I.width && I.height && Te(this, s, Ro).call(this, I.width, I.height);
              })), x(this, S).observe(this.div);
            }, Tn(f, "_type", "stamp");
            let Q = f;
            L.StampEditor = Q;
          }
          /******/
        ], __webpack_module_cache__ = {};
        function __w_pdfjs_require__(e) {
          var L = __webpack_module_cache__[e];
          if (L !== void 0)
            return L.exports;
          var p = __webpack_module_cache__[e] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          return __webpack_modules__[e](p, p.exports, __w_pdfjs_require__), p.exports;
        }
        var __webpack_exports__ = {};
        return (() => {
          var e = __webpack_exports__;
          Object.defineProperty(e, "__esModule", {
            value: !0
          }), Object.defineProperty(e, "AbortException", {
            enumerable: !0,
            get: function() {
              return L.AbortException;
            }
          }), Object.defineProperty(e, "AnnotationEditorLayer", {
            enumerable: !0,
            get: function() {
              return l.AnnotationEditorLayer;
            }
          }), Object.defineProperty(e, "AnnotationEditorParamsType", {
            enumerable: !0,
            get: function() {
              return L.AnnotationEditorParamsType;
            }
          }), Object.defineProperty(e, "AnnotationEditorType", {
            enumerable: !0,
            get: function() {
              return L.AnnotationEditorType;
            }
          }), Object.defineProperty(e, "AnnotationEditorUIManager", {
            enumerable: !0,
            get: function() {
              return W.AnnotationEditorUIManager;
            }
          }), Object.defineProperty(e, "AnnotationLayer", {
            enumerable: !0,
            get: function() {
              return Q.AnnotationLayer;
            }
          }), Object.defineProperty(e, "AnnotationMode", {
            enumerable: !0,
            get: function() {
              return L.AnnotationMode;
            }
          }), Object.defineProperty(e, "CMapCompressionType", {
            enumerable: !0,
            get: function() {
              return L.CMapCompressionType;
            }
          }), Object.defineProperty(e, "DOMSVGFactory", {
            enumerable: !0,
            get: function() {
              return n.DOMSVGFactory;
            }
          }), Object.defineProperty(e, "FeatureTest", {
            enumerable: !0,
            get: function() {
              return L.FeatureTest;
            }
          }), Object.defineProperty(e, "GlobalWorkerOptions", {
            enumerable: !0,
            get: function() {
              return G.GlobalWorkerOptions;
            }
          }), Object.defineProperty(e, "ImageKind", {
            enumerable: !0,
            get: function() {
              return L.ImageKind;
            }
          }), Object.defineProperty(e, "InvalidPDFException", {
            enumerable: !0,
            get: function() {
              return L.InvalidPDFException;
            }
          }), Object.defineProperty(e, "MissingPDFException", {
            enumerable: !0,
            get: function() {
              return L.MissingPDFException;
            }
          }), Object.defineProperty(e, "OPS", {
            enumerable: !0,
            get: function() {
              return L.OPS;
            }
          }), Object.defineProperty(e, "PDFDataRangeTransport", {
            enumerable: !0,
            get: function() {
              return p.PDFDataRangeTransport;
            }
          }), Object.defineProperty(e, "PDFDateString", {
            enumerable: !0,
            get: function() {
              return n.PDFDateString;
            }
          }), Object.defineProperty(e, "PDFWorker", {
            enumerable: !0,
            get: function() {
              return p.PDFWorker;
            }
          }), Object.defineProperty(e, "PasswordResponses", {
            enumerable: !0,
            get: function() {
              return L.PasswordResponses;
            }
          }), Object.defineProperty(e, "PermissionFlag", {
            enumerable: !0,
            get: function() {
              return L.PermissionFlag;
            }
          }), Object.defineProperty(e, "PixelsPerInch", {
            enumerable: !0,
            get: function() {
              return n.PixelsPerInch;
            }
          }), Object.defineProperty(e, "PromiseCapability", {
            enumerable: !0,
            get: function() {
              return L.PromiseCapability;
            }
          }), Object.defineProperty(e, "RenderingCancelledException", {
            enumerable: !0,
            get: function() {
              return n.RenderingCancelledException;
            }
          }), Object.defineProperty(e, "SVGGraphics", {
            enumerable: !0,
            get: function() {
              return p.SVGGraphics;
            }
          }), Object.defineProperty(e, "UnexpectedResponseException", {
            enumerable: !0,
            get: function() {
              return L.UnexpectedResponseException;
            }
          }), Object.defineProperty(e, "Util", {
            enumerable: !0,
            get: function() {
              return L.Util;
            }
          }), Object.defineProperty(e, "VerbosityLevel", {
            enumerable: !0,
            get: function() {
              return L.VerbosityLevel;
            }
          }), Object.defineProperty(e, "XfaLayer", {
            enumerable: !0,
            get: function() {
              return X.XfaLayer;
            }
          }), Object.defineProperty(e, "build", {
            enumerable: !0,
            get: function() {
              return p.build;
            }
          }), Object.defineProperty(e, "createValidAbsoluteUrl", {
            enumerable: !0,
            get: function() {
              return L.createValidAbsoluteUrl;
            }
          }), Object.defineProperty(e, "getDocument", {
            enumerable: !0,
            get: function() {
              return p.getDocument;
            }
          }), Object.defineProperty(e, "getFilenameFromUrl", {
            enumerable: !0,
            get: function() {
              return n.getFilenameFromUrl;
            }
          }), Object.defineProperty(e, "getPdfFilenameFromUrl", {
            enumerable: !0,
            get: function() {
              return n.getPdfFilenameFromUrl;
            }
          }), Object.defineProperty(e, "getXfaPageViewport", {
            enumerable: !0,
            get: function() {
              return n.getXfaPageViewport;
            }
          }), Object.defineProperty(e, "isDataScheme", {
            enumerable: !0,
            get: function() {
              return n.isDataScheme;
            }
          }), Object.defineProperty(e, "isPdfFile", {
            enumerable: !0,
            get: function() {
              return n.isPdfFile;
            }
          }), Object.defineProperty(e, "loadScript", {
            enumerable: !0,
            get: function() {
              return n.loadScript;
            }
          }), Object.defineProperty(e, "noContextMenu", {
            enumerable: !0,
            get: function() {
              return n.noContextMenu;
            }
          }), Object.defineProperty(e, "normalizeUnicode", {
            enumerable: !0,
            get: function() {
              return L.normalizeUnicode;
            }
          }), Object.defineProperty(e, "renderTextLayer", {
            enumerable: !0,
            get: function() {
              return t.renderTextLayer;
            }
          }), Object.defineProperty(e, "setLayerDimensions", {
            enumerable: !0,
            get: function() {
              return n.setLayerDimensions;
            }
          }), Object.defineProperty(e, "shadow", {
            enumerable: !0,
            get: function() {
              return L.shadow;
            }
          }), Object.defineProperty(e, "updateTextLayer", {
            enumerable: !0,
            get: function() {
              return t.updateTextLayer;
            }
          }), Object.defineProperty(e, "version", {
            enumerable: !0,
            get: function() {
              return p.version;
            }
          });
          var L = __w_pdfjs_require__(1), p = __w_pdfjs_require__(2), n = __w_pdfjs_require__(6), t = __w_pdfjs_require__(26), l = __w_pdfjs_require__(27), W = __w_pdfjs_require__(5), Q = __w_pdfjs_require__(29), G = __w_pdfjs_require__(14), X = __w_pdfjs_require__(32);
        })(), __webpack_exports__;
      })()
    ));
  }(pdf)), pdf.exports;
}
var hasRequiredCore_min;
function requireCore_min() {
  return hasRequiredCore_min || (hasRequiredCore_min = 1, function(e) {
    var L = requireReact(), p = requirePdf();
    function n(z) {
      var K = /* @__PURE__ */ Object.create(null);
      return z && Object.keys(z).forEach(function(ue) {
        if (ue !== "default") {
          var ve = Object.getOwnPropertyDescriptor(z, ue);
          Object.defineProperty(K, ue, ve.get ? ve : { enumerable: !0, get: function() {
            return z[ue];
          } });
        }
      }), K.default = z, Object.freeze(K);
    }
    var t, l = n(L), W = n(p);
    e.AnnotationType = void 0, (t = e.AnnotationType || (e.AnnotationType = {}))[t.Text = 1] = "Text", t[t.Link = 2] = "Link", t[t.FreeText = 3] = "FreeText", t[t.Line = 4] = "Line", t[t.Square = 5] = "Square", t[t.Circle = 6] = "Circle", t[t.Polygon = 7] = "Polygon", t[t.Polyline = 8] = "Polyline", t[t.Highlight = 9] = "Highlight", t[t.Underline = 10] = "Underline", t[t.Squiggly = 11] = "Squiggly", t[t.StrikeOut = 12] = "StrikeOut", t[t.Stamp = 13] = "Stamp", t[t.Caret = 14] = "Caret", t[t.Ink = 15] = "Ink", t[t.Popup = 16] = "Popup", t[t.FileAttachment = 17] = "FileAttachment";
    var Q = function(z, K) {
      return Q = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(ue, ve) {
        ue.__proto__ = ve;
      } || function(ue, ve) {
        for (var Pe in ve) Object.prototype.hasOwnProperty.call(ve, Pe) && (ue[Pe] = ve[Pe]);
      }, Q(z, K);
    };
    function G(z, K) {
      if (typeof K != "function" && K !== null) throw new TypeError("Class extends value " + String(K) + " is not a constructor or null");
      function ue() {
        this.constructor = z;
      }
      Q(z, K), z.prototype = K === null ? Object.create(K) : (ue.prototype = K.prototype, new ue());
    }
    var X, N = function() {
      return N = Object.assign || function(z) {
        for (var K, ue = 1, ve = arguments.length; ue < ve; ue++) for (var Pe in K = arguments[ue]) Object.prototype.hasOwnProperty.call(K, Pe) && (z[Pe] = K[Pe]);
        return z;
      }, N.apply(this, arguments);
    };
    e.TextDirection = void 0, (X = e.TextDirection || (e.TextDirection = {})).RightToLeft = "RTL", X.LeftToRight = "LTR";
    var H, B = l.createContext({ currentTheme: "light", direction: e.TextDirection.LeftToRight, setCurrentTheme: function() {
    } }), P = function(z) {
      var K = [];
      return Object.keys(z).forEach(function(ue) {
        ue && z[ue] && K.push(ue);
      }), K.join(" ");
    }, S = typeof window < "u" ? l.useLayoutEffect : l.useEffect, r = function(z) {
      var K = l.useRef(null), ue = z.once, ve = z.threshold, Pe = z.onVisibilityChanged;
      return S(function() {
        var Me = K.current;
        if (Me) {
          var Oe = new IntersectionObserver(function(xe) {
            xe.forEach(function(Ee) {
              var Ie = Ee.isIntersecting, Le = Ee.intersectionRatio;
              Pe({ isVisible: Ie, ratio: Le }), Ie && ue && (Oe.unobserve(Me), Oe.disconnect());
            });
          }, { threshold: ve || 0 });
          return Oe.observe(Me), function() {
            Oe.unobserve(Me), Oe.disconnect();
          };
        }
      }, []), K;
    }, u = function(z) {
      var K = z.children, ue = z.ignoreDirection, ve = ue !== void 0 && ue, Pe = z.size, Me = Pe === void 0 ? 24 : Pe, Oe = l.useContext(B).direction, xe = !ve && Oe === e.TextDirection.RightToLeft, Ee = "".concat(Me || 24, "px");
      return l.createElement("svg", { "aria-hidden": "true", className: P({ "rpv-core__icon": !0, "rpv-core__icon--rtl": xe }), focusable: "false", height: Ee, viewBox: "0 0 24 24", width: Ee }, K);
    }, m = function() {
      return l.createElement(u, { size: 16 }, l.createElement("path", { d: "M23.5,0.499l-16.5,23l-6.5-6.5" }));
    }, s = function(z) {
      var K = z.children, ue = z.testId, ve = z.onClick, Pe = l.useContext(B).direction === e.TextDirection.RightToLeft, Me = ue ? { "data-testid": ue } : {};
      return l.createElement("button", N({ className: P({ "rpv-core__primary-button": !0, "rpv-core__primary-button--rtl": Pe }), type: "button", onClick: ve }, Me), K);
    }, w = function(z) {
      var K = z.size, ue = K === void 0 ? "4rem" : K, ve = z.testId, Pe = l.useState(!1), Me = Pe[0], Oe = Pe[1], xe = ve ? { "data-testid": ve } : {}, Ee = r({ onVisibilityChanged: function(Ie) {
        Oe(Ie.isVisible);
      } });
      return l.createElement("div", N({}, xe, { className: P({ "rpv-core__spinner": !0, "rpv-core__spinner--animating": Me }), ref: Ee, style: { height: ue, width: ue } }));
    }, i = function(z) {
      var K = z.ariaLabel, ue = K === void 0 ? "" : K, ve = z.autoFocus, Pe = ve !== void 0 && ve, Me = z.placeholder, Oe = Me === void 0 ? "" : Me, xe = z.testId, Ee = z.type, Ie = Ee === void 0 ? "text" : Ee, Le = z.value, rt = Le === void 0 ? "" : Le, nt = z.onChange, Qe = z.onKeyDown, vt = Qe === void 0 ? function() {
      } : Qe, ft = l.useContext(B).direction, ut = l.useRef(), en = ft === e.TextDirection.RightToLeft, Nt = { ref: ut, "data-testid": "", "aria-label": ue, className: P({ "rpv-core__textbox": !0, "rpv-core__textbox--rtl": en }), placeholder: Oe, value: rt, onChange: function(jt) {
        return nt(jt.target.value);
      }, onKeyDown: vt };
      return xe && (Nt["data-testid"] = xe), S(function() {
        if (Pe) {
          var jt = ut.current;
          if (jt) {
            var $t = window.scrollX, Tt = window.scrollY;
            jt.focus(), window.scrollTo($t, Tt);
          }
        }
      }, []), Ie === "text" ? l.createElement("input", N({ type: "text" }, Nt)) : l.createElement("input", N({ type: "password" }, Nt));
    };
    (function(z) {
      z[z.ExitFullScreen = 0] = "ExitFullScreen", z[z.FullScreenChange = 1] = "FullScreenChange", z[z.FullScreenElement = 2] = "FullScreenElement", z[z.FullScreenEnabled = 3] = "FullScreenEnabled", z[z.RequestFullScreen = 4] = "RequestFullScreen";
    })(H || (H = {}));
    var o, b = { ExitFullScreen: "exitFullscreen", FullScreenChange: "fullscreenchange", FullScreenElement: "fullscreenElement", FullScreenEnabled: "fullscreenEnabled", RequestFullScreen: "requestFullscreen" }, g = { ExitFullScreen: "webkitExitFullscreen", FullScreenChange: "webkitfullscreenchange", FullScreenElement: "webkitFullscreenElement", FullScreenEnabled: "webkitFullscreenEnabled", RequestFullScreen: "webkitRequestFullscreen" }, c = { ExitFullScreen: "msExitFullscreen", FullScreenChange: "msFullscreenChange", FullScreenElement: "msFullscreenElement", FullScreenEnabled: "msFullscreenEnabled", RequestFullScreen: "msRequestFullscreen" }, v = typeof window < "u", k = v && (H.FullScreenEnabled in document && b || g.FullScreenEnabled in document && g || c.FullScreenEnabled in document && c) || b, a = function() {
      return v && k.FullScreenEnabled in document && document[k.FullScreenEnabled] === !0;
    }, f = function(z) {
      return v ? z[k.ExitFullScreen]() : Promise.resolve({});
    }, C = function() {
      return v ? document[k.FullScreenElement] : null;
    }, R = function(z, K) {
      var ue = l.useRef(), ve = function() {
        ue.current && clearTimeout(ue.current);
      };
      return l.useEffect(function() {
        return function() {
          return ve();
        };
      }, []), l.useCallback(function() {
        for (var Pe = [], Me = 0; Me < arguments.length; Me++) Pe[Me] = arguments[Me];
        ve(), ue.current = setTimeout(function() {
          z.apply(void 0, Pe);
        }, K);
      }, [z, K]);
    }, M = function() {
      var z = l.useRef(!1);
      return l.useEffect(function() {
        return z.current = !0, function() {
          z.current = !1;
        };
      }, []), z;
    }, I = function(z) {
      var K = l.useRef(z);
      return l.useEffect(function() {
        K.current = z;
      }, [z]), K.current;
    };
    (function(z) {
      z.NotRenderedYet = "NotRenderedYet", z.Rendering = "Rendering", z.Rendered = "Rendered";
    })(o || (o = {}));
    var E, T = -9999, y = function(z) {
      var K = z.doc, ue = K.numPages, ve = K.loadingTask.docId, Pe = l.useMemo(function() {
        return Array(ue).fill(null).map(function(xe, Ee) {
          return { pageIndex: Ee, renderStatus: o.NotRenderedYet, visibility: T };
        });
      }, [ve]), Me = l.useRef({ currentRenderingPage: -1, startRange: 0, endRange: ue - 1, visibilities: Pe }), Oe = function(xe, Ee) {
        Me.current.visibilities[xe].visibility = Ee;
      };
      return { getHighestPriorityPage: function() {
        var xe = Me.current.visibilities.slice(Me.current.startRange, Me.current.endRange + 1).filter(function(nt) {
          return nt.visibility > T;
        });
        if (!xe.length) return -1;
        for (var Ee = xe[0].pageIndex, Ie = xe[xe.length - 1].pageIndex, Le = xe.length, rt = 0; rt < Le; rt++) {
          if (xe[rt].renderStatus === o.Rendering) return -1;
          if (xe[rt].renderStatus === o.NotRenderedYet) return xe[rt].pageIndex;
        }
        return Ie + 1 < ue && Me.current.visibilities[Ie + 1].renderStatus !== o.Rendered ? Ie + 1 : Ee - 1 >= 0 && Me.current.visibilities[Ee - 1].renderStatus !== o.Rendered ? Ee - 1 : -1;
      }, isInRange: function(xe) {
        return xe >= Me.current.startRange && xe <= Me.current.endRange;
      }, markNotRendered: function() {
        for (var xe = 0; xe < ue; xe++) Me.current.visibilities[xe].renderStatus = o.NotRenderedYet;
      }, markRendered: function(xe) {
        Me.current.visibilities[xe].renderStatus = o.Rendered;
      }, markRendering: function(xe) {
        Me.current.currentRenderingPage !== -1 && Me.current.currentRenderingPage !== xe && Me.current.visibilities[Me.current.currentRenderingPage].renderStatus === o.Rendering && (Me.current.visibilities[Me.current.currentRenderingPage].renderStatus = o.NotRenderedYet), Me.current.visibilities[xe].renderStatus = o.Rendering, Me.current.currentRenderingPage = xe;
      }, setOutOfRange: function(xe) {
        Oe(xe, T);
      }, setRange: function(xe, Ee) {
        Me.current.startRange = xe, Me.current.endRange = Ee;
        for (var Ie = 0; Ie < ue; Ie++) (Ie < xe || Ie > Ee) && (Me.current.visibilities[Ie].visibility = T, Me.current.visibilities[Ie].renderStatus = o.NotRenderedYet);
      }, setVisibility: Oe };
    }, D = { core: { askingPassword: { requirePasswordToOpen: "This document requires a password to open", submit: "Submit" }, wrongPassword: { tryAgain: "The password is wrong. Please try again" }, pageLabel: "Page {{pageIndex}}" } }, j = l.createContext({ l10n: D, setL10n: function() {
    } }), A = 0, d = function() {
      return A++;
    }, _ = function(z, K, ue) {
      var ve = function(Pe) {
        var Me = K.current;
        if (Me) {
          var Oe = Pe.target;
          if (Oe instanceof Element && Oe.shadowRoot) {
            var xe = Pe.composedPath();
            xe.length > 0 && !Me.contains(xe[0]) && ue();
          } else Me.contains(Oe) || ue();
        }
      };
      l.useEffect(function() {
        if (z) {
          var Pe = { capture: !0 };
          return document.addEventListener("click", ve, Pe), function() {
            document.removeEventListener("click", ve, Pe);
          };
        }
      }, []);
    }, F = function(z) {
      var K = function(ue) {
        ue.key === "Escape" && z();
      };
      l.useEffect(function() {
        return document.addEventListener("keyup", K), function() {
          document.removeEventListener("keyup", K);
        };
      }, []);
    }, U = function(z) {
      var K = z.ariaControlsSuffix, ue = z.children, ve = z.closeOnClickOutside, Pe = z.closeOnEscape, Me = z.onToggle, Oe = l.useRef(), xe = l.useContext(B).direction === e.TextDirection.RightToLeft;
      return l.useEffect(function() {
        var Ee = window.getComputedStyle(document.body).overflow;
        return document.body.style.overflow = "hidden", function() {
          document.body.style.overflow = Ee;
        };
      }, []), F(function() {
        Oe.current && Pe && Me();
      }), _(ve, Oe, Me), S(function() {
        var Ee = Oe.current;
        if (Ee) {
          var Ie = 0.75 * document.body.clientHeight;
          Ee.getBoundingClientRect().height >= Ie && (Ee.style.overflow = "auto", Ee.style.maxHeight = "".concat(Ie, "px"));
        }
      }, []), l.createElement("div", { "aria-modal": "true", className: P({ "rpv-core__modal-body": !0, "rpv-core__modal-body--rtl": xe }), id: "rpv-core__modal-body-".concat(K), ref: Oe, role: "dialog", tabIndex: -1 }, ue);
    }, V = function(z) {
      var K = z.children;
      return l.createElement("div", { className: "rpv-core__modal-overlay" }, K);
    };
    e.ToggleStatus = void 0, (E = e.ToggleStatus || (e.ToggleStatus = {})).Close = "Close", E.Open = "Open", E.Toggle = "Toggle";
    var $, re = function(z) {
      var K = l.useState(z), ue = K[0], ve = K[1];
      return { opened: ue, toggle: function(Pe) {
        switch (Pe) {
          case e.ToggleStatus.Close:
            ve(!1);
            break;
          case e.ToggleStatus.Open:
            ve(!0);
            break;
          case e.ToggleStatus.Toggle:
          default:
            ve(function(Me) {
              return !Me;
            });
        }
      } };
    }, ge = function(z) {
      var K = z.content, ue = z.isOpened, ve = ue !== void 0 && ue, Pe = z.target, Me = re(ve), Oe = Me.opened, xe = Me.toggle;
      return l.createElement(l.Fragment, null, Pe && Pe(xe, Oe), Oe && K(xe));
    };
    e.Position = void 0, ($ = e.Position || (e.Position = {})).TopLeft = "TOP_LEFT", $.TopCenter = "TOP_CENTER", $.TopRight = "TOP_RIGHT", $.RightTop = "RIGHT_TOP", $.RightCenter = "RIGHT_CENTER", $.RightBottom = "RIGHT_BOTTOM", $.BottomLeft = "BOTTOM_LEFT", $.BottomCenter = "BOTTOM_CENTER", $.BottomRight = "BOTTOM_RIGHT", $.LeftTop = "LEFT_TOP", $.LeftCenter = "LEFT_CENTER", $.LeftBottom = "LEFT_BOTTOM";
    var be, le, fe, Ae, qe, ye, ce, q, Z = function(z, K, ue, ve, Pe) {
      S(function() {
        var Me = K.current, Oe = z.current, xe = ue.current;
        if (Oe && Me && xe) {
          var Ee = xe.getBoundingClientRect(), Ie = function(nt, Qe, vt, ft) {
            var ut = Qe.getBoundingClientRect(), en = nt.getBoundingClientRect(), Nt = en.height, jt = en.width, $t = 0, Tt = 0;
            switch (vt) {
              case e.Position.TopLeft:
                $t = ut.top - Nt, Tt = ut.left;
                break;
              case e.Position.TopCenter:
                $t = ut.top - Nt, Tt = ut.left + ut.width / 2 - jt / 2;
                break;
              case e.Position.TopRight:
                $t = ut.top - Nt, Tt = ut.left + ut.width - jt;
                break;
              case e.Position.RightTop:
                $t = ut.top, Tt = ut.left + ut.width;
                break;
              case e.Position.RightCenter:
                $t = ut.top + ut.height / 2 - Nt / 2, Tt = ut.left + ut.width;
                break;
              case e.Position.RightBottom:
                $t = ut.top + ut.height - Nt, Tt = ut.left + ut.width;
                break;
              case e.Position.BottomLeft:
                $t = ut.top + ut.height, Tt = ut.left;
                break;
              case e.Position.BottomCenter:
                $t = ut.top + ut.height, Tt = ut.left + ut.width / 2 - jt / 2;
                break;
              case e.Position.BottomRight:
                $t = ut.top + ut.height, Tt = ut.left + ut.width - jt;
                break;
              case e.Position.LeftTop:
                $t = ut.top, Tt = ut.left - jt;
                break;
              case e.Position.LeftCenter:
                $t = ut.top + ut.height / 2 - Nt / 2, Tt = ut.left - jt;
                break;
              case e.Position.LeftBottom:
                $t = ut.top + ut.height - Nt, Tt = ut.left - jt;
            }
            return { left: Tt + (ft.left || 0), top: $t + (ft.top || 0) };
          }(Oe, Me, ve, Pe), Le = Ie.top, rt = Ie.left;
          Oe.style.top = "".concat(Le - Ee.top, "px"), Oe.style.left = "".concat(rt - Ee.left, "px");
        }
      }, []);
    }, pe = function(z) {
      var K, ue = z.customClassName, ve = z.position;
      return l.createElement("div", { className: P((K = { "rpv-core__arrow": !0, "rpv-core__arrow--tl": ve === e.Position.TopLeft, "rpv-core__arrow--tc": ve === e.Position.TopCenter, "rpv-core__arrow--tr": ve === e.Position.TopRight, "rpv-core__arrow--rt": ve === e.Position.RightTop, "rpv-core__arrow--rc": ve === e.Position.RightCenter, "rpv-core__arrow--rb": ve === e.Position.RightBottom, "rpv-core__arrow--bl": ve === e.Position.BottomLeft, "rpv-core__arrow--bc": ve === e.Position.BottomCenter, "rpv-core__arrow--br": ve === e.Position.BottomRight, "rpv-core__arrow--lt": ve === e.Position.LeftTop, "rpv-core__arrow--lc": ve === e.Position.LeftCenter, "rpv-core__arrow--lb": ve === e.Position.LeftBottom }, K["".concat(ue)] = ue !== "", K)) });
    }, me = function(z) {
      var K = z.ariaControlsSuffix, ue = z.children, ve = z.closeOnClickOutside, Pe = z.offset, Me = z.position, Oe = z.targetRef, xe = z.onClose, Ee = l.useRef(), Ie = l.useRef(), Le = l.useRef(), rt = l.useContext(B).direction === e.TextDirection.RightToLeft;
      _(ve, Ee, xe), Z(Ee, Oe, Le, Me, Pe), S(function() {
        var Qe = Ie.current;
        if (Qe) {
          var vt = 0.75 * document.body.clientHeight;
          Qe.getBoundingClientRect().height >= vt && (Qe.style.overflow = "auto", Qe.style.maxHeight = "".concat(vt, "px"));
        }
      }, []);
      var nt = "rpv-core__popover-body-inner-".concat(K);
      return l.createElement(l.Fragment, null, l.createElement("div", { ref: Le, style: { left: 0, position: "absolute", top: 0 } }), l.createElement("div", { "aria-describedby": nt, className: P({ "rpv-core__popover-body": !0, "rpv-core__popover-body--rtl": rt }), id: "rpv-core__popover-body-".concat(K), ref: Ee, role: "dialog", tabIndex: -1 }, l.createElement(pe, { customClassName: "rpv-core__popover-body-arrow", position: Me }), l.createElement("div", { id: nt, ref: Ie }, ue)));
    }, _e = function(z) {
      var K = z.closeOnEscape, ue = z.onClose, ve = l.useRef();
      return F(function() {
        ve.current && K && ue();
      }), l.createElement("div", { className: "rpv-core__popover-overlay", ref: ve });
    }, Be = function(z) {
      var K = z.ariaControlsSuffix, ue = z.children, ve = z.contentRef, Pe = z.offset, Me = z.position, Oe = z.targetRef, xe = l.useRef(), Ee = l.useContext(B).direction === e.TextDirection.RightToLeft;
      return Z(ve, Oe, xe, Me, Pe), l.createElement(l.Fragment, null, l.createElement("div", { ref: xe, style: { left: 0, position: "absolute", top: 0 } }), l.createElement("div", { className: P({ "rpv-core__tooltip-body": !0, "rpv-core__tooltip-body--rtl": Ee }), id: "rpv-core__tooltip-body-".concat(K), ref: ve, role: "tooltip" }, l.createElement(pe, { customClassName: "rpv-core__tooltip-body-arrow", position: Me }), l.createElement("div", { className: "rpv-core__tooltip-body-content" }, ue)));
    };
    e.FullScreenMode = void 0, (be = e.FullScreenMode || (e.FullScreenMode = {})).Normal = "Normal", be.Entering = "Entering", be.Entered = "Entered", be.EnteredCompletely = "EnteredCompletely", be.Exitting = "Exitting", be.Exited = "Exited", e.LayerRenderStatus = void 0, (le = e.LayerRenderStatus || (e.LayerRenderStatus = {}))[le.PreRender = 0] = "PreRender", le[le.DidRender = 1] = "DidRender", e.PageMode = void 0, (fe = e.PageMode || (e.PageMode = {})).Attachments = "UseAttachments", fe.Bookmarks = "UseOutlines", fe.ContentGroup = "UseOC", fe.Default = "UserNone", fe.FullScreen = "FullScreen", fe.Thumbnails = "UseThumbs", e.PasswordStatus = void 0, (Ae = e.PasswordStatus || (e.PasswordStatus = {})).RequiredPassword = "RequiredPassword", Ae.WrongPassword = "WrongPassword", e.RotateDirection = void 0, (qe = e.RotateDirection || (e.RotateDirection = {})).Backward = "Backward", qe.Forward = "Forward", e.ScrollMode = void 0, (ye = e.ScrollMode || (e.ScrollMode = {})).Page = "Page", ye.Horizontal = "Horizontal", ye.Vertical = "Vertical", ye.Wrapped = "Wrapped", e.SpecialZoomLevel = void 0, (ce = e.SpecialZoomLevel || (e.SpecialZoomLevel = {})).ActualSize = "ActualSize", ce.PageFit = "PageFit", ce.PageWidth = "PageWidth", e.ViewMode = void 0, (q = e.ViewMode || (e.ViewMode = {})).DualPage = "DualPage", q.DualPageWithCover = "DualPageWithCover", q.SinglePage = "SinglePage";
    var ke, de = function(z, K) {
      return z.reduce(function(ue, ve, Pe) {
        return Pe % K ? ue[ue.length - 1].push(ve) : ue.push([ve]), ue;
      }, []);
    }, $e = function(z, K) {
      switch (K[1].name) {
        case "XYZ":
          return { bottomOffset: function(ue, ve) {
            return K[3] === null ? ve : K[3];
          }, leftOffset: function(ue, ve) {
            return K[2] === null ? 0 : K[2];
          }, pageIndex: z, scaleTo: K[4] };
        case "Fit":
        case "FitB":
          return { bottomOffset: 0, leftOffset: 0, pageIndex: z, scaleTo: e.SpecialZoomLevel.PageFit };
        case "FitH":
        case "FitBH":
          return { bottomOffset: K[2], leftOffset: 0, pageIndex: z, scaleTo: e.SpecialZoomLevel.PageWidth };
        default:
          return { bottomOffset: 0, leftOffset: 0, pageIndex: z, scaleTo: 1 };
      }
    }, Ge = /* @__PURE__ */ new Map(), st = /* @__PURE__ */ new Map(), it = function(z, K) {
      return "".concat(z.loadingTask.docId, "___").concat(K.num, "R").concat(K.gen === 0 ? "" : K.gen);
    }, _t = function(z, K, ue) {
      Ge.set(it(z, K), ue);
    }, tt = function(z, K) {
      if (!z) return Promise.reject("The document is not loaded yet");
      var ue = "".concat(z.loadingTask.docId, "___").concat(K), ve = st.get(ue);
      return ve ? Promise.resolve(ve) : new Promise(function(Pe, Me) {
        z.getPage(K + 1).then(function(Oe) {
          st.set(ue, Oe), Oe.ref && _t(z, Oe.ref, K), Pe(Oe);
        });
      });
    }, Xe = function(z, K) {
      return new Promise(function(ue) {
        new Promise(function(ve) {
          typeof K == "string" ? z.getDestination(K).then(function(Pe) {
            ve(Pe);
          }) : ve(K);
        }).then(function(ve) {
          if (typeof ve[0] == "object" && ve[0] !== null) {
            var Pe = ve[0], Me = function(xe, Ee) {
              var Ie = it(xe, Ee);
              return Ge.has(Ie) ? Ge.get(Ie) : null;
            }(z, Pe);
            Me === null ? z.getPageIndex(Pe).then(function(xe) {
              _t(z, Pe, xe), Xe(z, K).then(function(Ee) {
                return ue(Ee);
              });
            }) : ue($e(Me, ve));
          } else {
            var Oe = $e(ve[0], ve);
            ue(Oe);
          }
        });
      });
    };
    (function(z) {
      z[z.Solid = 1] = "Solid", z[z.Dashed = 2] = "Dashed", z[z.Beveled = 3] = "Beveled", z[z.Inset = 4] = "Inset", z[z.Underline = 5] = "Underline";
    })(ke || (ke = {}));
    var ct, xt = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"), We = function(z, K, ue, ve) {
      var Pe = parseInt(z, 10);
      return Pe >= K && Pe <= ue ? Pe : ve;
    }, Ce = function(z) {
      return z.contentsObj ? z.contentsObj.str : z.contents || "";
    }, Re = function(z) {
      return z.titleObj ? z.titleObj.str : z.title || "";
    }, lt = function(z) {
      var K = z.annotation, ue = l.useContext(B).direction, ve = Re(K), Pe = Ce(K), Me = ue === e.TextDirection.RightToLeft, Oe = l.useRef(), xe = "";
      if (K.modificationDate) {
        var Ee = function(Ie) {
          var Le = xt.exec(Ie);
          if (!Le) return null;
          var rt = parseInt(Le[1], 10), nt = We(Le[2], 1, 12, 1) - 1, Qe = We(Le[3], 1, 31, 1), vt = We(Le[4], 0, 23, 0), ft = We(Le[5], 0, 59, 0), ut = We(Le[6], 0, 59, 0), en = Le[7] || "Z", Nt = We(Le[8], 0, 23, 0), jt = We(Le[9], 0, 59, 0);
          switch (en) {
            case "-":
              vt += Nt, ft += jt;
              break;
            case "+":
              vt -= Nt, ft -= jt;
          }
          return new Date(Date.UTC(rt, nt, Qe, vt, ft, ut));
        }(K.modificationDate);
        xe = Ee ? "".concat(Ee.toLocaleDateString(), ", ").concat(Ee.toLocaleTimeString()) : "";
      }
      return l.useLayoutEffect(function() {
        if (Oe.current) {
          var Ie = document.querySelector('[data-annotation-id="'.concat(K.id, '"]'));
          if (Ie) {
            var Le = Ie;
            return Le.style.zIndex += 1, function() {
              Le.style.zIndex = "".concat(parseInt(Le.style.zIndex, 10) - 1);
            };
          }
        }
      }, []), l.createElement("div", { ref: Oe, className: P({ "rpv-core__annotation-popup-wrapper": !0, "rpv-core__annotation-popup-wrapper--rtl": Me }), style: { top: K.annotationType === e.AnnotationType.Popup ? "" : "100%" } }, ve && l.createElement(l.Fragment, null, l.createElement("div", { className: P({ "rpv-core__annotation-popup-title": !0, "rpv-core__annotation-popup-title--ltr": !Me, "rpv-core__annotation-popup-title--rtl": Me }) }, ve), l.createElement("div", { className: "rpv-core__annotation-popup-date" }, xe)), Pe && l.createElement("div", { className: "rpv-core__annotation-popup-content" }, Pe.split(`
`).map(function(Ie, Le) {
        return l.createElement(l.Fragment, { key: Le }, Ie, l.createElement("br", null));
      })));
    };
    (function(z) {
      z.Click = "Click", z.Hover = "Hover";
    })(ct || (ct = {}));
    var bt, Et = function(z) {
      var K, ue = z.annotation, ve = z.children, Pe = z.ignoreBorder, Me = z.hasPopup, Oe = z.isRenderable, xe = z.page, Ee = z.viewport, Ie = ue.rect, Le = function() {
        var Wt = re(!1), fn = Wt.opened, un = Wt.toggle, mn = l.useState(ct.Hover), vn = mn[0], bn = mn[1];
        return { opened: fn, closeOnHover: function() {
          vn === ct.Hover && un(e.ToggleStatus.Close);
        }, openOnHover: function() {
          vn === ct.Hover && un(e.ToggleStatus.Open);
        }, toggleOnClick: function() {
          switch (vn) {
            case ct.Click:
              fn && bn(ct.Hover), un(e.ToggleStatus.Toggle);
              break;
            case ct.Hover:
              bn(ct.Click), un(e.ToggleStatus.Open);
          }
        } };
      }(), rt = Le.closeOnHover, nt = Le.opened, Qe = Le.openOnHover, vt = Le.toggleOnClick, ft = (K = [Ie[0], xe.view[3] + xe.view[1] - Ie[1], Ie[2], xe.view[3] + xe.view[1] - Ie[3]], [Math.min(K[0], K[2]), Math.min(K[1], K[3]), Math.max(K[0], K[2]), Math.max(K[1], K[3])]), ut = Ie[2] - Ie[0], en = Ie[3] - Ie[1], Nt = { borderColor: "", borderRadius: "", borderStyle: "", borderWidth: "" };
      if (!Pe && ue.borderStyle.width > 0) {
        switch (ue.borderStyle.style) {
          case ke.Dashed:
            Nt.borderStyle = "dashed";
            break;
          case ke.Solid:
            Nt.borderStyle = "solid";
            break;
          case ke.Underline:
            Nt = Object.assign({ borderBottomStyle: "solid" }, Nt);
          case ke.Beveled:
          case ke.Inset:
        }
        var jt = ue.borderStyle.width;
        Nt.borderWidth = "".concat(jt, "px"), ue.borderStyle.style !== ke.Underline && (ut -= 2 * jt, en -= 2 * jt);
        var $t = ue.borderStyle, Tt = $t.horizontalCornerRadius, Gt = $t.verticalCornerRadius;
        (Tt > 0 || Gt > 0) && (Nt.borderRadius = "".concat(Tt, "px / ").concat(Gt, "px")), ue.color ? Nt.borderColor = "rgb(".concat(0 | ue.color[0], ", ").concat(0 | ue.color[1], ", ").concat(0 | ue.color[2], ")") : Nt.borderWidth = "0";
      }
      return l.createElement(l.Fragment, null, Oe && ve({ popup: { opened: nt, closeOnHover: rt, openOnHover: Qe, toggleOnClick: vt }, slot: { attrs: { style: Object.assign({ height: "".concat(en, "px"), left: "".concat(ft[0], "px"), top: "".concat(ft[1], "px"), transform: "matrix(".concat(Ee.transform.join(","), ")"), transformOrigin: "-".concat(ft[0], "px -").concat(ft[1], "px"), width: "".concat(ut, "px") }, Nt) }, children: l.createElement(l.Fragment, null, Me && nt && l.createElement(lt, { annotation: ue })) } }));
    }, oe = function(z) {
      var K = z.annotation, ue = z.page, ve = z.viewport, Pe = K.hasPopup === !1, Me = Re(K), Oe = Ce(K), xe = !!(K.hasPopup || Me || Oe);
      return l.createElement(Et, { annotation: K, hasPopup: Pe, ignoreBorder: !0, isRenderable: xe, page: ue, viewport: ve }, function(Ee) {
        return l.createElement("div", N({}, Ee.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--caret", "data-annotation-id": K.id, onClick: Ee.popup.toggleOnClick, onMouseEnter: Ee.popup.openOnHover, onMouseLeave: Ee.popup.closeOnHover }), Ee.slot.children);
      });
    }, He = function(z) {
      var K = z.annotation, ue = z.page, ve = z.viewport, Pe = K.hasPopup === !1, Me = Re(K), Oe = Ce(K), xe = !!(K.hasPopup || Me || Oe), Ee = K.rect, Ie = Ee[2] - Ee[0], Le = Ee[3] - Ee[1], rt = K.borderStyle.width;
      return l.createElement(Et, { annotation: K, hasPopup: Pe, ignoreBorder: !0, isRenderable: xe, page: ue, viewport: ve }, function(nt) {
        return l.createElement("div", N({}, nt.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--circle", "data-annotation-id": K.id, onClick: nt.popup.toggleOnClick, onMouseEnter: nt.popup.openOnHover, onMouseLeave: nt.popup.closeOnHover }), l.createElement("svg", { height: "".concat(Le, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(Ie, " ").concat(Le), width: "".concat(Ie, "px") }, l.createElement("circle", { cy: Le / 2, fill: "none", rx: Ie / 2 - rt / 2, ry: Le / 2 - rt / 2, stroke: "transparent", strokeWidth: rt || 1 })), nt.slot.children);
      });
    }, at = function(z) {
      var K = z.annotation, ue = z.page, ve = z.viewport, Pe = Re(K), Me = Ce(K), Oe = !(K.hasPopup !== !1 || !Pe && !Me), xe = function() {
        var Ee, Ie, Le, rt, nt = K.file;
        nt && (Ee = nt.filename, Ie = nt.content, Le = typeof Ie == "string" ? "" : URL.createObjectURL(new Blob([Ie], { type: "" })), (rt = document.createElement("a")).style.display = "none", rt.href = Le || Ee, rt.setAttribute("download", function(Qe) {
          var vt = Qe.split("/").pop();
          return vt ? vt.split("#")[0].split("?")[0] : Qe;
        }(Ee)), document.body.appendChild(rt), rt.click(), document.body.removeChild(rt), Le && URL.revokeObjectURL(Le));
      };
      return l.createElement(Et, { annotation: K, hasPopup: Oe, ignoreBorder: !0, isRenderable: !0, page: ue, viewport: ve }, function(Ee) {
        return l.createElement("div", N({}, Ee.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--file-attachment", "data-annotation-id": K.id, onClick: Ee.popup.toggleOnClick, onDoubleClick: xe, onMouseEnter: Ee.popup.openOnHover, onMouseLeave: Ee.popup.closeOnHover }), Ee.slot.children);
      });
    }, St = function(z) {
      var K = z.annotation, ue = z.page, ve = z.viewport, Pe = K.hasPopup === !1, Me = Re(K), Oe = Ce(K), xe = !!(K.hasPopup || Me || Oe);
      return l.createElement(Et, { annotation: K, hasPopup: Pe, ignoreBorder: !0, isRenderable: xe, page: ue, viewport: ve }, function(Ee) {
        return l.createElement("div", N({}, Ee.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--free-text", "data-annotation-id": K.id, onClick: Ee.popup.toggleOnClick, onMouseEnter: Ee.popup.openOnHover, onMouseLeave: Ee.popup.closeOnHover }), Ee.slot.children);
      });
    }, yt = function(z) {
      var K = z.annotation, ue = z.page, ve = z.viewport, Pe = Re(K), Me = Ce(K), Oe = !(!Pe && !Me), xe = !K.parentType || ["Circle", "Ink", "Line", "Polygon", "PolyLine", "Square"].indexOf(K.parentType) !== -1;
      return S(function() {
        if (K.parentId) {
          var Ee = document.querySelector('[data-annotation-id="'.concat(K.parentId, '"]')), Ie = document.querySelector('[data-annotation-id="'.concat(K.id, '"]'));
          if (Ee && Ie) {
            var Le = parseFloat(Ee.style.left), rt = parseFloat(Ee.style.top) + parseFloat(Ee.style.height);
            Ie.style.left = "".concat(Le, "px"), Ie.style.top = "".concat(rt, "px"), Ie.style.transformOrigin = "-".concat(Le, "px -").concat(rt, "px");
          }
        }
      }, []), l.createElement(Et, { annotation: K, hasPopup: xe, ignoreBorder: !1, isRenderable: Oe, page: ue, viewport: ve }, function(Ee) {
        return l.createElement("div", N({}, Ee.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--popup", "data-annotation-id": K.id }), l.createElement(lt, { annotation: K }));
      });
    }, dt = function(z) {
      var K = z.annotation, ue = z.childAnnotation, ve = z.page, Pe = z.viewport, Me = K.hasPopup === !1, Oe = Re(K), xe = Ce(K), Ee = !!(K.hasPopup || Oe || xe);
      if (K.quadPoints && K.quadPoints.length > 0) {
        var Ie = K.quadPoints.map(function(Le) {
          return Object.assign({}, K, { rect: [Le[2].x, Le[2].y, Le[1].x, Le[1].y], quadPoints: [] });
        });
        return l.createElement(l.Fragment, null, Ie.map(function(Le, rt) {
          return l.createElement(dt, { key: rt, annotation: Le, childAnnotation: ue, page: ve, viewport: Pe });
        }));
      }
      return l.createElement(Et, { annotation: K, hasPopup: Me, ignoreBorder: !0, isRenderable: Ee, page: ve, viewport: Pe }, function(Le) {
        return l.createElement(l.Fragment, null, l.createElement("div", N({}, Le.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--highlight", "data-annotation-id": K.id, onClick: Le.popup.toggleOnClick, onMouseEnter: Le.popup.openOnHover, onMouseLeave: Le.popup.closeOnHover }), Le.slot.children), ue && ue.annotationType === e.AnnotationType.Popup && Le.popup.opened && l.createElement(yt, { annotation: ue, page: ve, viewport: Pe }));
      });
    }, ie = function(z) {
      var K = z.annotation, ue = z.page, ve = z.viewport, Pe = K.hasPopup === !1, Me = Re(K), Oe = Ce(K), xe = !!(K.hasPopup || Me || Oe), Ee = K.rect, Ie = Ee[2] - Ee[0], Le = Ee[3] - Ee[1], rt = K.borderStyle.width;
      return l.createElement(Et, { annotation: K, hasPopup: Pe, ignoreBorder: !0, isRenderable: xe, page: ue, viewport: ve }, function(nt) {
        return l.createElement("div", N({}, nt.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--ink", "data-annotation-id": K.id, onClick: nt.popup.toggleOnClick, onMouseEnter: nt.popup.openOnHover, onMouseLeave: nt.popup.closeOnHover }), K.inkLists && K.inkLists.length && l.createElement("svg", { height: "".concat(Le, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(Ie, " ").concat(Le), width: "".concat(Ie, "px") }, K.inkLists.map(function(Qe, vt) {
          return l.createElement("polyline", { key: vt, fill: "none", stroke: "transparent", strokeWidth: rt || 1, points: Qe.map(function(ft) {
            return "".concat(ft.x - Ee[0], ",").concat(Ee[3] - ft.y);
          }).join(" ") });
        })), nt.slot.children);
      });
    }, te = function(z) {
      var K = z.annotation, ue = z.page, ve = z.viewport, Pe = K.hasPopup === !1, Me = Re(K), Oe = Ce(K), xe = !!(K.hasPopup || Me || Oe), Ee = K.rect, Ie = Ee[2] - Ee[0], Le = Ee[3] - Ee[1], rt = K.borderStyle.width;
      return l.createElement(Et, { annotation: K, hasPopup: Pe, ignoreBorder: !0, isRenderable: xe, page: ue, viewport: ve }, function(nt) {
        return l.createElement("div", N({}, nt.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--line", "data-annotation-id": K.id, onClick: nt.popup.toggleOnClick, onMouseEnter: nt.popup.openOnHover, onMouseLeave: nt.popup.closeOnHover }), l.createElement("svg", { height: "".concat(Le, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(Ie, " ").concat(Le), width: "".concat(Ie, "px") }, l.createElement("line", { stroke: "transparent", strokeWidth: rt || 1, x1: Ee[2] - K.lineCoordinates[0], x2: Ee[2] - K.lineCoordinates[2], y1: Ee[3] - K.lineCoordinates[1], y2: Ee[3] - K.lineCoordinates[3] })), nt.slot.children);
      });
    }, we = /^([^\w]*)(javascript|data|vbscript)/im, De = /&#(\w+)(^\w|;)?/g, Ve = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim, Ye = /^([^:]+):/gm, Je = function(z, K) {
      var ue, ve = (ue = z || "", ue.replace(De, function(xe, Ee) {
        return String.fromCharCode(Ee);
      })).replace(Ve, "").trim();
      if (!ve) return K;
      var Pe = ve[0];
      if (Pe === "." || Pe === "/") return ve;
      var Me = ve.match(Ye);
      if (!Me) return ve;
      var Oe = Me[0];
      return we.test(Oe) ? K : ve;
    }, Pt = function(z) {
      var K, ue = z.annotation, ve = z.annotationContainerRef, Pe = z.doc, Me = z.outlines, Oe = z.page, xe = z.pageIndex, Ee = z.scale, Ie = z.viewport, Le = z.onExecuteNamedAction, rt = z.onJumpFromLinkAnnotation, nt = z.onJumpToDest, Qe = l.useRef(), vt = Me && Me.length && ue.dest && typeof ue.dest == "string" ? (K = Me.find(function(Nt) {
        return Nt.dest === ue.dest;
      })) === null || K === void 0 ? void 0 : K.title : "", ft = !!(ue.url || ue.dest || ue.action || ue.unsafeUrl), ut = {};
      if (ue.url || ue.unsafeUrl) {
        var en = Je(ue.url || ue.unsafeUrl, "");
        en ? ut = { "data-target": "external", href: en, rel: "noopener noreferrer nofollow", target: ue.newWindow ? "_blank" : "", title: en } : ft = !1;
      } else ut = { href: "", "data-annotation-link": ue.id, onClick: function(Nt) {
        Nt.preventDefault(), ue.action ? Le(ue.action) : Xe(Pe, ue.dest).then(function(jt) {
          var $t = Qe.current, Tt = ve.current;
          if ($t && Tt) {
            var Gt = $t.getBoundingClientRect();
            Tt.style.setProperty("height", "100%"), Tt.style.setProperty("width", "100%");
            var Wt = Tt.getBoundingClientRect();
            Tt.style.removeProperty("height"), Tt.style.removeProperty("width");
            var fn = (Gt.left - Wt.left) / Ee, un = (Wt.bottom - Gt.bottom + Gt.height) / Ee;
            rt({ bottomOffset: un, label: vt, leftOffset: fn, pageIndex: xe });
          }
          nt(jt);
        });
      } };
      return vt && (ut = Object.assign({}, ut, { title: vt, "aria-label": vt })), l.createElement(Et, { annotation: ue, hasPopup: !1, ignoreBorder: !1, isRenderable: ft, page: Oe, viewport: Ie }, function(Nt) {
        return l.createElement("div", N({}, Nt.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--link", "data-annotation-id": ue.id, "data-testid": "core__annotation--link-".concat(ue.id) }), l.createElement("a", N({ ref: Qe }, ut)));
      });
    }, mt = function(z) {
      var K = z.annotation, ue = z.page, ve = z.viewport, Pe = K.hasPopup === !1, Me = Re(K), Oe = Ce(K), xe = !!(K.hasPopup || Me || Oe), Ee = K.rect, Ie = Ee[2] - Ee[0], Le = Ee[3] - Ee[1], rt = K.borderStyle.width;
      return l.createElement(Et, { annotation: K, hasPopup: Pe, ignoreBorder: !0, isRenderable: xe, page: ue, viewport: ve }, function(nt) {
        return l.createElement("div", N({}, nt.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--polygon", "data-annotation-id": K.id, onClick: nt.popup.toggleOnClick, onMouseEnter: nt.popup.openOnHover, onMouseLeave: nt.popup.closeOnHover }), K.vertices && K.vertices.length && l.createElement("svg", { height: "".concat(Le, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(Ie, " ").concat(Le), width: "".concat(Ie, "px") }, l.createElement("polygon", { fill: "none", stroke: "transparent", strokeWidth: rt || 1, points: K.vertices.map(function(Qe) {
          return "".concat(Qe.x - Ee[0], ",").concat(Ee[3] - Qe.y);
        }).join(" ") })), nt.slot.children);
      });
    }, pt = function(z) {
      var K = z.annotation, ue = z.page, ve = z.viewport, Pe = K.hasPopup === !1, Me = Re(K), Oe = Ce(K), xe = !!(K.hasPopup || Me || Oe), Ee = K.rect, Ie = Ee[2] - Ee[0], Le = Ee[3] - Ee[1], rt = K.borderStyle.width;
      return l.createElement(Et, { annotation: K, hasPopup: Pe, ignoreBorder: !0, isRenderable: xe, page: ue, viewport: ve }, function(nt) {
        return l.createElement("div", N({}, nt.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--polyline", "data-annotation-id": K.id, onClick: nt.popup.toggleOnClick, onMouseEnter: nt.popup.openOnHover, onMouseLeave: nt.popup.closeOnHover }), K.vertices && K.vertices.length && l.createElement("svg", { height: "".concat(Le, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(Ie, " ").concat(Le), width: "".concat(Ie, "px") }, l.createElement("polyline", { fill: "none", stroke: "transparent", strokeWidth: rt || 1, points: K.vertices.map(function(Qe) {
          return "".concat(Qe.x - Ee[0], ",").concat(Ee[3] - Qe.y);
        }).join(" ") })), nt.slot.children);
      });
    }, Ut = function(z) {
      var K = z.annotation, ue = z.page, ve = z.viewport, Pe = K.hasPopup === !1, Me = Re(K), Oe = Ce(K), xe = !!(K.hasPopup || Me || Oe), Ee = K.rect, Ie = Ee[2] - Ee[0], Le = Ee[3] - Ee[1], rt = K.borderStyle.width;
      return l.createElement(Et, { annotation: K, hasPopup: Pe, ignoreBorder: !0, isRenderable: xe, page: ue, viewport: ve }, function(nt) {
        return l.createElement("div", N({}, nt.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--square", "data-annotation-id": K.id, onClick: nt.popup.toggleOnClick, onMouseEnter: nt.popup.openOnHover, onMouseLeave: nt.popup.closeOnHover }), l.createElement("svg", { height: "".concat(Le, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(Ie, " ").concat(Le), width: "".concat(Ie, "px") }, l.createElement("rect", { height: Le - rt, fill: "none", stroke: "transparent", strokeWidth: rt || 1, x: rt / 2, y: rt / 2, width: Ie - rt })), nt.slot.children);
      });
    }, Ct = function(z) {
      var K = z.annotation, ue = z.page, ve = z.viewport, Pe = K.hasPopup === !1, Me = Re(K), Oe = Ce(K), xe = !!(K.hasPopup || Me || Oe);
      return l.createElement(Et, { annotation: K, hasPopup: Pe, ignoreBorder: !0, isRenderable: xe, page: ue, viewport: ve }, function(Ee) {
        return l.createElement("div", N({}, Ee.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--squiggly", "data-annotation-id": K.id, onClick: Ee.popup.toggleOnClick, onMouseEnter: Ee.popup.openOnHover, onMouseLeave: Ee.popup.closeOnHover }), Ee.slot.children);
      });
    }, Mt = function(z) {
      var K = z.annotation, ue = z.page, ve = z.viewport, Pe = K.hasPopup === !1, Me = Re(K), Oe = Ce(K), xe = !!(K.hasPopup || Me || Oe);
      return l.createElement(Et, { annotation: K, hasPopup: Pe, ignoreBorder: !0, isRenderable: xe, page: ue, viewport: ve }, function(Ee) {
        return l.createElement("div", N({}, Ee.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--stamp", "data-annotation-id": K.id, onClick: Ee.popup.toggleOnClick, onMouseEnter: Ee.popup.openOnHover, onMouseLeave: Ee.popup.closeOnHover }), Ee.slot.children);
      });
    }, zt = function(z) {
      var K = z.annotation, ue = z.page, ve = z.viewport, Pe = K.hasPopup === !1, Me = Re(K), Oe = Ce(K), xe = !!(K.hasPopup || Me || Oe);
      return l.createElement(Et, { annotation: K, hasPopup: Pe, ignoreBorder: !0, isRenderable: xe, page: ue, viewport: ve }, function(Ee) {
        return l.createElement("div", N({}, Ee.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--strike-out", "data-annotation-id": K.id, onClick: Ee.popup.toggleOnClick, onMouseEnter: Ee.popup.openOnHover, onMouseLeave: Ee.popup.closeOnHover }), Ee.slot.children);
      });
    }, Xt = function() {
      return l.createElement(u, { size: 16 }, l.createElement("path", { d: "M.5,16.5a1,1,0,0,0,1,1h2v4l4-4h15a1,1,0,0,0,1-1V3.5a1,1,0,0,0-1-1H1.5a1,1,0,0,0-1,1Z" }), l.createElement("path", { d: "M7.25,9.75A.25.25,0,1,1,7,10a.25.25,0,0,1,.25-.25" }), l.createElement("path", { d: "M12,9.75a.25.25,0,1,1-.25.25A.25.25,0,0,1,12,9.75" }), l.createElement("path", { d: "M16.75,9.75a.25.25,0,1,1-.25.25.25.25,0,0,1,.25-.25" }));
    }, sn = function() {
      return l.createElement(u, { size: 16 }, l.createElement("path", { d: "M0.500 12.001 A11.500 11.500 0 1 0 23.500 12.001 A11.500 11.500 0 1 0 0.500 12.001 Z" }), l.createElement("path", { d: "M6.000 12.001 A6.000 6.000 0 1 0 18.000 12.001 A6.000 6.000 0 1 0 6.000 12.001 Z" }), l.createElement("path", { d: "M21.423 5.406L17.415 9.414" }), l.createElement("path", { d: "M14.587 6.585L18.607 2.565" }), l.createElement("path", { d: "M5.405 21.424L9.413 17.416" }), l.createElement("path", { d: "M6.585 14.588L2.577 18.596" }), l.createElement("path", { d: "M18.602 21.419L14.595 17.412" }), l.createElement("path", { d: "M17.419 14.58L21.428 18.589" }), l.createElement("path", { d: "M2.582 5.399L6.588 9.406" }), l.createElement("path", { d: "M9.421 6.581L5.412 2.572" }));
    }, gn = function() {
      return l.createElement(u, { size: 16 }, l.createElement("path", { d: "M4.000 18.500 A1.500 1.500 0 1 0 7.000 18.500 A1.500 1.500 0 1 0 4.000 18.500 Z" }), l.createElement("path", { d: "M20.5.5l-9.782,9.783a7,7,0,1,0,3,3L17,10h1.5V8.5L19,8h1.5V6.5L21,6h1.5V4.5l1-1V.5Z" }));
    }, Un = function() {
      return l.createElement(u, { size: 16 }, l.createElement("path", { d: "M2.000 2.500 L22.000 2.500 L22.000 23.500 L2.000 23.500 Z" }), l.createElement("path", { d: "M6 4.5L6 0.5" }), l.createElement("path", { d: "M18 4.5L18 0.5" }), l.createElement("path", { d: "M10 4.5L10 0.5" }), l.createElement("path", { d: "M14 4.5L14 0.5" }));
    }, xn = function() {
      return l.createElement(u, { size: 16 }, l.createElement("path", { d: "M17.5 0.498L17.5 23.498" }), l.createElement("path", { d: "M10.5 0.498L10.5 23.498" }), l.createElement("path", { d: "M23.5.5H6.5a6,6,0,0,0,0,12h4" }));
    }, lr = function() {
      return l.createElement(u, { size: 16 }, l.createElement("path", { d: "M2.5 22.995L12 6.005 21.5 22.995 2.5 22.995z" }));
    }, hr = function(z) {
      var K = z.annotation, ue = z.childAnnotation, ve = z.page, Pe = z.viewport, Me = K.hasPopup === !1, Oe = Re(K), xe = Ce(K), Ee = !!(K.hasPopup || Oe || xe), Ie = K.name ? K.name.toLowerCase() : "";
      return l.createElement(Et, { annotation: K, hasPopup: Me, ignoreBorder: !1, isRenderable: Ee, page: ve, viewport: Pe }, function(Le) {
        return l.createElement(l.Fragment, null, l.createElement("div", N({}, Le.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--text", "data-annotation-id": K.id, onClick: Le.popup.toggleOnClick, onMouseEnter: Le.popup.openOnHover, onMouseLeave: Le.popup.closeOnHover }), Ie && l.createElement("div", { className: "rpv-core__annotation-text-icon" }, Ie === "check" && l.createElement(m, null), Ie === "comment" && l.createElement(Xt, null), Ie === "help" && l.createElement(sn, null), Ie === "insert" && l.createElement(lr, null), Ie === "key" && l.createElement(gn, null), Ie === "note" && l.createElement(Un, null), (Ie === "newparagraph" || Ie === "paragraph") && l.createElement(xn, null)), Le.slot.children), ue && ue.annotationType === e.AnnotationType.Popup && Le.popup.opened && l.createElement(yt, { annotation: ue, page: ve, viewport: Pe }));
      });
    }, fr = function(z) {
      var K = z.annotation, ue = z.page, ve = z.viewport, Pe = K.hasPopup === !1, Me = Re(K), Oe = Ce(K), xe = !!(K.hasPopup || Me || Oe);
      return l.createElement(Et, { annotation: K, hasPopup: Pe, ignoreBorder: !0, isRenderable: xe, page: ue, viewport: ve }, function(Ee) {
        return l.createElement("div", N({}, Ee.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--underline", "data-annotation-id": K.id, onClick: Ee.popup.toggleOnClick, onMouseEnter: Ee.popup.openOnHover, onMouseLeave: Ee.popup.closeOnHover }), Ee.slot.children);
      });
    }, Fr = function(z) {
      var K = z.annotations, ue = z.doc, ve = z.outlines, Pe = z.page, Me = z.pageIndex, Oe = z.plugins, xe = z.rotation, Ee = z.scale, Ie = z.onExecuteNamedAction, Le = z.onJumpFromLinkAnnotation, rt = z.onJumpToDest, nt = l.useRef(), Qe = Pe.getViewport({ rotation: xe, scale: Ee }).clone({ dontFlip: !0 }), vt = K.filter(function(ft) {
        return !ft.parentId;
      });
      return S(function() {
        var ft = nt.current;
        ft && Oe.forEach(function(ut) {
          ut.onAnnotationLayerRender && ut.onAnnotationLayerRender({ annotations: vt, container: ft, pageIndex: Me, rotation: xe, scale: Ee });
        });
      }, []), l.createElement("div", { ref: nt, className: "rpv-core__annotation-layer", "data-testid": "core__annotation-layer-".concat(Me) }, vt.map(function(ft) {
        var ut = K.find(function(en) {
          return en.parentId === ft.id;
        });
        switch (ft.annotationType) {
          case e.AnnotationType.Caret:
            return l.createElement(oe, { key: ft.id, annotation: ft, page: Pe, viewport: Qe });
          case e.AnnotationType.Circle:
            return l.createElement(He, { key: ft.id, annotation: ft, page: Pe, viewport: Qe });
          case e.AnnotationType.FileAttachment:
            return l.createElement(at, { key: ft.id, annotation: ft, page: Pe, viewport: Qe });
          case e.AnnotationType.FreeText:
            return l.createElement(St, { key: ft.id, annotation: ft, page: Pe, viewport: Qe });
          case e.AnnotationType.Highlight:
            return l.createElement(dt, { key: ft.id, annotation: ft, childAnnotation: ut, page: Pe, viewport: Qe });
          case e.AnnotationType.Ink:
            return l.createElement(ie, { key: ft.id, annotation: ft, page: Pe, viewport: Qe });
          case e.AnnotationType.Line:
            return l.createElement(te, { key: ft.id, annotation: ft, page: Pe, viewport: Qe });
          case e.AnnotationType.Link:
            return l.createElement(Pt, { key: ft.id, annotation: ft, annotationContainerRef: nt, doc: ue, outlines: ve, page: Pe, pageIndex: Me, scale: Ee, viewport: Qe, onExecuteNamedAction: Ie, onJumpFromLinkAnnotation: Le, onJumpToDest: rt });
          case e.AnnotationType.Polygon:
            return l.createElement(mt, { key: ft.id, annotation: ft, page: Pe, viewport: Qe });
          case e.AnnotationType.Polyline:
            return l.createElement(pt, { key: ft.id, annotation: ft, page: Pe, viewport: Qe });
          case e.AnnotationType.Popup:
            return l.createElement(yt, { key: ft.id, annotation: ft, page: Pe, viewport: Qe });
          case e.AnnotationType.Square:
            return l.createElement(Ut, { key: ft.id, annotation: ft, page: Pe, viewport: Qe });
          case e.AnnotationType.Squiggly:
            return l.createElement(Ct, { key: ft.id, annotation: ft, page: Pe, viewport: Qe });
          case e.AnnotationType.Stamp:
            return l.createElement(Mt, { key: ft.id, annotation: ft, page: Pe, viewport: Qe });
          case e.AnnotationType.StrikeOut:
            return l.createElement(zt, { key: ft.id, annotation: ft, page: Pe, viewport: Qe });
          case e.AnnotationType.Text:
            return l.createElement(hr, { key: ft.id, annotation: ft, childAnnotation: ut, page: Pe, viewport: Qe });
          case e.AnnotationType.Underline:
            return l.createElement(fr, { key: ft.id, annotation: ft, page: Pe, viewport: Qe });
          default:
            return l.createElement(l.Fragment, { key: ft.id });
        }
      }));
    }, Ta = function(z) {
      var K = z.page, ue = z.renderAnnotations, ve = M(), Pe = l.useState({ loading: !0, annotations: [] }), Me = Pe[0], Oe = Pe[1];
      return l.useEffect(function() {
        K.getAnnotations({ intent: "display" }).then(function(xe) {
          ve.current && Oe({ loading: !1, annotations: xe });
        });
      }, []), Me.loading ? l.createElement(l.Fragment, null) : ue(Me.annotations);
    }, Aa = function(z) {
      var K = z.doc, ue = z.outlines, ve = z.page, Pe = z.pageIndex, Me = z.plugins, Oe = z.rotation, xe = z.scale, Ee = z.onExecuteNamedAction, Ie = z.onJumpFromLinkAnnotation, Le = z.onJumpToDest;
      return l.createElement(Ta, { page: ve, renderAnnotations: function(rt) {
        return l.createElement(Fr, { annotations: rt, doc: K, outlines: ue, page: ve, pageIndex: Pe, plugins: Me, rotation: Oe, scale: xe, onExecuteNamedAction: Ee, onJumpFromLinkAnnotation: Ie, onJumpToDest: Le });
      } });
    }, Dr = function(z, K) {
      var ue = z % K;
      return ue === 0 ? z : Math.floor(z - ue);
    }, xa = function(z) {
      var K = z.canvasLayerRef, ue = z.height, ve = z.page, Pe = z.pageIndex, Me = z.plugins, Oe = z.rotation, xe = z.scale, Ee = z.width, Ie = z.onRenderCanvasCompleted, Le = l.useRef();
      return S(function() {
        var rt = Le.current;
        rt && rt.cancel();
        var nt = K.current;
        nt.removeAttribute("data-testid"), Me.forEach(function(Wt) {
          Wt.onCanvasLayerRender && Wt.onCanvasLayerRender({ ele: nt, pageIndex: Pe, rotation: Oe, scale: xe, status: e.LayerRenderStatus.PreRender });
        });
        var Qe = ve.getViewport({ rotation: Oe, scale: xe }), vt = window.devicePixelRatio || 1, ft = Math.sqrt(16777216 / (Qe.width * Qe.height)), ut = vt > ft;
        ut ? nt.style.transform = "scale(1, 1)" : nt.style.removeProperty("transform");
        var en = Math.min(ft, vt), Nt = function(Wt, fn) {
          var un, mn;
          if (Math.floor(Wt) === Wt) return [Wt, 1];
          var vn = 1 / Wt;
          if (vn > fn) return [1, fn];
          if (Math.floor(vn) === vn) return [1, vn];
          for (var bn = Wt > 1 ? vn : Wt, Ln = 0, Mn = 1, Hn = 1, Cn = 1; ; ) {
            var Bn = Ln + Hn, In = Mn + Cn;
            if (In > fn) break;
            bn <= Bn / In ? (Hn = (un = [Bn, In])[0], Cn = un[1]) : (Ln = (mn = [Bn, In])[0], Mn = mn[1]);
          }
          return bn < (Ln / Mn + Hn / Cn) / 2 ? bn === Wt ? [Ln, Mn] : [Mn, Ln] : bn === Wt ? [Hn, Cn] : [Cn, Hn];
        }(en, 8), jt = Nt[0], $t = Nt[1];
        nt.width = Dr(Qe.width * en, jt), nt.height = Dr(Qe.height * en, jt), nt.style.width = "".concat(Dr(Qe.width, $t), "px"), nt.style.height = "".concat(Dr(Qe.height, $t), "px"), nt.hidden = !0;
        var Tt = nt.getContext("2d", { alpha: !1 }), Gt = ut || vt !== 1 ? [en, 0, 0, en, 0, 0] : null;
        return Le.current = ve.render({ canvasContext: Tt, transform: Gt, viewport: Qe }), Le.current.promise.then(function() {
          nt.hidden = !1, nt.setAttribute("data-testid", "core__canvas-layer-".concat(Pe)), Me.forEach(function(Wt) {
            Wt.onCanvasLayerRender && Wt.onCanvasLayerRender({ ele: nt, pageIndex: Pe, rotation: Oe, scale: xe, status: e.LayerRenderStatus.DidRender });
          }), Ie();
        }, function() {
          Ie();
        }), function() {
          nt && (nt.width = 0, nt.height = 0);
        };
      }, []), l.createElement("div", { className: "rpv-core__canvas-layer", style: { height: "".concat(ue, "px"), width: "".concat(Ee, "px") } }, l.createElement("canvas", { ref: K }));
    }, La = function(z) {
      var K = z.height, ue = z.page, ve = z.rotation, Pe = z.scale, Me = z.width, Oe = l.useRef();
      return S(function() {
        var xe = Oe.current, Ee = ue.getViewport({ rotation: ve, scale: Pe });
        ue.getOperatorList().then(function(Ie) {
          (function() {
            var Le = Oe.current;
            Le && (Le.innerHTML = "");
          })(), new W.SVGGraphics(ue.commonObjs, ue.objs).getSVG(Ie, Ee).then(function(Le) {
            Le.style.height = "".concat(K, "px"), Le.style.width = "".concat(Me, "px"), xe.appendChild(Le);
          });
        });
      }, []), l.createElement("div", { className: "rpv-core__svg-layer", ref: Oe });
    }, Ia = function(z) {
      var K = z.containerRef, ue = z.page, ve = z.pageIndex, Pe = z.plugins, Me = z.rotation, Oe = z.scale, xe = z.onRenderTextCompleted, Ee = l.useRef(), Ie = function() {
        var Le = K.current;
        Le && ([].slice.call(Le.querySelectorAll(".rpv-core__text-layer-text")).forEach(function(rt) {
          return Le.removeChild(rt);
        }), [].slice.call(Le.querySelectorAll('br[role="presentation"]')).forEach(function(rt) {
          return Le.removeChild(rt);
        }));
      };
      return S(function() {
        var Le = Ee.current;
        Le && Le.cancel();
        var rt = K.current;
        if (rt) {
          rt.removeAttribute("data-testid");
          var nt = ue.getViewport({ rotation: Me, scale: Oe });
          return Pe.forEach(function(Qe) {
            Qe.onTextLayerRender && Qe.onTextLayerRender({ ele: rt, pageIndex: ve, scale: Oe, status: e.LayerRenderStatus.PreRender });
          }), ue.getTextContent().then(function(Qe) {
            Ie(), Ee.current = W.renderTextLayer({ container: rt, textContent: Qe, textContentSource: Qe, viewport: nt }), Ee.current.promise.then(function() {
              rt.setAttribute("data-testid", "core__text-layer-".concat(ve)), [].slice.call(rt.children).forEach(function(vt) {
                vt.classList.contains("rpv-core__text-layer-text--not") || vt.classList.add("rpv-core__text-layer-text");
              }), Pe.forEach(function(vt) {
                vt.onTextLayerRender && vt.onTextLayerRender({ ele: rt, pageIndex: ve, scale: Oe, status: e.LayerRenderStatus.DidRender });
              }), xe();
            }, function() {
              rt.removeAttribute("data-testid"), xe();
            });
          }), function() {
            var Qe;
            Ie(), (Qe = Ee.current) === null || Qe === void 0 || Qe.cancel();
          };
        }
      }, []), l.createElement("div", { className: "rpv-core__text-layer", ref: K });
    }, Fa = function(z) {
      var K = z.doc, ue = z.measureRef, ve = z.outlines, Pe = z.pageIndex, Me = z.pageRotation, Oe = z.pageSize, xe = z.plugins, Ee = z.renderPage, Ie = z.renderQueueKey, Le = z.rotation, rt = z.scale, nt = z.shouldRender, Qe = z.viewMode, vt = z.onExecuteNamedAction, ft = z.onJumpFromLinkAnnotation, ut = z.onJumpToDest, en = z.onRenderCompleted, Nt = z.onRotatePage, jt = M(), $t = l.useState(null), Tt = $t[0], Gt = $t[1], Wt = l.useState(!1), fn = Wt[0], un = Wt[1], mn = l.useState(!1), vn = mn[0], bn = mn[1], Ln = l.useRef(), Mn = l.useRef(), Hn = Math.abs(Le + Me) % 180 == 0, Cn = Oe.pageWidth * rt, Bn = Oe.pageHeight * rt, In = Hn ? Cn : Bn, Fn = Hn ? Bn : Cn, Kn = (Oe.rotation + Le + Me) % 360, mr = l.useRef(0), ur = Ee || function(jn) {
        return l.createElement(l.Fragment, null, jn.canvasLayer.children, jn.textLayer.children, jn.annotationLayer.children);
      };
      return l.useEffect(function() {
        Gt(null), un(!1), bn(!1);
      }, [Me, Le, rt]), l.useEffect(function() {
        nt && jt.current && !Tt && tt(K, Pe).then(function(jn) {
          jt.current && (mr.current = Ie, Gt(jn));
        });
      }, [nt, Tt]), l.useEffect(function() {
        fn && vn && (Ie !== mr.current ? (Gt(null), un(!1), bn(!1)) : en(Pe));
      }, [fn, vn]), l.createElement("div", { className: P({ "rpv-core__page-layer": !0, "rpv-core__page-layer--dual": Qe === e.ViewMode.DualPage, "rpv-core__page-layer--dual-cover": Qe === e.ViewMode.DualPageWithCover, "rpv-core__page-layer--single": Qe === e.ViewMode.SinglePage }), "data-testid": "core__page-layer-".concat(Pe), ref: ue, style: { height: "".concat(Fn, "px"), width: "".concat(In, "px") } }, Tt ? l.createElement(l.Fragment, null, ur({ annotationLayer: { attrs: {}, children: l.createElement(Aa, { doc: K, outlines: ve, page: Tt, pageIndex: Pe, plugins: xe, rotation: Kn, scale: rt, onExecuteNamedAction: vt, onJumpFromLinkAnnotation: ft, onJumpToDest: ut }) }, canvasLayer: { attrs: {}, children: l.createElement(xa, { canvasLayerRef: Ln, height: Fn, page: Tt, pageIndex: Pe, plugins: xe, rotation: Kn, scale: rt, width: In, onRenderCanvasCompleted: function() {
        jt.current && un(!0);
      } }) }, canvasLayerRendered: fn, doc: K, height: Fn, pageIndex: Pe, rotation: Kn, scale: rt, svgLayer: { attrs: {}, children: l.createElement(La, { height: Fn, page: Tt, rotation: Kn, scale: rt, width: In }) }, textLayer: { attrs: {}, children: l.createElement(Ia, { containerRef: Mn, page: Tt, pageIndex: Pe, plugins: xe, rotation: Kn, scale: rt, onRenderTextCompleted: function() {
        jt.current && bn(!0);
      } }) }, textLayerRendered: vn, width: In, markRendered: en, onRotatePage: function(jn) {
        return Nt(Pe, jn);
      } }), xe.map(function(jn, Xn) {
        return jn.renderPageLayer ? l.createElement(l.Fragment, { key: Xn }, jn.renderPageLayer({ canvasLayerRef: Ln, canvasLayerRendered: fn, doc: K, height: Fn, pageIndex: Pe, rotation: Kn, scale: rt, textLayerRef: Mn, textLayerRendered: vn, width: In })) : l.createElement(l.Fragment, { key: Xn });
      })) : l.createElement(w, { testId: "core__page-layer-loading-".concat(Pe) }));
    }, Da = function(z, K) {
      var ue = K.rect;
      return z.height !== ue.height || z.width !== ue.width ? ue : z;
    };
    (function(z) {
      z.Horizontal = "Horizontal", z.Vertical = "Vertical", z.Both = "Both";
    })(bt || (bt = {}));
    var Oa = function(z) {
      return 1 - Math.pow(1 - z, 4);
    }, Or = 1e-4, ia = { left: 0, top: 0 }, oa = { capture: !1, passive: !0 }, Na = function(z) {
      var K = z.elementRef, ue = z.enableSmoothScroll, ve = z.isRtl, Pe = z.scrollDirection, Me = z.onSmoothScroll, Oe = l.useState(ia), xe = Oe[0], Ee = Oe[1], Ie = l.useState(K.current), Le = Ie[0], rt = Ie[1], nt = ve ? -1 : 1, Qe = l.useRef(Pe);
      Qe.current = Pe;
      var vt = l.useRef(ia), ft = l.useRef(!0), ut = l.useCallback(function() {
        ft.current = !0, ue && Ee(vt.current), Me(!1);
      }, []), en = l.useCallback(function() {
        if (Le) {
          switch (Qe.current) {
            case bt.Horizontal:
              vt.current = { left: nt * Le.scrollLeft, top: 0 };
              break;
            case bt.Both:
              vt.current = { left: nt * Le.scrollLeft, top: Le.scrollTop };
              break;
            case bt.Vertical:
            default:
              vt.current = { left: 0, top: Le.scrollTop };
          }
          ue && !ft.current || Ee(vt.current);
        }
      }, [Le]);
      S(function() {
        rt(K.current);
      }), S(function() {
        if (Le) return Le.addEventListener("scroll", en, oa), function() {
          Le.removeEventListener("scroll", en, oa);
        };
      }, [Le]);
      var Nt = l.useCallback(function(jt, $t) {
        var Tt = K.current;
        if (!Tt) return Promise.resolve();
        var Gt = { left: 0, top: 0 };
        switch (Qe.current) {
          case bt.Horizontal:
            Gt.left = nt * jt.left;
            break;
          case bt.Both:
            Gt.left = nt * jt.left, Gt.top = jt.top;
            break;
          case bt.Vertical:
          default:
            Gt.top = jt.top;
        }
        return $t ? (ft.current = !1, Me(!0), new Promise(function(Wt, fn) {
          (function(un, mn, vn, bn, Ln, Mn) {
            Ln === void 0 && (Ln = function(Xn) {
              return Xn;
            }), Mn === void 0 && (Mn = function() {
            });
            var Hn = 0, Cn = 0, Bn = !1;
            switch (mn) {
              case bt.Horizontal:
                Cn = un.scrollLeft, Hn = 0;
              case bt.Both:
                Cn = un.scrollLeft, Hn = un.scrollTop;
                break;
              case bt.Vertical:
              default:
                Cn = 0, Hn = un.scrollTop;
            }
            var In = function() {
              Bn || (Bn = !0, un.scrollLeft = vn.left, un.scrollTop = vn.top, Mn());
            };
            if (Math.abs(Hn - vn.top) <= Or && mn === bt.Vertical) In();
            else if (Math.abs(Cn - vn.left) <= Or && mn === bt.Horizontal) In();
            else {
              var Fn, Kn = -1, mr = Cn - vn.left, ur = Hn - vn.top, jn = function(Xn) {
                Kn === -1 && (Kn = Xn);
                var Er = Xn - Kn, qt = Math.min(Er / bn, 1), Vt = Ln(qt), At = { left: Cn - mr * Vt, top: Hn - ur * Vt };
                switch (mn) {
                  case bt.Horizontal:
                    un.scrollLeft = At.left;
                    break;
                  case bt.Both:
                    un.scrollLeft = At.left, un.scrollTop = At.top;
                    break;
                  case bt.Vertical:
                  default:
                    un.scrollTop = At.top;
                }
                Math.abs(At.top - vn.top) <= Or && Math.abs(At.left - vn.left) <= Or && !Bn && (window.cancelAnimationFrame(Fn), In()), Er < bn ? Fn = window.requestAnimationFrame(jn) : window.cancelAnimationFrame(Fn);
              };
              Fn = window.requestAnimationFrame(jn);
            }
          })(Tt, Qe.current, Gt, 400, Oa, function() {
            ut(), Wt();
          });
        })) : new Promise(function(Wt, fn) {
          switch (Qe.current) {
            case bt.Horizontal:
              Tt.scrollLeft = Gt.left;
              break;
            case bt.Both:
              Tt.scrollLeft = Gt.left, Tt.scrollTop = Gt.top;
              break;
            case bt.Vertical:
            default:
              Tt.scrollTop = Gt.top;
          }
          Wt();
        });
      }, [K]);
      return { scrollOffset: xe, scrollTo: Nt };
    }, Tr = function(z, K, ue) {
      return Math.max(z, Math.min(ue, K));
    }, Ba = function(z, K) {
      if (K !== e.ViewMode.DualPageWithCover) return 0;
      if (!function(Pe) {
        var Me = Pe.length;
        if (Me === 1) return !1;
        for (var Oe = 1; Oe < Me; Oe++) if (Pe[Oe].height !== Pe[0].height || Pe[Oe].width !== Pe[0].width) return !0;
        return !1;
      }(z)) return 2 * z[0].width;
      var ue = de(z.slice(1), 2).map(function(Pe) {
        return Pe.length === 2 ? Pe[0].width + Pe[1].width : Pe[0].width;
      }), ve = [z[0].width].concat(ue);
      return Math.max.apply(Math, ve);
    }, za = { left: 0, top: 0 }, ja = { left: 0, top: 0 }, Ur = { left: 0, top: 0 }, Va = { left: 0, top: 0 }, Ha = { height: 0, width: 0 }, sa = { left: 0, top: 0 }, Ar = "data-virtual-index", qa = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1], Wa = function(z) {
      var K = z.enableSmoothScroll, ue = z.isRtl, ve = z.numberOfItems, Pe = z.parentRef, Me = z.setRenderRange, Oe = z.sizes, xe = z.scrollMode, Ee = z.viewMode, Ie = l.useState(!1), Le = Ie[0], rt = Ie[1], nt = l.useCallback(function(qt) {
        return rt(qt);
      }, []), Qe = l.useRef(xe);
      Qe.current = xe;
      var vt = l.useRef(Ee);
      vt.current = Ee;
      var ft = xe === e.ScrollMode.Wrapped || Ee === e.ViewMode.DualPageWithCover || Ee === e.ViewMode.DualPage ? bt.Both : xe === e.ScrollMode.Horizontal ? bt.Horizontal : bt.Vertical, ut = Na({ elementRef: Pe, enableSmoothScroll: K, isRtl: ue, scrollDirection: ft, onSmoothScroll: nt }), en = ut.scrollOffset, Nt = ut.scrollTo, jt = function(qt) {
        var Vt = qt.elementRef, At = l.useState(Vt.current), Dt = At[0], Lt = At[1], Kt = l.useRef(!1), Yt = l.useReducer(Da, { height: 0, width: 0 }), Ft = Yt[0], kt = Yt[1];
        return S(function() {
          Vt.current !== Dt && Lt(Vt.current);
        }), S(function() {
          if (Dt && !Kt.current) {
            Kt.current = !0;
            var Qt = Dt.getBoundingClientRect(), an = Qt.height, h = Qt.width;
            kt({ rect: { height: an, width: h } });
          }
        }, [Dt]), l.useEffect(function() {
          if (Dt) {
            var Qt = new ResizeObserver(function(an, h) {
              an.forEach(function(O) {
                if (O.target === Dt) {
                  var Y = O.contentRect, ee = Y.height, J = Y.width;
                  kt({ rect: { height: ee, width: J } });
                }
              });
            });
            return Qt.observe(Dt), function() {
              Qt.unobserve(Dt);
            };
          }
        }, [Dt]), Ft;
      }({ elementRef: Pe }), $t = l.useRef({ scrollOffset: sa, measurements: [] });
      $t.current.scrollOffset = en;
      var Tt = l.useMemo(function() {
        return Array(ve).fill(-1);
      }, []), Gt = l.useState(Tt), Wt = Gt[0], fn = Gt[1], un = l.useMemo(function() {
        var qt = new IntersectionObserver(function(Vt) {
          Vt.forEach(function(At) {
            var Dt = At.isIntersecting ? At.intersectionRatio : -1, Lt = At.target.getAttribute(Ar);
            if (Lt) {
              var Kt = parseInt(Lt, 10);
              0 <= Kt && Kt < ve && fn(function(Yt) {
                return Yt[Kt] = Dt, function(Ft, kt, Qt) {
                  for (var an, h = 0, O = kt.length; h < O; h++) !an && h in kt || (an || (an = Array.prototype.slice.call(kt, 0, h)), an[h] = kt[h]);
                  return Ft.concat(an || Array.prototype.slice.call(kt));
                }([], Yt);
              });
            }
          });
        }, { threshold: qa });
        return qt;
      }, []), mn = l.useMemo(function() {
        return xe === e.ScrollMode.Page && Ee === e.ViewMode.SinglePage ? function(qt, Vt, At) {
          for (var Dt = [], Lt = 0; Lt < qt; Lt++) {
            var Kt = { height: Math.max(Vt.height, At[Lt].height), width: Math.max(Vt.width, At[Lt].width) }, Yt = Lt === 0 ? Va : Dt[Lt - 1].end, Ft = { left: Yt.left + Kt.width, top: Yt.top + Kt.height };
            Dt[Lt] = { index: Lt, start: Yt, size: Kt, end: Ft, visibility: -1 };
          }
          return Dt;
        }(ve, jt, Oe) : Ee === e.ViewMode.DualPageWithCover ? function(qt, Vt, At, Dt) {
          for (var Lt = [], Kt = 0, Yt = 0, Ft = Ur, kt = 0; kt < qt; kt++) {
            var Qt = kt === 0 ? { height: Dt === e.ScrollMode.Page ? Math.max(Vt.height, At[kt].height) : At[kt].height, width: Dt === e.ScrollMode.Page ? Math.max(Vt.width, At[kt].width) : At[kt].width } : { height: Dt === e.ScrollMode.Page ? Math.max(Vt.height, At[kt].height) : At[kt].height, width: Math.max(Vt.width / 2, At[kt].width) };
            Dt === e.ScrollMode.Page ? Ft = kt === 0 ? Ur : { left: kt % 2 == 0 ? Qt.width : 0, top: Math.floor((kt - 1) / 2) * Qt.height + Lt[0].end.top } : kt === 0 ? (Ft = Ur, Kt = At[0].height, Yt = 0) : kt % 2 == 1 ? (Ft = { left: 0, top: Kt += Yt }, Yt = kt === qt - 1 ? At[kt].height : Math.max(At[kt].height, At[kt + 1].height)) : Ft = { left: Lt[kt - 1].end.left, top: Kt };
            var an = { left: Ft.left + Qt.width, top: Ft.top + Qt.height };
            Lt[kt] = { index: kt, start: Ft, size: Qt, end: an, visibility: -1 };
          }
          return Lt;
        }(ve, jt, Oe, xe) : Ee === e.ViewMode.DualPage ? function(qt, Vt, At, Dt) {
          for (var Lt = [], Kt = 0, Yt = 0, Ft = ja, kt = 0; kt < qt; kt++) {
            var Qt = { height: Dt === e.ScrollMode.Page ? Math.max(Vt.height, At[kt].height) : At[kt].height, width: Math.max(Vt.width / 2, At[kt].width) };
            Dt === e.ScrollMode.Page ? Ft = { left: kt % 2 == 0 ? 0 : Qt.width, top: Math.floor(kt / 2) * Qt.height } : kt % 2 == 0 ? (Ft = { left: 0, top: Kt += Yt }, Yt = kt === qt - 1 ? At[kt].height : Math.max(At[kt].height, At[kt + 1].height)) : Ft = { left: Lt[kt - 1].end.left, top: Kt };
            var an = { left: Ft.left + Qt.width, top: Ft.top + Qt.height };
            Lt[kt] = { index: kt, start: Ft, size: Qt, end: an, visibility: -1 };
          }
          return Lt;
        }(ve, jt, Oe, xe) : function(qt, Vt, At, Dt) {
          for (var Lt = [], Kt = 0, Yt = { left: 0, top: 0 }, Ft = 0, kt = za, Qt = 0; Qt < qt; Qt++) {
            var an = At[Qt];
            if (Qt === 0) Kt = an.width, Yt = { left: 0, top: 0 }, Ft = an.height;
            else switch (Dt) {
              case e.ScrollMode.Wrapped:
                (Kt += an.width) < Vt.width ? (kt = { left: Lt[Qt - 1].end.left, top: Yt.top }, Ft = Math.max(Ft, an.height)) : (Kt = an.width, Yt = { left: (kt = { left: Yt.left, top: Yt.top + Ft }).left, top: kt.top }, Ft = an.height);
                break;
              case e.ScrollMode.Horizontal:
              case e.ScrollMode.Vertical:
              default:
                kt = Lt[Qt - 1].end;
            }
            var h = { left: kt.left + an.width, top: kt.top + an.height };
            Lt[Qt] = { index: Qt, start: kt, size: an, end: h, visibility: -1 };
          }
          return Lt;
        }(ve, jt, Oe, xe);
      }, [xe, Oe, Ee, jt]), vn = mn[ve - 1] ? { height: mn[ve - 1].end.top, width: mn[ve - 1].end.left } : Ha;
      $t.current.measurements = mn;
      var bn = l.useMemo(function() {
        var qt = function(Qt, an, h, O) {
          var Y = 0;
          switch (Qt) {
            case bt.Horizontal:
              Y = O.left;
              break;
            case bt.Vertical:
            default:
              Y = O.top;
          }
          var ee = an.length - 1, J = function(Se, Fe, ze, Ue) {
            for (; Se <= Fe; ) {
              var ot = (Se + Fe) / 2 | 0, Ze = Ue(ot);
              if (Ze < ze) Se = ot + 1;
              else {
                if (!(Ze > ze)) return ot;
                Fe = ot - 1;
              }
            }
            return Se > 0 ? Se - 1 : 0;
          }(0, ee, Y, function(Se) {
            switch (Qt) {
              case bt.Horizontal:
                return an[Se].start.left;
              case bt.Both:
              case bt.Vertical:
              default:
                return an[Se].start.top;
            }
          });
          if (Qt === bt.Both) for (var ae = an[J].start.top; J - 1 >= 0 && an[J - 1].start.top === ae && an[J - 1].start.left >= O.left; ) J--;
          for (var se = J; se <= ee; ) {
            var he = { top: an[se].start.top - O.top, left: an[se].start.left - O.left }, ne = { height: h.height - he.top, width: h.width - he.left };
            if (Qt === bt.Horizontal && ne.width < 0 || Qt === bt.Vertical && ne.height < 0 || Qt === bt.Both && (ne.width < 0 || ne.height < 0)) break;
            se++;
          }
          return { start: J, end: se };
        }(ft, mn, jt, en), Vt = qt.start, At = qt.end, Dt = Wt.slice(Tr(0, ve, Vt), Tr(0, ve, At)), Lt = Vt + Dt.reduce(function(Qt, an, h, O) {
          return an > O[Qt] ? h : Qt;
        }, 0), Kt = Lt = Tr(0, ve - 1, Lt), Yt = Me({ endPage: At, numPages: ve, startPage: Vt }), Ft = Yt.startPage, kt = Yt.endPage;
        switch (Ft = Math.max(Ft, 0), kt = Math.min(kt, ve - 1), Ee) {
          case e.ViewMode.DualPageWithCover:
            Lt > 0 && (Kt = Lt % 2 == 1 ? Lt : Lt - 1), Ft = Ft === 0 ? 0 : Ft % 2 == 1 ? Ft : Ft - 1, ve - (kt = kt % 2 == 1 ? kt - 1 : kt) <= 2 && (kt = ve - 1);
            break;
          case e.ViewMode.DualPage:
            Kt = Lt % 2 == 0 ? Lt : Lt - 1, Ft = Ft % 2 == 0 ? Ft : Ft - 1, kt = kt % 2 == 1 ? kt : kt - 1;
            break;
          case e.ViewMode.SinglePage:
          default:
            Kt = Lt;
        }
        return { startPage: Ft, endPage: kt, maxVisbilityIndex: Kt };
      }, [mn, jt, en, Ee, Wt]), Ln = bn.startPage, Mn = bn.endPage, Hn = bn.maxVisbilityIndex, Cn = l.useMemo(function() {
        for (var qt = [], Vt = function(Dt) {
          var Lt = mn[Dt], Kt = N(N({}, Lt), { visibility: Wt[Dt] !== void 0 ? Wt[Dt] : -1, measureRef: function(Yt) {
            Yt && (Yt.setAttribute(Ar, "".concat(Dt)), un.observe(Yt));
          } });
          qt.push(Kt);
        }, At = Ln; At <= Mn; At++) Vt(At);
        return qt;
      }, [Ln, Mn, Wt, mn]), Bn = l.useCallback(function(qt, Vt) {
        var At = $t.current.measurements[Tr(0, ve - 1, qt)], Dt = Qe.current === e.ScrollMode.Page ? sa : Vt;
        return At ? Nt({ left: Dt.left + At.start.left, top: Dt.top + At.start.top }, K) : Promise.resolve();
      }, [Nt, K]), In = l.useCallback(function(qt, Vt) {
        var At = $t.current.measurements, Dt = At[qt].start, Lt = At.find(function(Yt) {
          return Yt.start.top - Dt.top > 1e-12;
        });
        if (!Lt) return Promise.resolve();
        var Kt = Lt.index;
        switch (vt.current) {
          case e.ViewMode.DualPage:
            Kt = Kt % 2 == 0 ? Kt : Kt + 1;
            break;
          case e.ViewMode.DualPageWithCover:
            Kt = Kt % 2 == 1 ? Kt : Kt + 1;
        }
        return Bn(Kt, Vt);
      }, []), Fn = l.useCallback(function(qt, Vt) {
        for (var At = $t.current.measurements, Dt = At[qt].start, Lt = qt, Kt = !1, Yt = ve - 1; Yt >= 0; Yt--) if (Dt.top - At[Yt].start.top > 1e-12) {
          Kt = !0, Lt = At[Yt].index;
          break;
        }
        if (!Kt) return Promise.resolve();
        switch (vt.current) {
          case e.ViewMode.DualPage:
            Lt = Lt % 2 == 0 ? Lt : Lt - 1;
            break;
          case e.ViewMode.DualPageWithCover:
            Lt = Lt % 2 == 0 ? Lt - 1 : Lt;
        }
        return Lt === qt && (Lt = qt - 1), Bn(Lt, Vt);
      }, []), Kn = l.useCallback(function(qt, Vt) {
        if (vt.current === e.ViewMode.DualPageWithCover || vt.current === e.ViewMode.DualPage) return In(qt, Vt);
        switch (Qe.current) {
          case e.ScrollMode.Wrapped:
            return In(qt, Vt);
          case e.ScrollMode.Horizontal:
          case e.ScrollMode.Vertical:
          default:
            return Bn(qt + 1, Vt);
        }
      }, []), mr = l.useCallback(function(qt, Vt) {
        if (vt.current === e.ViewMode.DualPageWithCover || vt.current === e.ViewMode.DualPage) return Fn(qt, Vt);
        switch (Qe.current) {
          case e.ScrollMode.Wrapped:
            return Fn(qt, Vt);
          case e.ScrollMode.Horizontal:
          case e.ScrollMode.Vertical:
          default:
            return Bn(qt - 1, Vt);
        }
      }, []), ur = l.useCallback(function() {
        return function(qt, Vt) {
          switch (Vt) {
            case e.ScrollMode.Horizontal:
              return { position: "relative", height: "100%", width: "".concat(qt.width, "px") };
            case e.ScrollMode.Vertical:
            default:
              return { position: "relative", height: "".concat(qt.height, "px"), width: "100%" };
          }
        }(vn, Qe.current);
      }, [vn]), jn = l.useCallback(function(qt) {
        return function(Vt, At, Dt) {
          return Dt !== e.ScrollMode.Page ? {} : { height: "".concat(At.height, "px"), width: "100%", position: "absolute", top: 0, transform: "translateY(".concat(Vt.start.top, "px)") };
        }(qt, jt, Qe.current);
      }, [jt]), Xn = l.useCallback(function(qt) {
        return function(Vt, At, Dt, Lt, Kt) {
          var Yt, Ft, kt, Qt, an, h, O, Y = At ? "right" : "left", ee = At ? -1 : 1, J = Dt.length, ae = Vt.start.left * ee, se = Vt.size, he = se.height, ne = se.width;
          if (Lt === e.ViewMode.DualPageWithCover) {
            var Se = Kt === e.ScrollMode.Page ? 0 : Vt.start.top;
            return Vt.index === 0 || J % 2 == 0 && Vt.index === J - 1 ? ((Yt = { height: "".concat(he, "px"), minWidth: "".concat(Ba(Dt, Lt), "px"), width: "100%" })[Y] = 0, Yt.position = "absolute", Yt.top = 0, Yt.transform = "translate(".concat(ae, "px, ").concat(Se, "px)"), Yt) : ((Ft = { height: "".concat(he, "px"), width: "".concat(ne, "px") })[Y] = 0, Ft.position = "absolute", Ft.top = 0, Ft.transform = "translate(".concat(ae, "px, ").concat(Se, "px)"), Ft);
          }
          if (Lt === e.ViewMode.DualPage) return (kt = { height: "".concat(he, "px"), width: "".concat(ne, "px") })[Y] = 0, kt.position = "absolute", kt.top = 0, kt.transform = "translate(".concat(ae, "px, ").concat(Kt === e.ScrollMode.Page ? 0 : Vt.start.top, "px)"), kt;
          switch (Kt) {
            case e.ScrollMode.Horizontal:
              return (Qt = { height: "100%", width: "".concat(ne, "px") })[Y] = 0, Qt.position = "absolute", Qt.top = 0, Qt.transform = "translateX(".concat(ae, "px)"), Qt;
            case e.ScrollMode.Page:
              return (an = { height: "".concat(he, "px"), width: "".concat(ne, "px") })[Y] = 0, an.position = "absolute", an.top = 0, an;
            case e.ScrollMode.Wrapped:
              return (h = { height: "".concat(he, "px"), width: "".concat(ne, "px") })[Y] = 0, h.position = "absolute", h.top = 0, h.transform = "translate(".concat(ae, "px, ").concat(Vt.start.top, "px)"), h;
            case e.ScrollMode.Vertical:
            default:
              return (O = { height: "".concat(he, "px"), width: "100%" })[Y] = 0, O.position = "absolute", O.top = 0, O.transform = "translateY(".concat(Vt.start.top, "px)"), O;
          }
        }(qt, ue, Oe, vt.current, Qe.current);
      }, [ue, Oe]), Er = l.useCallback(function(qt, Vt) {
        var At = $t.current, Dt = At.measurements, Lt = At.scrollOffset, Kt = Dt[Tr(0, ve - 1, Vt)];
        if (Kt) {
          var Yt = Qe.current === e.ScrollMode.Page ? { left: Kt.start.left, top: Kt.start.top } : { left: Lt.left * qt, top: Lt.top * qt };
          return Nt(Yt, !1);
        }
        return Promise.resolve();
      }, []);
      return l.useEffect(function() {
        return function() {
          un.disconnect();
        };
      }, []), { boundingClientRect: jt, isSmoothScrolling: Le, startPage: Ln, endPage: Mn, maxVisbilityIndex: Hn, virtualItems: Cn, getContainerStyles: ur, getItemContainerStyles: jn, getItemStyles: Xn, scrollToItem: Bn, scrollToNextItem: Kn, scrollToPreviousItem: mr, zoom: Er };
    }, $r = function(z, K, ue, ve, Pe, Me) {
      var Oe = ue;
      switch (!0) {
        case (Pe === e.ViewMode.DualPageWithCover && Me >= 3):
        case (Pe === e.ViewMode.DualPage && Me >= 3):
          Oe = 2 * ue;
          break;
        default:
          Oe = ue;
      }
      switch (ve) {
        case e.SpecialZoomLevel.ActualSize:
          return 1;
        case e.SpecialZoomLevel.PageFit:
          return Math.min((z.clientWidth - 17) / Oe, (z.clientHeight - 16) / K);
        case e.SpecialZoomLevel.PageWidth:
          return (z.clientWidth - 17) / Oe;
      }
    }, Ua = function(z) {
      var K, ue, ve = z.getCurrentPage, Pe = (K = 50, ue = l.useRef([]), l.useEffect(function() {
        return function() {
          ue.current = [];
        };
      }, []), { push: function(Ie) {
        var Le = ue.current;
        Le.length + 1 > K && Le.shift(), Le.push(Ie), ue.current = Le;
      }, map: function(Ie) {
        return ue.current.map(function(Le) {
          return Ie(Le);
        });
      }, pop: function() {
        var Ie = ue.current;
        if (Ie.length === 0) return null;
        var Le = Ie.pop();
        return ue.current = Ie, Le;
      } }), Me = function(Ie) {
        var Le = l.useRef([]);
        return l.useEffect(function() {
          return function() {
            Le.current = [];
          };
        }, []), { dequeue: function() {
          var rt = Le.current;
          if (rt.length === 0) return null;
          var nt = rt.shift();
          return Le.current = rt, nt || null;
        }, enqueue: function(rt) {
          var nt = Le.current;
          nt.length + 1 > Ie && nt.pop(), Le.current = [rt].concat(nt);
        }, map: function(rt) {
          return Le.current.map(function(nt) {
            return rt(nt);
          });
        } };
      }(50), Oe = function() {
        var Ie = Me.dequeue();
        return Ie && Pe.push(Ie), Ie && Ie.pageIndex === ve() ? Oe() : Ie;
      }, xe = function() {
        var Ie = Pe.pop();
        return Ie && Me.enqueue(Ie), Ie && Ie.pageIndex === ve() ? xe() : Ie;
      }, Ee = l.useCallback(function(Ie) {
        Pe.push(Ie);
      }, []);
      return { getNextDestination: Oe, getPreviousDestination: xe, markVisitedDestination: Ee };
    }, ca = function(z) {
      var K = [];
      return z.map(function(ue) {
        K = K.concat(ue).concat(function(ve) {
          var Pe = [];
          return ve.items && ve.items.length > 0 && (Pe = Pe.concat(ca(ve.items))), Pe;
        }(ue));
      }), K;
    }, la = { capture: !1, passive: !0 }, $a = { height: 0, width: 0 }, Gr = { height: 0, width: 0 }, Sn = function(z) {
      var K = z.getCurrentPage, ue = z.getCurrentScrollMode, ve = z.jumpToPage, Pe = z.targetRef, Me = l.useState(e.FullScreenMode.Normal), Oe = Me[0], xe = Me[1], Ee = function() {
        var Wt = l.useState($a), fn = Wt[0], un = Wt[1], mn = R(function() {
          un({ height: window.innerHeight, width: window.innerWidth });
        }, 100);
        return S(function() {
          return window.addEventListener("resize", mn, la), function() {
            window.removeEventListener("resize", mn, la);
          };
        }, []), fn;
      }(), Ie = l.useState(Gr), Le = Ie[0], rt = Ie[1], nt = l.useRef(Gr), Qe = l.useRef(K()), vt = l.useRef(Gr), ft = l.useState(Pe.current), ut = ft[0], en = ft[1], Nt = l.useRef();
      S(function() {
        Pe.current !== ut && en(Pe.current);
      }, []), S(function() {
        if (ut) {
          var Wt = new ResizeObserver(function(fn) {
            fn.forEach(function(un) {
              var mn = un.target.getBoundingClientRect(), vn = mn.height, bn = mn.width;
              rt({ height: vn, width: bn });
            });
          });
          return Wt.observe(ut), function() {
            Wt.unobserve(ut), Wt.disconnect();
          };
        }
      }, [ut]);
      var jt = l.useCallback(function(Wt) {
        var fn = C();
        return fn && fn !== Wt ? (xe(e.FullScreenMode.Normal), f(fn)) : Promise.resolve();
      }, []), $t = l.useCallback(function(Wt) {
        Wt && a() && (en(Wt), jt(Wt).then(function() {
          Nt.current = Wt, xe(e.FullScreenMode.Entering), function(fn) {
            v && fn[k.RequestFullScreen]();
          }(Wt);
        }));
      }, []), Tt = l.useCallback(function() {
        C() && (xe(e.FullScreenMode.Exitting), f(document));
      }, []), Gt = l.useCallback(function() {
        ut && C() !== ut && xe(e.FullScreenMode.Exitting);
      }, [ut]);
      return l.useEffect(function() {
        switch (Oe) {
          case e.FullScreenMode.Entering:
            Nt.current && (Nt.current.style.backgroundColor = "var(--rpv-core__full-screen-target-background-color)"), Qe.current = K(), nt.current = { height: window.innerHeight, width: window.innerWidth };
            break;
          case e.FullScreenMode.Entered:
            ue() === e.ScrollMode.Page ? ve(Qe.current).then(function() {
              xe(e.FullScreenMode.EnteredCompletely);
            }) : xe(e.FullScreenMode.EnteredCompletely);
            break;
          case e.FullScreenMode.Exitting:
            Nt.current && (Nt.current.style.backgroundColor = "", Nt.current = null), Qe.current = K();
            break;
          case e.FullScreenMode.Exited:
            xe(e.FullScreenMode.Normal), ue() === e.ScrollMode.Page && ve(Qe.current);
        }
      }, [Oe]), l.useEffect(function() {
        if (Oe !== e.FullScreenMode.Normal) return Oe === e.FullScreenMode.Entering && Ee.height === Le.height && Ee.width === Le.width && Ee.height > 0 && Ee.width > 0 && (vt.current.height === 0 || Ee.height == vt.current.height) ? (vt.current = { height: window.innerHeight, width: window.innerWidth }, void xe(e.FullScreenMode.Entered)) : void (Oe === e.FullScreenMode.Exitting && nt.current.height === Ee.height && nt.current.width === Ee.width && Ee.height > 0 && Ee.width > 0 && xe(e.FullScreenMode.Exited));
      }, [Oe, Ee, Le]), l.useEffect(function() {
        var Wt;
        return Wt = Gt, v && document.addEventListener(k.FullScreenChange, Wt), function() {
          (function(fn) {
            v && document.removeEventListener(k.FullScreenChange, fn);
          })(Gt);
        };
      }, [ut]), { enterFullScreenMode: $t, exitFullScreenMode: Tt, fullScreenMode: Oe };
    }, Ga = { buildPageStyles: function() {
      return {};
    }, transformSize: function(z) {
      return z.size;
    } }, br = { left: 0, top: 0 }, Ka = function(z) {
      var K = z.currentFile, ue = z.defaultScale, ve = z.doc, Pe = z.enableSmoothScroll, Me = z.initialPage, Oe = z.initialRotation, xe = z.initialScale, Ee = z.pageLayout, Ie = z.pageSizes, Le = z.plugins, rt = z.renderPage, nt = z.scrollMode, Qe = z.setRenderRange, vt = z.viewMode, ft = z.viewerState, ut = z.onDocumentLoad, en = z.onOpenFile, Nt = z.onPageChange, jt = z.onRotate, $t = z.onRotatePage, Tt = z.onZoom, Gt = ve.numPages, Wt = ve.loadingTask.docId, fn = l.useContext(j).l10n, un = l.useContext(B), mn = un.direction === e.TextDirection.RightToLeft, vn = l.useRef(), bn = l.useRef(), Ln = l.useState(Me), Mn = Ln[0], Hn = Ln[1], Cn = l.useRef(null), Bn = Ua({ getCurrentPage: function() {
        return J.current.pageIndex;
      } }), In = l.useState(Oe), Fn = In[0], Kn = In[1], mr = I(Fn), ur = l.useState(!1), jn = ur[0], Xn = ur[1], Er = l.useState(/* @__PURE__ */ new Map()), qt = Er[0], Vt = Er[1], At = l.useState(nt), Dt = At[0], Lt = At[1], Kt = I(Dt), Yt = l.useState(vt), Ft = Yt[0], kt = Yt[1], Qt = I(Ft), an = function(Ke) {
        var Ot = M(), on = l.useState([]), pn = on[0], hn = on[1];
        return l.useEffect(function() {
          Ke.getOutline().then(function(Jt) {
            if (Ot.current && Jt !== null) {
              var zn = ca(Jt);
              hn(zn);
            }
          });
        }, []), pn;
      }(ve), h = l.useState(xe), O = h[0], Y = h[1], ee = I(O), J = l.useRef(ft), ae = l.useRef(typeof ue == "string" ? ue : null), se = l.useRef(-1), he = l.useRef(-1), ne = l.useRef(Me), Se = Sn({ getCurrentPage: function() {
        return J.current.pageIndex;
      }, getCurrentScrollMode: function() {
        return J.current.scrollMode;
      }, jumpToPage: function(Ke) {
        return On(Ke);
      }, targetRef: bn }), Fe = l.useState(-1), ze = Fe[0], Ue = Fe[1], ot = l.useState(0), Ze = ot[0], gt = ot[1], et = y({ doc: ve });
      l.useEffect(function() {
        return function() {
          Ge.clear(), st.clear();
        };
      }, [Wt]);
      var It = l.useMemo(function() {
        return Object.assign({}, Ga, Ee);
      }, []), Rt = l.useMemo(function() {
        return Array(Gt).fill(0).map(function(Ke, Ot) {
          var on = [Ie[Ot].pageHeight, Ie[Ot].pageWidth], pn = Math.abs(Fn) % 180 == 0 ? { height: on[0], width: on[1] } : { height: on[1], width: on[0] }, hn = { height: pn.height * O, width: pn.width * O };
          return It.transformSize({ numPages: Gt, pageIndex: Ot, size: hn });
        });
      }, [Fn, O]), wt = Wa({ enableSmoothScroll: Pe, isRtl: mn, numberOfItems: Gt, parentRef: bn, scrollMode: Dt, setRenderRange: Qe, sizes: Rt, viewMode: Ft }), En = R(function() {
        !ae.current || J.current.fullScreenMode !== e.FullScreenMode.Normal || Me > 0 && ne.current === Me || rr(ae.current);
      }, 200);
      (function(Ke) {
        var Ot = Ke.targetRef, on = Ke.onResize;
        S(function() {
          var pn = new ResizeObserver(function(Jt) {
            Jt.forEach(function(zn) {
              on(zn.target);
            });
          }), hn = Ot.current;
          if (hn) return pn.observe(hn), function() {
            pn.unobserve(hn);
          };
        }, []);
      })({ targetRef: bn, onResize: En });
      var Zt = function(Ke) {
        var Ot = Ke;
        Le.forEach(function(on) {
          on.onViewerStateChange && (Ot = on.onViewerStateChange(Ot));
        }), J.current = Ot;
      }, Bt = function() {
        return bn.current;
      }, Ht = function() {
        return J.current;
      }, An = l.useCallback(function(Ke) {
        Bn.markVisitedDestination(Ke);
      }, []), $n = l.useCallback(function(Ke) {
        var Ot = Ke.pageIndex, on = Ke.bottomOffset, pn = Ke.leftOffset, hn = Ke.scaleTo, Jt = bn.current, zn = J.current;
        return Jt && zn ? new Promise(function(or, ln) {
          tt(ve, Ot).then(function(sr) {
            var Qn = sr.getViewport({ scale: 1 }), er = 0, cr = (typeof on == "function" ? on(Qn.width, Qn.height) : on) || 0, qn = (typeof pn == "function" ? pn(Qn.width, Qn.height) : pn) || 0, Pr = zn.scale;
            switch (hn) {
              case e.SpecialZoomLevel.PageFit:
                er = 0, qn = 0, rr(e.SpecialZoomLevel.PageFit);
                break;
              case e.SpecialZoomLevel.PageWidth:
                Pr = $r(Jt, Ie[Ot].pageHeight, Ie[Ot].pageWidth, e.SpecialZoomLevel.PageWidth, vt, Gt), er = (Qn.height - cr) * Pr, qn *= Pr, rr(Pr);
                break;
              default:
                er = (Qn.height - cr) * Pr, qn *= Pr;
            }
            switch (zn.scrollMode) {
              case e.ScrollMode.Horizontal:
                wt.scrollToItem(Ot, { left: qn, top: 0 }).then(function() {
                  or();
                });
                break;
              case e.ScrollMode.Vertical:
              default:
                wt.scrollToItem(Ot, { left: 0, top: er }).then(function() {
                  or();
                });
            }
          });
        }) : Promise.resolve();
      }, []), Dn = l.useCallback(function(Ke) {
        return Bn.markVisitedDestination(Ke), $n(Ke);
      }, []), Jn = l.useCallback(function() {
        var Ke = Bn.getNextDestination();
        return Ke ? $n(Ke) : Promise.resolve();
      }, []), Vn = l.useCallback(function() {
        var Ke = Bn.getPreviousDestination();
        return Ke ? $n(Ke) : Promise.resolve();
      }, []), ar = l.useCallback(function() {
        return wt.scrollToNextItem(J.current.pageIndex, br);
      }, []), On = l.useCallback(function(Ke) {
        return 0 <= Ke && Ke < Gt ? wt.scrollToItem(Ke, br) : Promise.resolve();
      }, []), Sr = l.useCallback(function() {
        return wt.scrollToPreviousItem(J.current.pageIndex, br);
      }, []), ir = l.useCallback(function(Ke) {
        var Ot, on;
        (Ot = Ke.name, on = Ot.split(/\./).pop(), on ? on.toLowerCase() : "").toLowerCase() === "pdf" && new Promise(function(pn) {
          var hn = new FileReader();
          hn.readAsArrayBuffer(Ke), hn.onload = function() {
            var Jt = new Uint8Array(hn.result);
            pn(Jt);
          };
        }).then(function(pn) {
          en(Ke.name, pn);
        });
      }, [en]), Yn = l.useCallback(function(Ke) {
        var Ot = Ke === e.RotateDirection.Backward ? -90 : 90, on = J.current.rotation, pn = on === 360 || on === -360 ? Ot : on + Ot;
        et.markNotRendered(), Kn(pn), Zt(N(N({}, J.current), { rotation: pn })), jt({ direction: Ke, doc: ve, rotation: pn });
      }, []), Zn = l.useCallback(function(Ke, Ot) {
        var on = Ot === e.RotateDirection.Backward ? -90 : 90, pn = J.current.pagesRotation, hn = (pn.has(Ke) ? pn.get(Ke) : Oe) + on, Jt = pn.set(Ke, hn);
        Vt(Jt), Xn(function(zn) {
          return !zn;
        }), Zt(N(N({}, J.current), { pagesRotation: Jt, rotatedPage: Ke })), $t({ direction: Ot, doc: ve, pageIndex: Ke, rotation: hn }), et.markRendering(Ke), Ue(Ke);
      }, []), Gn = l.useCallback(function(Ke) {
        Zt(N(N({}, J.current), { scrollMode: Ke })), Lt(Ke);
      }, []), nr = l.useCallback(function(Ke) {
        Zt(N(N({}, J.current), { viewMode: Ke })), kt(Ke);
      }, []), rr = l.useCallback(function(Ke) {
        var Ot = bn.current, on = J.current.pageIndex;
        if (!(on < 0 || on >= Gt)) {
          var pn = Ie[on].pageHeight, hn = Ie[on].pageWidth, Jt = Ot ? typeof Ke == "string" ? $r(Ot, pn, hn, Ke, J.current.viewMode, Gt) : Ke : 1;
          ae.current = typeof Ke == "string" ? Ke : null, Jt !== J.current.scale && (gt(function(zn) {
            return zn + 1;
          }), et.markNotRendered(), Y(Jt), Tt({ doc: ve, scale: Jt }), Zt(N(N({}, J.current), { scale: Jt })));
        }
      }, []), _r = l.useCallback(function(Ke) {
        Se.enterFullScreenMode(Ke);
      }, []), wr = l.useCallback(function() {
        Se.exitFullScreenMode();
      }, []);
      l.useEffect(function() {
        Zt(N(N({}, J.current), { fullScreenMode: Se.fullScreenMode }));
      }, [Se.fullScreenMode]), l.useEffect(function() {
        var Ke = { enterFullScreenMode: _r, exitFullScreenMode: wr, getPagesContainer: Bt, getViewerState: Ht, jumpToDestination: Dn, jumpToNextDestination: Jn, jumpToPreviousDestination: Vn, jumpToNextPage: ar, jumpToPreviousPage: Sr, jumpToPage: On, openFile: ir, rotate: Yn, rotatePage: Zn, setViewerState: Zt, switchScrollMode: Gn, switchViewMode: nr, zoom: rr };
        return Le.forEach(function(Ot) {
          Ot.install && Ot.install(Ke);
        }), function() {
          Le.forEach(function(Ot) {
            Ot.uninstall && Ot.uninstall(Ke);
          });
        };
      }, [Wt]), l.useEffect(function() {
        ut({ doc: ve, file: K }), Le.forEach(function(Ke) {
          Ke.onDocumentLoad && Ke.onDocumentLoad({ doc: ve, file: K });
        });
      }, [Wt]);
      var pr, gr, tn, cn = wt.boundingClientRect;
      pr = function() {
        Me && On(Me);
      }, gr = cn.height > 0 && cn.width > 0, tn = l.useRef(!1), S(function() {
        gr && !tn.current && (tn.current = !0, pr());
      }, [pr, gr]), S(function() {
        var Ke = J.current.pageIndex;
        Ke > -1 && Kt !== Dt && wt.scrollToItem(Ke, br).then(function() {
          Se.fullScreenMode === e.FullScreenMode.EnteredCompletely && (Pe || et.markNotRendered(), se.current = -1);
        });
      }, [Dt]), S(function() {
        var Ke = J.current.pageIndex;
        Ke > -1 && mr !== Fn && wt.scrollToItem(Ke, br);
      }, [Fn]), S(function() {
        ee != 0 && ee != J.current.scale && wt.zoom(J.current.scale / ee, J.current.pageIndex).then(function() {
          Se.fullScreenMode === e.FullScreenMode.EnteredCompletely && (he.current = -1);
        });
      }, [O]), S(function() {
        if (Qt !== J.current.viewMode) {
          var Ke = wt.startPage, Ot = wt.endPage, on = wt.virtualItems;
          et.markNotRendered(), et.setRange(Ke, Ot);
          for (var pn = function(Jt) {
            var zn = on.find(function(or) {
              return or.index === Jt;
            });
            zn && et.setVisibility(Jt, zn.visibility);
          }, hn = Ke; hn <= Ot; hn++) pn(hn);
          dn();
        }
      }, [Ft]), S(function() {
        var Ke = J.current.pageIndex;
        Ke > -1 && Qt !== Ft && wt.scrollToItem(Ke, br);
      }, [Ft]), S(function() {
        var Ke = J.current.pageIndex;
        Ke > 0 && Ke === Me && ne.current === Me && ae.current && (ne.current = -1, rr(ae.current));
      }, [Mn]), l.useEffect(function() {
        wt.isSmoothScrolling || Cn.current !== null && Cn.current === Mn || (Cn.current = Mn, Nt({ currentPage: Mn, doc: ve }));
      }, [Mn, wt.isSmoothScrolling]), l.useEffect(function() {
        Se.fullScreenMode === e.FullScreenMode.Entering && J.current.scrollMode === e.ScrollMode.Page && (se.current = J.current.pageIndex), Se.fullScreenMode === e.FullScreenMode.EnteredCompletely && J.current.scrollMode === e.ScrollMode.Page && Pe && (se.current = -1), Se.fullScreenMode === e.FullScreenMode.EnteredCompletely && ae.current && (he.current = J.current.pageIndex, rr(ae.current));
      }, [Se.fullScreenMode]), l.useEffect(function() {
        if (Se.fullScreenMode !== e.FullScreenMode.Entering && Se.fullScreenMode !== e.FullScreenMode.Exitting && !wt.isSmoothScrolling) {
          var Ke = wt.startPage, Ot = wt.endPage, on = wt.maxVisbilityIndex, pn = wt.virtualItems, hn = on, Jt = Se.fullScreenMode === e.FullScreenMode.Entered || Se.fullScreenMode === e.FullScreenMode.EnteredCompletely;
          if (!(Jt && hn !== se.current && se.current > -1 || Jt && hn !== he.current && he.current > -1)) {
            Hn(hn), Zt(N(N({}, J.current), { pageIndex: hn })), et.setRange(Ke, Ot);
            for (var zn = function(ln) {
              var sr = pn.find(function(Qn) {
                return Qn.index === ln;
              });
              sr && et.setVisibility(ln, sr.visibility);
            }, or = Ke; or <= Ot; or++) zn(or);
            dn();
          }
        }
      }, [wt.startPage, wt.endPage, wt.isSmoothScrolling, wt.maxVisbilityIndex, Se.fullScreenMode, jn, Fn, O]);
      var yn = l.useCallback(function(Ke) {
        et.markRendered(Ke), dn();
      }, [Ze]), dn = function() {
        var Ke = et.getHighestPriorityPage();
        Ke > -1 && et.isInRange(Ke) && (et.markRendering(Ke), Ue(Ke));
      }, nn = function(Ke) {
        var Ot = Mn - 1, on = Mn + 1;
        switch (Ke) {
          case "FirstPage":
            On(0);
            break;
          case "LastPage":
            On(Gt - 1);
            break;
          case "NextPage":
            on < Gt && On(on);
            break;
          case "PrevPage":
            Ot >= 0 && On(Ot);
        }
      }, wn = l.useCallback(function() {
        var Ke = wt.virtualItems, Ot = [];
        switch (Ft) {
          case e.ViewMode.DualPage:
            Ot = de(Ke, 2);
            break;
          case e.ViewMode.DualPageWithCover:
            Ke.length && (Ot = Ke[0].index === 0 ? [[Ke[0]]].concat(de(Ke.slice(1), 2)) : de(Ke, 2));
            break;
          case e.ViewMode.SinglePage:
          default:
            Ot = de(Ke, 1);
        }
        var on = fn && fn.core ? fn.core.pageLabel : "Page {{pageIndex}}", pn = { attrs: { className: "rpv-core__inner-container", "data-testid": "core__inner-container", ref: vn, style: { height: "100%" } }, children: l.createElement(l.Fragment, null), subSlot: { attrs: { "data-testid": "core__inner-pages", className: P({ "rpv-core__inner-pages": !0, "rpv-core__inner-pages--horizontal": Dt === e.ScrollMode.Horizontal, "rpv-core__inner-pages--rtl": mn, "rpv-core__inner-pages--single": Dt === e.ScrollMode.Page, "rpv-core__inner-pages--vertical": Dt === e.ScrollMode.Vertical, "rpv-core__inner-pages--wrapped": Dt === e.ScrollMode.Wrapped }), ref: bn, style: { height: "100%", position: "relative" } }, children: l.createElement("div", { "data-testid": "core__inner-current-page-".concat(Mn), style: Object.assign({ "--scale-factor": O }, wt.getContainerStyles()) }, Ot.map(function(hn) {
          return l.createElement("div", { className: P({ "rpv-core__inner-page-container": !0, "rpv-core__inner-page-container--single": Dt === e.ScrollMode.Page }), style: wt.getItemContainerStyles(hn[0]), key: "".concat(hn[0].index, "-").concat(Ft) }, hn.map(function(Jt) {
            var zn = Ft === e.ViewMode.DualPageWithCover && (Jt.index === 0 || Gt % 2 == 0 && Jt.index === Gt - 1);
            return l.createElement("div", { "aria-label": on.replace("{{pageIndex}}", "".concat(Jt.index + 1)), className: P({ "rpv-core__inner-page": !0, "rpv-core__inner-page--dual-even": Ft === e.ViewMode.DualPage && Jt.index % 2 == 0, "rpv-core__inner-page--dual-odd": Ft === e.ViewMode.DualPage && Jt.index % 2 == 1, "rpv-core__inner-page--dual-cover": zn, "rpv-core__inner-page--dual-cover-even": Ft === e.ViewMode.DualPageWithCover && !zn && Jt.index % 2 == 0, "rpv-core__inner-page--dual-cover-odd": Ft === e.ViewMode.DualPageWithCover && !zn && Jt.index % 2 == 1, "rpv-core__inner-page--single": Ft === e.ViewMode.SinglePage && Dt === e.ScrollMode.Page }), role: "region", key: "".concat(Jt.index, "-").concat(Ft), style: Object.assign({}, wt.getItemStyles(Jt), It.buildPageStyles({ numPages: Gt, pageIndex: Jt.index, scrollMode: Dt, viewMode: Ft })) }, l.createElement(Fa, { doc: ve, measureRef: Jt.measureRef, outlines: an, pageIndex: Jt.index, pageRotation: qt.has(Jt.index) ? qt.get(Jt.index) : 0, pageSize: Ie[Jt.index], plugins: Le, renderPage: rt, renderQueueKey: Ze, rotation: Fn, scale: O, shouldRender: ze === Jt.index, viewMode: Ft, onExecuteNamedAction: nn, onJumpFromLinkAnnotation: An, onJumpToDest: Dn, onRenderCompleted: yn, onRotatePage: Zn }));
          }));
        })) } };
        return Le.forEach(function(hn) {
          hn.renderViewer && (pn = hn.renderViewer({ containerRef: vn, doc: ve, pagesContainerRef: bn, pagesRotation: qt, pageSizes: Ie, rotation: Fn, slot: pn, themeContext: un, jumpToPage: On, openFile: ir, rotate: Yn, rotatePage: Zn, switchScrollMode: Gn, switchViewMode: nr, zoom: rr }));
        }), pn;
      }, [Le, wt]), kn = l.useCallback(function(Ke) {
        return l.createElement("div", N({}, Ke.attrs, { style: Ke.attrs && Ke.attrs.style ? Ke.attrs.style : {} }), Ke.children, Ke.subSlot && kn(Ke.subSlot));
      }, []);
      return kn(wn());
    }, Kr = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.3, 1.5, 1.7, 1.9, 2.1, 2.4, 2.7, 3, 3.3, 3.7, 4.1, 4.6, 5.1, 5.7, 6.3, 7, 7.7, 8.5, 9.4, 10], ua = function(z) {
      var K = z.defaultScale, ue = z.doc, ve = z.render, Pe = z.scrollMode, Me = z.viewMode, Oe = l.useRef(), xe = l.useState({ pageSizes: [], scale: 0 }), Ee = xe[0], Ie = xe[1];
      return l.useLayoutEffect(function() {
        var Le = Array(ue.numPages).fill(0).map(function(rt, nt) {
          return new Promise(function(Qe, vt) {
            tt(ue, nt).then(function(ft) {
              var ut = ft.getViewport({ scale: 1 });
              Qe({ pageHeight: ut.height, pageWidth: ut.width, rotation: ut.rotation });
            });
          });
        });
        Promise.all(Le).then(function(rt) {
          var nt = Oe.current;
          if (nt && rt.length !== 0) {
            var Qe = rt[0].pageWidth, vt = rt[0].pageHeight, ft = nt.parentElement, ut = (ft.clientWidth - 45) / Qe, en = (ft.clientHeight - 45) / vt, Nt = ut;
            switch (Pe) {
              case e.ScrollMode.Horizontal:
                Nt = Math.min(ut, en);
                break;
              case e.ScrollMode.Vertical:
              default:
                Nt = ut;
            }
            var jt, $t, Tt = K ? typeof K == "string" ? $r(ft, vt, Qe, K, Me, ue.numPages) : K : (jt = Nt, ($t = Kr.findIndex(function(Gt) {
              return Gt >= jt;
            })) === -1 || $t === 0 ? jt : Kr[$t - 1]);
            Ie({ pageSizes: rt, scale: Tt });
          }
        });
      }, [ue.loadingTask.docId]), Ee.pageSizes.length === 0 || Ee.scale === 0 ? l.createElement("div", { className: "rpv-core__page-size-calculator", "data-testid": "core__page-size-calculating", ref: Oe }, l.createElement(w, null)) : ve(Ee.pageSizes, Ee.scale);
    }, Nr = function() {
    }, Xr = function(z) {
      function K(ue, ve) {
        var Pe = z.call(this) || this;
        return Pe.verifyPassword = ue, Pe.passwordStatus = ve, Pe;
      }
      return G(K, z), K;
    }(Nr), xr = function(z) {
      var K = z.passwordStatus, ue = z.renderProtectedView, ve = z.verifyPassword, Pe = z.onDocumentAskPassword, Me = l.useContext(j).l10n, Oe = l.useState(""), xe = Oe[0], Ee = Oe[1], Ie = l.useContext(B).direction === e.TextDirection.RightToLeft, Le = function() {
        return ve(xe);
      };
      return l.useEffect(function() {
        Pe && Pe({ verifyPassword: ve });
      }, []), ue ? ue({ passwordStatus: K, verifyPassword: ve }) : l.createElement("div", { className: "rpv-core__asking-password-wrapper" }, l.createElement("div", { className: P({ "rpv-core__asking-password": !0, "rpv-core__asking-password--rtl": Ie }) }, l.createElement("div", { className: "rpv-core__asking-password-message" }, K === e.PasswordStatus.RequiredPassword && Me.core.askingPassword.requirePasswordToOpen, K === e.PasswordStatus.WrongPassword && Me.core.wrongPassword.tryAgain), l.createElement("div", { className: "rpv-core__asking-password-body" }, l.createElement("div", { className: P({ "rpv-core__asking-password-input": !0, "rpv-core__asking-password-input--ltr": !Ie, "rpv-core__asking-password-input--rtl": Ie }) }, l.createElement(i, { testId: "core__asking-password-input", type: "password", value: xe, onChange: Ee, onKeyDown: function(rt) {
        rt.key === "Enter" && Le();
      } })), l.createElement(s, { onClick: Le }, Me.core.askingPassword.submit))));
    }, da = function(z) {
      function K(ue) {
        var ve = z.call(this) || this;
        return ve.doc = ue, ve;
      }
      return G(K, z), K;
    }(Nr), ha = function(z) {
      function K(ue) {
        var ve = z.call(this) || this;
        return ve.error = ue, ve;
      }
      return G(K, z), K;
    }(Nr), Yr = function(z) {
      function K(ue) {
        var ve = z.call(this) || this;
        return ve.percentages = ue, ve;
      }
      return G(K, z), K;
    }(Nr), Xa = function(z) {
      var K = z.characterMap, ue = z.file, ve = z.httpHeaders, Pe = z.render, Me = z.renderError, Oe = z.renderLoader, xe = z.renderProtectedView, Ee = z.transformGetDocumentParams, Ie = z.withCredentials, Le = z.onDocumentAskPassword, rt = l.useContext(B).direction === e.TextDirection.RightToLeft, nt = l.useState(new Yr(0)), Qe = nt[0], vt = nt[1], ft = l.useRef(""), ut = M();
      return l.useEffect(function() {
        ft.current = "", vt(new Yr(0));
        var en = new W.PDFWorker({ name: "PDFWorker_".concat(Date.now()) }), Nt = Object.assign({ httpHeaders: ve, withCredentials: Ie, worker: en }, typeof ue == "string" ? { url: ue } : { data: ue }, K ? { cMapUrl: K.url, cMapPacked: K.isCompressed } : {}), jt = Ee ? Ee(Nt) : Nt, $t = W.getDocument(jt);
        return $t.onPassword = function(Tt, Gt) {
          switch (Gt) {
            case W.PasswordResponses.NEED_PASSWORD:
              ut.current && vt(new Xr(Tt, e.PasswordStatus.RequiredPassword));
              break;
            case W.PasswordResponses.INCORRECT_PASSWORD:
              ut.current && vt(new Xr(Tt, e.PasswordStatus.WrongPassword));
          }
        }, $t.onProgress = function(Tt) {
          var Gt = Tt.total > 0 ? Math.min(100, 100 * Tt.loaded / Tt.total) : 100;
          ut.current && ft.current === "" && vt(new Yr(Gt));
        }, $t.promise.then(function(Tt) {
          ft.current = Tt.loadingTask.docId, ut.current && vt(new da(Tt));
        }, function(Tt) {
          return ut.current && !en.destroyed && vt(new ha({ message: Tt.message || "Cannot load document", name: Tt.name }));
        }), function() {
          $t.destroy(), en.destroy();
        };
      }, [ue]), Qe instanceof Xr ? l.createElement(xr, { passwordStatus: Qe.passwordStatus, renderProtectedView: xe, verifyPassword: Qe.verifyPassword, onDocumentAskPassword: Le }) : Qe instanceof da ? Pe(Qe.doc) : Qe instanceof ha ? Me ? Me(Qe.error) : l.createElement("div", { className: P({ "rpv-core__doc-error": !0, "rpv-core__doc-error--rtl": rt }) }, l.createElement("div", { className: "rpv-core__doc-error-text" }, Qe.error.message)) : l.createElement("div", { "data-testid": "core__doc-loading", className: P({ "rpv-core__doc-loading": !0, "rpv-core__doc-loading--rtl": rt }) }, Oe ? Oe(Qe.percentages) : l.createElement(w, null));
    }, Ya = function(z, K) {
      var ue = l.useMemo(function() {
        return z === "auto" ? typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" : z;
      }, []), ve = l.useState(ue), Pe = ve[0], Me = ve[1], Oe = I(Pe);
      return l.useEffect(function() {
        if (z === "auto") {
          var xe = window.matchMedia("(prefers-color-scheme: dark)"), Ee = function(Ie) {
            Me(Ie.matches ? "dark" : "light");
          };
          return xe.addEventListener("change", Ee), function() {
            return xe.removeEventListener("change", Ee);
          };
        }
      }, []), l.useEffect(function() {
        Pe !== Oe && K && K(Pe);
      }, [Pe]), l.useEffect(function() {
        z !== Pe && Me(z);
      }, [z]), { currentTheme: Pe, setCurrentTheme: Me };
    }, Za = function(z) {
      return { startPage: z.startPage - 3, endPage: z.endPage + 3 };
    };
    e.Button = function(z) {
      var K = z.children, ue = z.testId, ve = z.onClick, Pe = l.useContext(B).direction === e.TextDirection.RightToLeft, Me = ue ? { "data-testid": ue } : {};
      return l.createElement("button", N({ className: P({ "rpv-core__button": !0, "rpv-core__button--rtl": Pe }), type: "button", onClick: ve }, Me), K);
    }, e.Icon = u, e.LazyRender = function(z) {
      var K = z.attrs, ue = z.children, ve = z.testId, Pe = l.useState(!1), Me = Pe[0], Oe = Pe[1], xe = ve ? N(N({}, K), { "data-testid": ve }) : K, Ee = r({ once: !0, onVisibilityChanged: function(Ie) {
        Ie.isVisible && Oe(!0);
      } });
      return l.createElement("div", N({ ref: Ee }, xe), Me && ue);
    }, e.LocalizationContext = j, e.Menu = function(z) {
      var K = z.children, ue = l.useRef(), ve = l.useRef([]), Pe = l.useContext(B).direction === e.TextDirection.RightToLeft, Me = function(xe) {
        if (ue.current) switch (xe.key) {
          case "Tab":
            xe.preventDefault();
            break;
          case "ArrowDown":
            xe.preventDefault(), Oe(function(Ee, Ie) {
              return Ie + 1;
            });
            break;
          case "ArrowUp":
            xe.preventDefault(), Oe(function(Ee, Ie) {
              return Ie - 1;
            });
            break;
          case "End":
            xe.preventDefault(), Oe(function(Ee, Ie) {
              return Ee.length - 1;
            });
            break;
          case "Home":
            xe.preventDefault(), Oe(function(Ee, Ie) {
              return 0;
            });
        }
      }, Oe = function(xe) {
        if (ue.current) {
          var Ee = ve.current, Ie = Ee.findIndex(function(rt) {
            return rt.getAttribute("tabindex") === "0";
          }), Le = Math.min(Ee.length - 1, Math.max(0, xe(Ee, Ie)));
          Ie >= 0 && Ie <= Ee.length - 1 && Ee[Ie].setAttribute("tabindex", "-1"), Ee[Le].setAttribute("tabindex", "0"), Ee[Le].focus();
        }
      };
      return S(function() {
        var xe = ue.current;
        if (xe) {
          var Ee = function(Ie) {
            var Le = [];
            return Ie.querySelectorAll('.rpv-core__menu-item[role="menuitem"]').forEach(function(rt) {
              if (rt instanceof HTMLElement) {
                var nt = rt.parentElement;
                (nt === Ie || window.getComputedStyle(nt).display !== "none") && Le.push(rt);
              }
            }), Le;
          }(xe);
          ve.current = Ee;
        }
      }, []), S(function() {
        return document.addEventListener("keydown", Me), function() {
          document.removeEventListener("keydown", Me);
        };
      }, []), l.createElement("div", { ref: ue, "aria-orientation": "vertical", className: P({ "rpv-core__menu": !0, "rpv-core__menu--rtl": Pe }), role: "menu", tabIndex: 0 }, K);
    }, e.MenuDivider = function() {
      return l.createElement("div", { "aria-orientation": "horizontal", className: "rpv-core__menu-divider", role: "separator" });
    }, e.MenuItem = function(z) {
      var K = z.checked, ue = K !== void 0 && K, ve = z.children, Pe = z.icon, Me = Pe === void 0 ? null : Pe, Oe = z.isDisabled, xe = Oe !== void 0 && Oe, Ee = z.testId, Ie = z.onClick, Le = l.useContext(B).direction === e.TextDirection.RightToLeft, rt = Ee ? { "data-testid": Ee } : {};
      return l.createElement("button", N({ className: P({ "rpv-core__menu-item": !0, "rpv-core__menu-item--disabled": xe, "rpv-core__menu-item--ltr": !Le, "rpv-core__menu-item--rtl": Le }), role: "menuitem", tabIndex: -1, type: "button", onClick: Ie }, rt), l.createElement("div", { className: P({ "rpv-core__menu-item-icon": !0, "rpv-core__menu-item-icon--ltr": !Le, "rpv-core__menu-item-icon--rtl": Le }) }, Me), l.createElement("div", { className: P({ "rpv-core__menu-item-label": !0, "rpv-core__menu-item-label--ltr": !Le, "rpv-core__menu-item-label--rtl": Le }) }, ve), l.createElement("div", { className: P({ "rpv-core__menu-item-check": !0, "rpv-core__menu-item-check--ltr": !Le, "rpv-core__menu-item-check--rtl": Le }) }, ue && l.createElement(m, null)));
    }, e.MinimalButton = function(z) {
      var K = z.ariaLabel, ue = K === void 0 ? "" : K, ve = z.ariaKeyShortcuts, Pe = ve === void 0 ? "" : ve, Me = z.children, Oe = z.isDisabled, xe = Oe !== void 0 && Oe, Ee = z.isSelected, Ie = Ee !== void 0 && Ee, Le = z.testId, rt = z.onClick, nt = l.useContext(B).direction === e.TextDirection.RightToLeft, Qe = Le ? { "data-testid": Le } : {};
      return l.createElement("button", N({ "aria-label": ue }, Pe && { "aria-keyshortcuts": Pe }, xe && { "aria-disabled": !0 }, { className: P({ "rpv-core__minimal-button": !0, "rpv-core__minimal-button--disabled": xe, "rpv-core__minimal-button--rtl": nt, "rpv-core__minimal-button--selected": Ie }), type: "button", onClick: rt }, Qe), Me);
    }, e.Modal = function(z) {
      var K = z.ariaControlsSuffix, ue = z.closeOnClickOutside, ve = z.closeOnEscape, Pe = z.content, Me = z.isOpened, Oe = Me !== void 0 && Me, xe = z.target, Ee = K || "".concat(d());
      return l.createElement(ge, { target: xe ? function(Ie, Le) {
        return l.createElement("div", { "aria-expanded": Le ? "true" : "false", "aria-haspopup": "dialog", "aria-controls": "rpv-core__modal-body-".concat(Ee) }, xe(Ie, Le));
      } : null, content: function(Ie) {
        return l.createElement(V, null, l.createElement(U, { ariaControlsSuffix: Ee, closeOnClickOutside: ue, closeOnEscape: ve, onToggle: Ie }, Pe(Ie)));
      }, isOpened: Oe });
    }, e.Popover = function(z) {
      var K = z.ariaHasPopup, ue = K === void 0 ? "dialog" : K, ve = z.ariaControlsSuffix, Pe = z.closeOnClickOutside, Me = z.closeOnEscape, Oe = z.content, xe = z.lockScroll, Ee = xe === void 0 || xe, Ie = z.offset, Le = z.position, rt = z.target, nt = re(!1), Qe = nt.opened, vt = nt.toggle, ft = l.useRef(), ut = l.useMemo(function() {
        return ve || "".concat(d());
      }, []);
      return l.createElement("div", { ref: ft, "aria-expanded": Qe ? "true" : "false", "aria-haspopup": ue, "aria-controls": "rpv-core__popver-body-".concat(ut) }, rt(vt, Qe), Qe && l.createElement(l.Fragment, null, Ee && l.createElement(_e, { closeOnEscape: Me, onClose: vt }), l.createElement(me, { ariaControlsSuffix: ut, closeOnClickOutside: Pe, offset: Ie, position: Le, targetRef: ft, onClose: vt }, Oe(vt))));
    }, e.PrimaryButton = s, e.ProgressBar = function(z) {
      var K = z.progress, ue = l.useContext(B).direction === e.TextDirection.RightToLeft;
      return l.createElement("div", { className: P({ "rpv-core__progress-bar": !0, "rpv-core__progress-bar--rtl": ue }) }, l.createElement("div", { className: "rpv-core__progress-bar-progress", style: { width: "".concat(K, "%") } }, K, "%"));
    }, e.Separator = function() {
      return l.createElement("div", { className: "rpv-core__separator" });
    }, e.Spinner = w, e.Splitter = function(z) {
      var K = z.constrain, ue = l.useContext(B).direction === e.TextDirection.RightToLeft, ve = l.useRef(), Pe = l.useRef(), Me = l.useRef(), Oe = l.useRef(0), xe = l.useRef(0), Ee = l.useRef(0), Ie = l.useRef(0), Le = { capture: !0 }, rt = function(Qe) {
        var vt = ve.current, ft = Pe.current, ut = Me.current;
        if (vt && ft && ut) {
          var en = Ie.current, Nt = Qe.clientX - Oe.current, jt = Ee.current + (ue ? -Nt : Nt), $t = vt.parentElement.getBoundingClientRect().width, Tt = 100 * jt / $t;
          if (vt.classList.add("rpv-core__splitter--resizing"), K) {
            var Gt = $t - jt - en;
            if (!K({ firstHalfPercentage: Tt, firstHalfSize: jt, secondHalfPercentage: 100 * Gt / $t, secondHalfSize: Gt })) return;
          }
          ft.style.width = "".concat(Tt, "%"), document.body.classList.add("rpv-core__splitter-body--resizing"), ft.classList.add("rpv-core__splitter-sibling--resizing"), ut.classList.add("rpv-core__splitter-sibling--resizing");
        }
      }, nt = function(Qe) {
        var vt = ve.current, ft = Pe.current, ut = Me.current;
        vt && ft && ut && (document.body.classList.remove("rpv-core__splitter-body--resizing"), vt.classList.remove("rpv-core__splitter--resizing"), ft.classList.remove("rpv-core__splitter-sibling--resizing"), ut.classList.remove("rpv-core__splitter-sibling--resizing"), document.removeEventListener("mousemove", rt, Le), document.removeEventListener("mouseup", nt, Le));
      };
      return l.useEffect(function() {
        var Qe = ve.current;
        Qe && (Ie.current = Qe.getBoundingClientRect().width, Pe.current = Qe.previousElementSibling, Me.current = Qe.nextElementSibling);
      }, []), l.createElement("div", { ref: ve, className: "rpv-core__splitter", onMouseDown: function(Qe) {
        var vt = Pe.current;
        vt && (Oe.current = Qe.clientX, xe.current = Qe.clientY, Ee.current = vt.getBoundingClientRect().width, document.addEventListener("mousemove", rt, Le), document.addEventListener("mouseup", nt, Le));
      } });
    }, e.TextBox = i, e.ThemeContext = B, e.Tooltip = function(z) {
      var K = z.ariaControlsSuffix, ue = z.content, ve = z.offset, Pe = z.position, Me = z.target, Oe = re(!1), xe = Oe.opened, Ee = Oe.toggle, Ie = l.useRef(), Le = l.useRef(), rt = l.useMemo(function() {
        return K || "".concat(d());
      }, []);
      F(function() {
        Ie.current && document.activeElement && Ie.current.contains(document.activeElement) && Qe();
      });
      var nt = function() {
        Ee(e.ToggleStatus.Open);
      }, Qe = function() {
        Ee(e.ToggleStatus.Close);
      };
      return l.createElement(l.Fragment, null, l.createElement("div", { ref: Ie, "aria-describedby": "rpv-core__tooltip-body-".concat(rt), onBlur: function(vt) {
        vt.relatedTarget instanceof HTMLElement && vt.currentTarget.parentElement && vt.currentTarget.parentElement.contains(vt.relatedTarget) ? Le.current && (Le.current.style.display = "none") : Qe();
      }, onFocus: nt, onMouseEnter: nt, onMouseLeave: Qe }, Me), xe && l.createElement(Be, { ariaControlsSuffix: rt, contentRef: Le, offset: ve, position: Pe, targetRef: Ie }, ue()));
    }, e.Viewer = function(z) {
      var K = z.characterMap, ue = z.defaultScale, ve = z.enableSmoothScroll, Pe = ve === void 0 || ve, Me = z.fileUrl, Oe = z.httpHeaders, xe = Oe === void 0 ? {} : Oe, Ee = z.initialPage, Ie = Ee === void 0 ? 0 : Ee, Le = z.pageLayout, rt = z.initialRotation, nt = rt === void 0 ? 0 : rt, Qe = z.localization, vt = z.plugins, ft = vt === void 0 ? [] : vt, ut = z.renderError, en = z.renderLoader, Nt = z.renderPage, jt = z.renderProtectedView, $t = z.scrollMode, Tt = $t === void 0 ? e.ScrollMode.Vertical : $t, Gt = z.setRenderRange, Wt = Gt === void 0 ? Za : Gt, fn = z.transformGetDocumentParams, un = z.theme, mn = un === void 0 ? { direction: e.TextDirection.LeftToRight, theme: "light" } : un, vn = z.viewMode, bn = vn === void 0 ? e.ViewMode.SinglePage : vn, Ln = z.withCredentials, Mn = Ln !== void 0 && Ln, Hn = z.onDocumentAskPassword, Cn = z.onDocumentLoad, Bn = Cn === void 0 ? function() {
      } : Cn, In = z.onPageChange, Fn = In === void 0 ? function() {
      } : In, Kn = z.onRotate, mr = Kn === void 0 ? function() {
      } : Kn, ur = z.onRotatePage, jn = ur === void 0 ? function() {
      } : ur, Xn = z.onSwitchTheme, Er = Xn === void 0 ? function() {
      } : Xn, qt = z.onZoom, Vt = qt === void 0 ? function() {
      } : qt, At = l.useState({ data: Me, name: typeof Me == "string" ? Me : "", shouldLoad: !1 }), Dt = At[0], Lt = At[1], Kt = function(se, he) {
        Lt({ data: he, name: se, shouldLoad: !0 });
      }, Yt = l.useState(!1), Ft = Yt[0], kt = Yt[1], Qt = I(Dt);
      l.useEffect(function() {
        var se, he, ne, Se;
        se = Qt.data, Se = typeof (he = Me), (ne = typeof se) == "string" && Se === "string" && se === he || ne === "object" && Se === "object" && se.length === he.length && se.every(function(Fe, ze) {
          return Fe === he[ze];
        }) || Lt({ data: Me, name: typeof Me == "string" ? Me : "", shouldLoad: Ft });
      }, [Me, Ft]);
      var an = r({ onVisibilityChanged: function(se) {
        kt(se.isVisible), se.isVisible && Lt(function(he) {
          return Object.assign({}, he, { shouldLoad: !0 });
        });
      } }), h = typeof mn == "string" ? { direction: e.TextDirection.LeftToRight, theme: mn } : mn, O = l.useState(Qe || D), Y = O[0], ee = O[1], J = { l10n: Y, setL10n: ee }, ae = Object.assign({}, { direction: h.direction }, Ya(h.theme || "light", Er));
      return l.useEffect(function() {
        Qe && ee(Qe);
      }, [Qe]), l.createElement(j.Provider, { value: J }, l.createElement(B.Provider, { value: ae }, l.createElement("div", { ref: an, className: "rpv-core__viewer rpv-core__viewer--".concat(ae.currentTheme), "data-testid": "core__viewer", style: { height: "100%", width: "100%" } }, Dt.shouldLoad && l.createElement(Xa, { characterMap: K, file: Dt.data, httpHeaders: xe, render: function(se) {
        return l.createElement(ua, { defaultScale: ue, doc: se, render: function(he, ne) {
          return l.createElement(Ka, { currentFile: { data: Dt.data, name: Dt.name }, defaultScale: ue, doc: se, enableSmoothScroll: Pe, initialPage: Ie, initialRotation: nt, initialScale: ne, pageLayout: Le, pageSizes: he, plugins: ft, renderPage: Nt, scrollMode: Tt, setRenderRange: Wt, viewMode: bn, viewerState: { file: Dt, fullScreenMode: e.FullScreenMode.Normal, pageIndex: -1, pageHeight: he[0].pageHeight, pageWidth: he[0].pageWidth, pagesRotation: /* @__PURE__ */ new Map(), rotation: nt, scale: ne, scrollMode: Tt, viewMode: bn }, onDocumentLoad: Bn, onOpenFile: Kt, onPageChange: Fn, onRotate: mr, onRotatePage: jn, onZoom: Vt });
        }, scrollMode: Tt, viewMode: bn });
      }, renderError: ut, renderLoader: en, renderProtectedView: jt, transformGetDocumentParams: fn, withCredentials: Mn, onDocumentAskPassword: Hn }))));
    }, e.Worker = function(z) {
      var K = z.children, ue = z.workerUrl;
      return W.GlobalWorkerOptions.workerSrc = ue, l.createElement(l.Fragment, null, K);
    }, e.chunk = de, e.classNames = P, e.createStore = function(z) {
      var K = z || {}, ue = {}, ve = function(Me, Oe) {
        var xe;
        K = N(N({}, K), ((xe = {})[Me] = Oe, xe)), (ue[Me] || []).forEach(function(Ee) {
          return Ee(K[Me]);
        });
      }, Pe = function(Me) {
        return K[Me];
      };
      return { subscribe: function(Me, Oe) {
        ue[Me] = (ue[Me] || []).concat(Oe);
      }, unsubscribe: function(Me, Oe) {
        ue[Me] = (ue[Me] || []).filter(function(xe) {
          return xe !== Oe;
        });
      }, update: function(Me, Oe) {
        ve(Me, Oe);
      }, updateCurrentValue: function(Me, Oe) {
        var xe = Pe(Me);
        xe !== void 0 && ve(Me, Oe(xe));
      }, get: function(Me) {
        return Pe(Me);
      } };
    }, e.getDestination = Xe, e.getPage = tt, e.isFullScreenEnabled = a, e.isMac = function() {
      return typeof window < "u" && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
    }, e.useDebounceCallback = R, e.useIntersectionObserver = r, e.useIsMounted = M, e.useIsomorphicLayoutEffect = S, e.usePrevious = I, e.useRenderQueue = y;
  }(core_min)), core_min;
}
var core = {}, hasRequiredCore;
function requireCore() {
  return hasRequiredCore || (hasRequiredCore = 1, function(e) {
    var L = requireReact(), p = requirePdf();
    function n(h) {
      var O = /* @__PURE__ */ Object.create(null);
      return h && Object.keys(h).forEach(function(Y) {
        if (Y !== "default") {
          var ee = Object.getOwnPropertyDescriptor(h, Y);
          Object.defineProperty(O, Y, ee.get ? ee : {
            enumerable: !0,
            get: function() {
              return h[Y];
            }
          });
        }
      }), O.default = h, Object.freeze(O);
    }
    var t = /* @__PURE__ */ n(L), l = /* @__PURE__ */ n(p);
    e.AnnotationType = void 0, function(h) {
      h[h.Text = 1] = "Text", h[h.Link = 2] = "Link", h[h.FreeText = 3] = "FreeText", h[h.Line = 4] = "Line", h[h.Square = 5] = "Square", h[h.Circle = 6] = "Circle", h[h.Polygon = 7] = "Polygon", h[h.Polyline = 8] = "Polyline", h[h.Highlight = 9] = "Highlight", h[h.Underline = 10] = "Underline", h[h.Squiggly = 11] = "Squiggly", h[h.StrikeOut = 12] = "StrikeOut", h[h.Stamp = 13] = "Stamp", h[h.Caret = 14] = "Caret", h[h.Ink = 15] = "Ink", h[h.Popup = 16] = "Popup", h[h.FileAttachment = 17] = "FileAttachment";
    }(e.AnnotationType || (e.AnnotationType = {}));
    var W = function(h, O) {
      return W = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Y, ee) {
        Y.__proto__ = ee;
      } || function(Y, ee) {
        for (var J in ee) Object.prototype.hasOwnProperty.call(ee, J) && (Y[J] = ee[J]);
      }, W(h, O);
    };
    function Q(h, O) {
      if (typeof O != "function" && O !== null)
        throw new TypeError("Class extends value " + String(O) + " is not a constructor or null");
      W(h, O);
      function Y() {
        this.constructor = h;
      }
      h.prototype = O === null ? Object.create(O) : (Y.prototype = O.prototype, new Y());
    }
    var G = function() {
      return G = Object.assign || function(O) {
        for (var Y, ee = 1, J = arguments.length; ee < J; ee++) {
          Y = arguments[ee];
          for (var ae in Y) Object.prototype.hasOwnProperty.call(Y, ae) && (O[ae] = Y[ae]);
        }
        return O;
      }, G.apply(this, arguments);
    };
    function X(h, O, Y) {
      for (var ee = 0, J = O.length, ae; ee < J; ee++)
        (ae || !(ee in O)) && (ae || (ae = Array.prototype.slice.call(O, 0, ee)), ae[ee] = O[ee]);
      return h.concat(ae || Array.prototype.slice.call(O));
    }
    e.TextDirection = void 0, function(h) {
      h.RightToLeft = "RTL", h.LeftToRight = "LTR";
    }(e.TextDirection || (e.TextDirection = {}));
    var N = t.createContext({
      currentTheme: "light",
      direction: e.TextDirection.LeftToRight,
      setCurrentTheme: function() {
      }
    }), H = function(h) {
      var O = [];
      return Object.keys(h).forEach(function(Y) {
        Y && h[Y] && O.push(Y);
      }), O.join(" ");
    }, B = function(h) {
      var O = h.children, Y = h.testId, ee = h.onClick, J = t.useContext(N).direction, ae = J === e.TextDirection.RightToLeft, se = Y ? { "data-testid": Y } : {};
      return t.createElement("button", G({ className: H({
        "rpv-core__button": !0,
        "rpv-core__button--rtl": ae
      }), type: "button", onClick: ee }, se), O);
    }, P = typeof window < "u" ? t.useLayoutEffect : t.useEffect, S = function(h) {
      var O = t.useRef(null), Y = h.once, ee = h.threshold, J = h.onVisibilityChanged;
      return P(function() {
        var ae = O.current;
        if (ae) {
          var se = new IntersectionObserver(function(he) {
            he.forEach(function(ne) {
              var Se = ne.isIntersecting, Fe = ne.intersectionRatio;
              J({ isVisible: Se, ratio: Fe }), Se && Y && (se.unobserve(ae), se.disconnect());
            });
          }, {
            threshold: ee || 0
          });
          return se.observe(ae), function() {
            se.unobserve(ae), se.disconnect();
          };
        }
      }, []), O;
    }, r = function(h) {
      var O = h.attrs, Y = h.children, ee = h.testId, J = t.useState(!1), ae = J[0], se = J[1], he = ee ? G(G({}, O), { "data-testid": ee }) : O, ne = function(Fe) {
        Fe.isVisible && se(!0);
      }, Se = S({
        once: !0,
        onVisibilityChanged: ne
      });
      return t.createElement("div", G({ ref: Se }, he), ae && Y);
    }, u = function(h) {
      var O = h.children, Y = t.useRef(), ee = t.useRef([]), J = t.useContext(N).direction, ae = J === e.TextDirection.RightToLeft, se = function(Se) {
        var Fe = Y.current;
        if (Fe)
          switch (Se.key) {
            case "Tab":
              Se.preventDefault();
              break;
            case "ArrowDown":
              Se.preventDefault(), he(function(ze, Ue) {
                return Ue + 1;
              });
              break;
            case "ArrowUp":
              Se.preventDefault(), he(function(ze, Ue) {
                return Ue - 1;
              });
              break;
            case "End":
              Se.preventDefault(), he(function(ze, Ue) {
                return ze.length - 1;
              });
              break;
            case "Home":
              Se.preventDefault(), he(function(ze, Ue) {
                return 0;
              });
              break;
          }
      }, he = function(Se) {
        var Fe = Y.current;
        if (Fe) {
          var ze = ee.current, Ue = ze.findIndex(function(Ze) {
            return Ze.getAttribute("tabindex") === "0";
          }), ot = Math.min(ze.length - 1, Math.max(0, Se(ze, Ue)));
          Ue >= 0 && Ue <= ze.length - 1 && ze[Ue].setAttribute("tabindex", "-1"), ze[ot].setAttribute("tabindex", "0"), ze[ot].focus();
        }
      }, ne = function(Se) {
        var Fe = [];
        return Se.querySelectorAll('.rpv-core__menu-item[role="menuitem"]').forEach(function(ze) {
          if (ze instanceof HTMLElement) {
            var Ue = ze.parentElement;
            (Ue === Se || window.getComputedStyle(Ue).display !== "none") && Fe.push(ze);
          }
        }), Fe;
      };
      return P(function() {
        var Se = Y.current;
        if (Se) {
          var Fe = ne(Se);
          ee.current = Fe;
        }
      }, []), P(function() {
        return document.addEventListener("keydown", se), function() {
          document.removeEventListener("keydown", se);
        };
      }, []), t.createElement("div", { ref: Y, "aria-orientation": "vertical", className: H({
        "rpv-core__menu": !0,
        "rpv-core__menu--rtl": ae
      }), role: "menu", tabIndex: 0 }, O);
    }, m = function() {
      return t.createElement("div", { "aria-orientation": "horizontal", className: "rpv-core__menu-divider", role: "separator" });
    }, s = function(h) {
      var O = h.children, Y = h.ignoreDirection, ee = Y === void 0 ? !1 : Y, J = h.size, ae = J === void 0 ? 24 : J, se = t.useContext(N).direction, he = !ee && se === e.TextDirection.RightToLeft, ne = "".concat(ae || 24, "px");
      return t.createElement("svg", { "aria-hidden": "true", className: H({
        "rpv-core__icon": !0,
        "rpv-core__icon--rtl": he
      }), focusable: "false", height: ne, viewBox: "0 0 24 24", width: ne }, O);
    }, w = function() {
      return t.createElement(
        s,
        { size: 16 },
        t.createElement("path", { d: "M23.5,0.499l-16.5,23l-6.5-6.5" })
      );
    }, i = function(h) {
      var O = h.checked, Y = O === void 0 ? !1 : O, ee = h.children, J = h.icon, ae = J === void 0 ? null : J, se = h.isDisabled, he = se === void 0 ? !1 : se, ne = h.testId, Se = h.onClick, Fe = t.useContext(N).direction, ze = Fe === e.TextDirection.RightToLeft, Ue = ne ? { "data-testid": ne } : {};
      return t.createElement(
        "button",
        G({ className: H({
          "rpv-core__menu-item": !0,
          "rpv-core__menu-item--disabled": he,
          "rpv-core__menu-item--ltr": !ze,
          "rpv-core__menu-item--rtl": ze
        }), role: "menuitem", tabIndex: -1, type: "button", onClick: Se }, Ue),
        t.createElement("div", { className: H({
          "rpv-core__menu-item-icon": !0,
          "rpv-core__menu-item-icon--ltr": !ze,
          "rpv-core__menu-item-icon--rtl": ze
        }) }, ae),
        t.createElement("div", { className: H({
          "rpv-core__menu-item-label": !0,
          "rpv-core__menu-item-label--ltr": !ze,
          "rpv-core__menu-item-label--rtl": ze
        }) }, ee),
        t.createElement("div", { className: H({
          "rpv-core__menu-item-check": !0,
          "rpv-core__menu-item-check--ltr": !ze,
          "rpv-core__menu-item-check--rtl": ze
        }) }, Y && t.createElement(w, null))
      );
    }, o = function(h) {
      var O = h.ariaLabel, Y = O === void 0 ? "" : O, ee = h.ariaKeyShortcuts, J = ee === void 0 ? "" : ee, ae = h.children, se = h.isDisabled, he = se === void 0 ? !1 : se, ne = h.isSelected, Se = ne === void 0 ? !1 : ne, Fe = h.testId, ze = h.onClick, Ue = t.useContext(N).direction, ot = Ue === e.TextDirection.RightToLeft, Ze = Fe ? { "data-testid": Fe } : {};
      return t.createElement("button", G({ "aria-label": Y }, J && { "aria-keyshortcuts": J }, he && { "aria-disabled": !0 }, { className: H({
        "rpv-core__minimal-button": !0,
        "rpv-core__minimal-button--disabled": he,
        "rpv-core__minimal-button--rtl": ot,
        "rpv-core__minimal-button--selected": Se
      }), type: "button", onClick: ze }, Ze), ae);
    }, b = function(h) {
      var O = h.children, Y = h.testId, ee = h.onClick, J = t.useContext(N).direction, ae = J === e.TextDirection.RightToLeft, se = Y ? { "data-testid": Y } : {};
      return t.createElement("button", G({ className: H({
        "rpv-core__primary-button": !0,
        "rpv-core__primary-button--rtl": ae
      }), type: "button", onClick: ee }, se), O);
    }, g = function(h) {
      var O = h.progress, Y = t.useContext(N).direction, ee = Y === e.TextDirection.RightToLeft;
      return t.createElement(
        "div",
        { className: H({
          "rpv-core__progress-bar": !0,
          "rpv-core__progress-bar--rtl": ee
        }) },
        t.createElement(
          "div",
          { className: "rpv-core__progress-bar-progress", style: { width: "".concat(O, "%") } },
          O,
          "%"
        )
      );
    }, c = function() {
      return t.createElement("div", { className: "rpv-core__separator" });
    }, v = function(h) {
      var O = h.size, Y = O === void 0 ? "4rem" : O, ee = h.testId, J = t.useState(!1), ae = J[0], se = J[1], he = ee ? { "data-testid": ee } : {}, ne = function(Fe) {
        se(Fe.isVisible);
      }, Se = S({
        onVisibilityChanged: ne
      });
      return t.createElement("div", G({}, he, { className: H({
        "rpv-core__spinner": !0,
        "rpv-core__spinner--animating": ae
      }), ref: Se, style: { height: Y, width: Y } }));
    }, k = function(h) {
      var O = h.constrain, Y = t.useContext(N).direction, ee = Y === e.TextDirection.RightToLeft, J = t.useRef(), ae = t.useRef(), se = t.useRef(), he = t.useRef(0), ne = t.useRef(0), Se = t.useRef(0), Fe = t.useRef(0), ze = {
        capture: !0
      }, Ue = function(gt) {
        var et = J.current, It = ae.current, Rt = se.current;
        if (!(!et || !It || !Rt)) {
          var wt = Fe.current, En = gt.clientX - he.current, Zt = Se.current + (ee ? -En : En), Bt = et.parentElement.getBoundingClientRect().width, Ht = Zt * 100 / Bt;
          if (et.classList.add("rpv-core__splitter--resizing"), O) {
            var An = Bt - Zt - wt, $n = An * 100 / Bt;
            if (!O({ firstHalfPercentage: Ht, firstHalfSize: Zt, secondHalfPercentage: $n, secondHalfSize: An }))
              return;
          }
          It.style.width = "".concat(Ht, "%"), document.body.classList.add("rpv-core__splitter-body--resizing"), It.classList.add("rpv-core__splitter-sibling--resizing"), Rt.classList.add("rpv-core__splitter-sibling--resizing");
        }
      }, ot = function(gt) {
        var et = J.current, It = ae.current, Rt = se.current;
        !et || !It || !Rt || (document.body.classList.remove("rpv-core__splitter-body--resizing"), et.classList.remove("rpv-core__splitter--resizing"), It.classList.remove("rpv-core__splitter-sibling--resizing"), Rt.classList.remove("rpv-core__splitter-sibling--resizing"), document.removeEventListener("mousemove", Ue, ze), document.removeEventListener("mouseup", ot, ze));
      }, Ze = function(gt) {
        var et = ae.current;
        et && (he.current = gt.clientX, ne.current = gt.clientY, Se.current = et.getBoundingClientRect().width, document.addEventListener("mousemove", Ue, ze), document.addEventListener("mouseup", ot, ze));
      };
      return t.useEffect(function() {
        var gt = J.current;
        gt && (Fe.current = gt.getBoundingClientRect().width, ae.current = gt.previousElementSibling, se.current = gt.nextElementSibling);
      }, []), t.createElement("div", { ref: J, className: "rpv-core__splitter", onMouseDown: Ze });
    }, a = function(h) {
      var O = h.ariaLabel, Y = O === void 0 ? "" : O, ee = h.autoFocus, J = ee === void 0 ? !1 : ee, ae = h.placeholder, se = ae === void 0 ? "" : ae, he = h.testId, ne = h.type, Se = ne === void 0 ? "text" : ne, Fe = h.value, ze = Fe === void 0 ? "" : Fe, Ue = h.onChange, ot = h.onKeyDown, Ze = ot === void 0 ? function() {
      } : ot, gt = t.useContext(N).direction, et = t.useRef(), It = gt === e.TextDirection.RightToLeft, Rt = {
        ref: et,
        "data-testid": "",
        "aria-label": Y,
        className: H({
          "rpv-core__textbox": !0,
          "rpv-core__textbox--rtl": It
        }),
        placeholder: se,
        value: ze,
        onChange: function(wt) {
          return Ue(wt.target.value);
        },
        onKeyDown: Ze
      };
      return he && (Rt["data-testid"] = he), P(function() {
        if (J) {
          var wt = et.current;
          if (wt) {
            var En = window.scrollX, Zt = window.scrollY;
            wt.focus(), window.scrollTo(En, Zt);
          }
        }
      }, []), Se === "text" ? t.createElement("input", G({ type: "text" }, Rt)) : t.createElement("input", G({ type: "password" }, Rt));
    }, f;
    (function(h) {
      h[h.ExitFullScreen = 0] = "ExitFullScreen", h[h.FullScreenChange = 1] = "FullScreenChange", h[h.FullScreenElement = 2] = "FullScreenElement", h[h.FullScreenEnabled = 3] = "FullScreenEnabled", h[h.RequestFullScreen = 4] = "RequestFullScreen";
    })(f || (f = {}));
    var C = {
      ExitFullScreen: "exitFullscreen",
      FullScreenChange: "fullscreenchange",
      FullScreenElement: "fullscreenElement",
      FullScreenEnabled: "fullscreenEnabled",
      RequestFullScreen: "requestFullscreen"
    }, R = {
      ExitFullScreen: "webkitExitFullscreen",
      FullScreenChange: "webkitfullscreenchange",
      FullScreenElement: "webkitFullscreenElement",
      FullScreenEnabled: "webkitFullscreenEnabled",
      RequestFullScreen: "webkitRequestFullscreen"
    }, M = {
      ExitFullScreen: "msExitFullscreen",
      FullScreenChange: "msFullscreenChange",
      FullScreenElement: "msFullscreenElement",
      FullScreenEnabled: "msFullscreenEnabled",
      RequestFullScreen: "msRequestFullscreen"
    }, I = typeof window < "u", E = I && (f.FullScreenEnabled in document && C || R.FullScreenEnabled in document && R || M.FullScreenEnabled in document && M) || C, T = function() {
      return I && E.FullScreenEnabled in document && document[E.FullScreenEnabled] === !0;
    }, y = function(h) {
      I && document.addEventListener(E.FullScreenChange, h);
    }, D = function(h) {
      I && document.removeEventListener(E.FullScreenChange, h);
    }, j = function(h) {
      return I ? h[E.ExitFullScreen]() : Promise.resolve({});
    }, A = function() {
      return I ? document[E.FullScreenElement] : null;
    }, d = function(h) {
      I && h[E.RequestFullScreen]();
    }, _ = function(h, O) {
      var Y = t.useRef(), ee = function() {
        Y.current && clearTimeout(Y.current);
      };
      return t.useEffect(function() {
        return function() {
          return ee();
        };
      }, []), t.useCallback(function() {
        for (var J = [], ae = 0; ae < arguments.length; ae++)
          J[ae] = arguments[ae];
        ee(), Y.current = setTimeout(function() {
          h.apply(void 0, J);
        }, O);
      }, [h, O]);
    }, F = function() {
      var h = t.useRef(!1);
      return t.useEffect(function() {
        return h.current = !0, function() {
          h.current = !1;
        };
      }, []), h;
    }, U = function(h) {
      var O = t.useRef(h);
      return t.useEffect(function() {
        O.current = h;
      }, [h]), O.current;
    }, V;
    (function(h) {
      h.NotRenderedYet = "NotRenderedYet", h.Rendering = "Rendering", h.Rendered = "Rendered";
    })(V || (V = {}));
    var $ = -9999, re = function(h) {
      var O = h.doc, Y = O.numPages, ee = O.loadingTask.docId, J = t.useMemo(function() {
        return Array(Y).fill(null).map(function(Ze, gt) {
          return {
            pageIndex: gt,
            renderStatus: V.NotRenderedYet,
            visibility: $
          };
        });
      }, [ee]), ae = t.useRef({
        currentRenderingPage: -1,
        startRange: 0,
        endRange: Y - 1,
        visibilities: J
      }), se = function() {
        for (var Ze = 0; Ze < Y; Ze++)
          ae.current.visibilities[Ze].renderStatus = V.NotRenderedYet;
      }, he = function(Ze) {
        ae.current.visibilities[Ze].renderStatus = V.Rendered;
      }, ne = function(Ze) {
        ae.current.currentRenderingPage !== -1 && ae.current.currentRenderingPage !== Ze && ae.current.visibilities[ae.current.currentRenderingPage].renderStatus === V.Rendering && (ae.current.visibilities[ae.current.currentRenderingPage].renderStatus = V.NotRenderedYet), ae.current.visibilities[Ze].renderStatus = V.Rendering, ae.current.currentRenderingPage = Ze;
      }, Se = function(Ze, gt) {
        ae.current.startRange = Ze, ae.current.endRange = gt;
        for (var et = 0; et < Y; et++)
          (et < Ze || et > gt) && (ae.current.visibilities[et].visibility = $, ae.current.visibilities[et].renderStatus = V.NotRenderedYet);
      }, Fe = function(Ze) {
        ze(Ze, $);
      }, ze = function(Ze, gt) {
        ae.current.visibilities[Ze].visibility = gt;
      }, Ue = function() {
        var Ze = ae.current.visibilities.slice(ae.current.startRange, ae.current.endRange + 1).filter(function(wt) {
          return wt.visibility > $;
        });
        if (!Ze.length)
          return -1;
        for (var gt = Ze[0].pageIndex, et = Ze[Ze.length - 1].pageIndex, It = Ze.length, Rt = 0; Rt < It; Rt++) {
          if (Ze[Rt].renderStatus === V.Rendering)
            return -1;
          if (Ze[Rt].renderStatus === V.NotRenderedYet)
            return Ze[Rt].pageIndex;
        }
        return et + 1 < Y && ae.current.visibilities[et + 1].renderStatus !== V.Rendered ? et + 1 : gt - 1 >= 0 && ae.current.visibilities[gt - 1].renderStatus !== V.Rendered ? gt - 1 : -1;
      }, ot = function(Ze) {
        return Ze >= ae.current.startRange && Ze <= ae.current.endRange;
      };
      return {
        getHighestPriorityPage: Ue,
        isInRange: ot,
        markNotRendered: se,
        markRendered: he,
        markRendering: ne,
        setOutOfRange: Fe,
        setRange: Se,
        setVisibility: ze
      };
    }, ge = {
      askingPassword: {
        requirePasswordToOpen: "This document requires a password to open",
        submit: "Submit"
      },
      wrongPassword: {
        tryAgain: "The password is wrong. Please try again"
      },
      pageLabel: "Page {{pageIndex}}"
    }, be = {
      core: ge
    }, le = be, fe = t.createContext({
      l10n: le,
      setL10n: function() {
      }
    }), Ae = 0, qe = function() {
      return Ae++;
    }, ye = function(h, O, Y) {
      var ee = function(J) {
        var ae = O.current;
        if (ae) {
          var se = J.target;
          if (se instanceof Element && se.shadowRoot) {
            var he = J.composedPath();
            he.length > 0 && !ae.contains(he[0]) && Y();
          } else ae.contains(se) || Y();
        }
      };
      t.useEffect(function() {
        if (h) {
          var J = {
            capture: !0
          };
          return document.addEventListener("click", ee, J), function() {
            document.removeEventListener("click", ee, J);
          };
        }
      }, []);
    }, ce = function(h) {
      var O = function(Y) {
        Y.key === "Escape" && h();
      };
      t.useEffect(function() {
        return document.addEventListener("keyup", O), function() {
          document.removeEventListener("keyup", O);
        };
      }, []);
    }, q = function() {
      t.useEffect(function() {
        var h = window.getComputedStyle(document.body).overflow;
        return document.body.style.overflow = "hidden", function() {
          document.body.style.overflow = h;
        };
      }, []);
    }, Z = function(h) {
      var O = h.ariaControlsSuffix, Y = h.children, ee = h.closeOnClickOutside, J = h.closeOnEscape, ae = h.onToggle, se = t.useRef(), he = t.useContext(N).direction, ne = he === e.TextDirection.RightToLeft;
      return q(), ce(function() {
        se.current && J && ae();
      }), ye(ee, se, ae), P(function() {
        var Se = se.current;
        if (Se) {
          var Fe = document.body.clientHeight * 0.75;
          Se.getBoundingClientRect().height >= Fe && (Se.style.overflow = "auto", Se.style.maxHeight = "".concat(Fe, "px"));
        }
      }, []), t.createElement("div", { "aria-modal": "true", className: H({
        "rpv-core__modal-body": !0,
        "rpv-core__modal-body--rtl": ne
      }), id: "rpv-core__modal-body-".concat(O), ref: se, role: "dialog", tabIndex: -1 }, Y);
    }, pe = function(h) {
      var O = h.children;
      return t.createElement("div", { className: "rpv-core__modal-overlay" }, O);
    };
    e.ToggleStatus = void 0, function(h) {
      h.Close = "Close", h.Open = "Open", h.Toggle = "Toggle";
    }(e.ToggleStatus || (e.ToggleStatus = {}));
    var me = function(h) {
      var O = t.useState(h), Y = O[0], ee = O[1], J = function(ae) {
        switch (ae) {
          case e.ToggleStatus.Close:
            ee(!1);
            break;
          case e.ToggleStatus.Open:
            ee(!0);
            break;
          case e.ToggleStatus.Toggle:
          default:
            ee(function(se) {
              return !se;
            });
            break;
        }
      };
      return { opened: Y, toggle: J };
    }, _e = function(h) {
      var O = h.content, Y = h.isOpened, ee = Y === void 0 ? !1 : Y, J = h.target, ae = me(ee), se = ae.opened, he = ae.toggle;
      return t.createElement(
        t.Fragment,
        null,
        J && J(he, se),
        se && O(he)
      );
    }, Be = function(h) {
      var O = h.ariaControlsSuffix, Y = h.closeOnClickOutside, ee = h.closeOnEscape, J = h.content, ae = h.isOpened, se = ae === void 0 ? !1 : ae, he = h.target, ne = O || "".concat(qe()), Se = function(ze, Ue) {
        return t.createElement("div", { "aria-expanded": Ue ? "true" : "false", "aria-haspopup": "dialog", "aria-controls": "rpv-core__modal-body-".concat(ne) }, he(ze, Ue));
      }, Fe = function(ze) {
        return t.createElement(
          pe,
          null,
          t.createElement(Z, { ariaControlsSuffix: ne, closeOnClickOutside: Y, closeOnEscape: ee, onToggle: ze }, J(ze))
        );
      };
      return t.createElement(_e, { target: he ? Se : null, content: Fe, isOpened: se });
    };
    e.Position = void 0, function(h) {
      h.TopLeft = "TOP_LEFT", h.TopCenter = "TOP_CENTER", h.TopRight = "TOP_RIGHT", h.RightTop = "RIGHT_TOP", h.RightCenter = "RIGHT_CENTER", h.RightBottom = "RIGHT_BOTTOM", h.BottomLeft = "BOTTOM_LEFT", h.BottomCenter = "BOTTOM_CENTER", h.BottomRight = "BOTTOM_RIGHT", h.LeftTop = "LEFT_TOP", h.LeftCenter = "LEFT_CENTER", h.LeftBottom = "LEFT_BOTTOM";
    }(e.Position || (e.Position = {}));
    var ke = function(h, O, Y, ee) {
      var J = O.getBoundingClientRect(), ae = h.getBoundingClientRect(), se = ae.height, he = ae.width, ne = 0, Se = 0;
      switch (Y) {
        case e.Position.TopLeft:
          ne = J.top - se, Se = J.left;
          break;
        case e.Position.TopCenter:
          ne = J.top - se, Se = J.left + J.width / 2 - he / 2;
          break;
        case e.Position.TopRight:
          ne = J.top - se, Se = J.left + J.width - he;
          break;
        case e.Position.RightTop:
          ne = J.top, Se = J.left + J.width;
          break;
        case e.Position.RightCenter:
          ne = J.top + J.height / 2 - se / 2, Se = J.left + J.width;
          break;
        case e.Position.RightBottom:
          ne = J.top + J.height - se, Se = J.left + J.width;
          break;
        case e.Position.BottomLeft:
          ne = J.top + J.height, Se = J.left;
          break;
        case e.Position.BottomCenter:
          ne = J.top + J.height, Se = J.left + J.width / 2 - he / 2;
          break;
        case e.Position.BottomRight:
          ne = J.top + J.height, Se = J.left + J.width - he;
          break;
        case e.Position.LeftTop:
          ne = J.top, Se = J.left - he;
          break;
        case e.Position.LeftCenter:
          ne = J.top + J.height / 2 - se / 2, Se = J.left - he;
          break;
        case e.Position.LeftBottom:
          ne = J.top + J.height - se, Se = J.left - he;
          break;
      }
      return {
        left: Se + (ee.left || 0),
        top: ne + (ee.top || 0)
      };
    }, de = function(h, O, Y, ee, J) {
      P(function() {
        var ae = O.current, se = h.current, he = Y.current;
        if (!(!se || !ae || !he)) {
          var ne = he.getBoundingClientRect(), Se = ke(se, ae, ee, J), Fe = Se.top, ze = Se.left;
          se.style.top = "".concat(Fe - ne.top, "px"), se.style.left = "".concat(ze - ne.left, "px");
        }
      }, []);
    }, $e = function(h) {
      var O, Y = h.customClassName, ee = h.position;
      return t.createElement("div", { className: H((O = {
        "rpv-core__arrow": !0,
        "rpv-core__arrow--tl": ee === e.Position.TopLeft,
        "rpv-core__arrow--tc": ee === e.Position.TopCenter,
        "rpv-core__arrow--tr": ee === e.Position.TopRight,
        "rpv-core__arrow--rt": ee === e.Position.RightTop,
        "rpv-core__arrow--rc": ee === e.Position.RightCenter,
        "rpv-core__arrow--rb": ee === e.Position.RightBottom,
        "rpv-core__arrow--bl": ee === e.Position.BottomLeft,
        "rpv-core__arrow--bc": ee === e.Position.BottomCenter,
        "rpv-core__arrow--br": ee === e.Position.BottomRight,
        "rpv-core__arrow--lt": ee === e.Position.LeftTop,
        "rpv-core__arrow--lc": ee === e.Position.LeftCenter,
        "rpv-core__arrow--lb": ee === e.Position.LeftBottom
      }, O["".concat(Y)] = Y !== "", O)) });
    }, Ge = function(h) {
      var O = h.ariaControlsSuffix, Y = h.children, ee = h.closeOnClickOutside, J = h.offset, ae = h.position, se = h.targetRef, he = h.onClose, ne = t.useRef(), Se = t.useRef(), Fe = t.useRef(), ze = t.useContext(N).direction, Ue = ze === e.TextDirection.RightToLeft;
      ye(ee, ne, he), de(ne, se, Fe, ae, J), P(function() {
        var Ze = Se.current;
        if (Ze) {
          var gt = document.body.clientHeight * 0.75;
          Ze.getBoundingClientRect().height >= gt && (Ze.style.overflow = "auto", Ze.style.maxHeight = "".concat(gt, "px"));
        }
      }, []);
      var ot = "rpv-core__popover-body-inner-".concat(O);
      return t.createElement(
        t.Fragment,
        null,
        t.createElement("div", { ref: Fe, style: { left: 0, position: "absolute", top: 0 } }),
        t.createElement(
          "div",
          { "aria-describedby": ot, className: H({
            "rpv-core__popover-body": !0,
            "rpv-core__popover-body--rtl": Ue
          }), id: "rpv-core__popover-body-".concat(O), ref: ne, role: "dialog", tabIndex: -1 },
          t.createElement($e, { customClassName: "rpv-core__popover-body-arrow", position: ae }),
          t.createElement("div", { id: ot, ref: Se }, Y)
        )
      );
    }, st = function(h) {
      var O = h.closeOnEscape, Y = h.onClose, ee = t.useRef();
      return ce(function() {
        ee.current && O && Y();
      }), t.createElement("div", { className: "rpv-core__popover-overlay", ref: ee });
    }, it = function(h) {
      var O = h.ariaHasPopup, Y = O === void 0 ? "dialog" : O, ee = h.ariaControlsSuffix, J = h.closeOnClickOutside, ae = h.closeOnEscape, se = h.content, he = h.lockScroll, ne = he === void 0 ? !0 : he, Se = h.offset, Fe = h.position, ze = h.target, Ue = me(!1), ot = Ue.opened, Ze = Ue.toggle, gt = t.useRef(), et = t.useMemo(function() {
        return ee || "".concat(qe());
      }, []);
      return t.createElement(
        "div",
        { ref: gt, "aria-expanded": ot ? "true" : "false", "aria-haspopup": Y, "aria-controls": "rpv-core__popver-body-".concat(et) },
        ze(Ze, ot),
        ot && t.createElement(
          t.Fragment,
          null,
          ne && t.createElement(st, { closeOnEscape: ae, onClose: Ze }),
          t.createElement(Ge, { ariaControlsSuffix: et, closeOnClickOutside: J, offset: Se, position: Fe, targetRef: gt, onClose: Ze }, se(Ze))
        )
      );
    }, _t = function(h) {
      var O = h.ariaControlsSuffix, Y = h.children, ee = h.contentRef, J = h.offset, ae = h.position, se = h.targetRef, he = t.useRef(), ne = t.useContext(N).direction, Se = ne === e.TextDirection.RightToLeft;
      return de(ee, se, he, ae, J), t.createElement(
        t.Fragment,
        null,
        t.createElement("div", { ref: he, style: { left: 0, position: "absolute", top: 0 } }),
        t.createElement(
          "div",
          { className: H({
            "rpv-core__tooltip-body": !0,
            "rpv-core__tooltip-body--rtl": Se
          }), id: "rpv-core__tooltip-body-".concat(O), ref: ee, role: "tooltip" },
          t.createElement($e, { customClassName: "rpv-core__tooltip-body-arrow", position: ae }),
          t.createElement("div", { className: "rpv-core__tooltip-body-content" }, Y)
        )
      );
    }, tt = function(h) {
      var O = h.ariaControlsSuffix, Y = h.content, ee = h.offset, J = h.position, ae = h.target, se = me(!1), he = se.opened, ne = se.toggle, Se = t.useRef(), Fe = t.useRef(), ze = t.useMemo(function() {
        return O || "".concat(qe());
      }, []);
      ce(function() {
        Se.current && document.activeElement && Se.current.contains(document.activeElement) && ot();
      });
      var Ue = function() {
        ne(e.ToggleStatus.Open);
      }, ot = function() {
        ne(e.ToggleStatus.Close);
      }, Ze = function(gt) {
        var et = gt.relatedTarget instanceof HTMLElement && gt.currentTarget.parentElement && gt.currentTarget.parentElement.contains(gt.relatedTarget);
        et ? Fe.current && (Fe.current.style.display = "none") : ot();
      };
      return t.createElement(
        t.Fragment,
        null,
        t.createElement("div", { ref: Se, "aria-describedby": "rpv-core__tooltip-body-".concat(ze), onBlur: Ze, onFocus: Ue, onMouseEnter: Ue, onMouseLeave: ot }, ae),
        he && t.createElement(_t, { ariaControlsSuffix: ze, contentRef: Fe, offset: ee, position: J, targetRef: Se }, Y())
      );
    };
    function Xe(h) {
      var O = h || {}, Y = {}, ee = function(ae, se) {
        var he;
        O = G(G({}, O), (he = {}, he[ae] = se, he)), (Y[ae] || []).forEach(function(ne) {
          return ne(O[ae]);
        });
      }, J = function(ae) {
        return O[ae];
      };
      return {
        subscribe: function(ae, se) {
          Y[ae] = (Y[ae] || []).concat(se);
        },
        unsubscribe: function(ae, se) {
          Y[ae] = (Y[ae] || []).filter(function(he) {
            return he !== se;
          });
        },
        update: function(ae, se) {
          ee(ae, se);
        },
        updateCurrentValue: function(ae, se) {
          var he = J(ae);
          he !== void 0 && ee(ae, se(he));
        },
        get: function(ae) {
          return J(ae);
        }
      };
    }
    e.FullScreenMode = void 0, function(h) {
      h.Normal = "Normal", h.Entering = "Entering", h.Entered = "Entered", h.EnteredCompletely = "EnteredCompletely", h.Exitting = "Exitting", h.Exited = "Exited";
    }(e.FullScreenMode || (e.FullScreenMode = {})), e.LayerRenderStatus = void 0, function(h) {
      h[h.PreRender = 0] = "PreRender", h[h.DidRender = 1] = "DidRender";
    }(e.LayerRenderStatus || (e.LayerRenderStatus = {})), e.PageMode = void 0, function(h) {
      h.Attachments = "UseAttachments", h.Bookmarks = "UseOutlines", h.ContentGroup = "UseOC", h.Default = "UserNone", h.FullScreen = "FullScreen", h.Thumbnails = "UseThumbs";
    }(e.PageMode || (e.PageMode = {})), e.PasswordStatus = void 0, function(h) {
      h.RequiredPassword = "RequiredPassword", h.WrongPassword = "WrongPassword";
    }(e.PasswordStatus || (e.PasswordStatus = {})), e.RotateDirection = void 0, function(h) {
      h.Backward = "Backward", h.Forward = "Forward";
    }(e.RotateDirection || (e.RotateDirection = {})), e.ScrollMode = void 0, function(h) {
      h.Page = "Page", h.Horizontal = "Horizontal", h.Vertical = "Vertical", h.Wrapped = "Wrapped";
    }(e.ScrollMode || (e.ScrollMode = {})), e.SpecialZoomLevel = void 0, function(h) {
      h.ActualSize = "ActualSize", h.PageFit = "PageFit", h.PageWidth = "PageWidth";
    }(e.SpecialZoomLevel || (e.SpecialZoomLevel = {})), e.ViewMode = void 0, function(h) {
      h.DualPage = "DualPage", h.DualPageWithCover = "DualPageWithCover", h.SinglePage = "SinglePage";
    }(e.ViewMode || (e.ViewMode = {}));
    var ct = function(h, O) {
      return h.reduce(function(Y, ee, J) {
        return J % O ? Y[Y.length - 1].push(ee) : Y.push([ee]), Y;
      }, []);
    }, xt = function() {
      return typeof window < "u" ? /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform) : !1;
    }, We = function(h, O) {
      switch (O[1].name) {
        case "XYZ":
          return {
            bottomOffset: function(Y, ee) {
              return O[3] === null ? ee : O[3];
            },
            leftOffset: function(Y, ee) {
              return O[2] === null ? 0 : O[2];
            },
            pageIndex: h,
            scaleTo: O[4]
          };
        case "Fit":
        case "FitB":
          return {
            bottomOffset: 0,
            leftOffset: 0,
            pageIndex: h,
            scaleTo: e.SpecialZoomLevel.PageFit
          };
        case "FitH":
        case "FitBH":
          return {
            bottomOffset: O[2],
            leftOffset: 0,
            pageIndex: h,
            scaleTo: e.SpecialZoomLevel.PageWidth
          };
        default:
          return {
            bottomOffset: 0,
            leftOffset: 0,
            pageIndex: h,
            scaleTo: 1
          };
      }
    }, Ce = /* @__PURE__ */ new Map(), Re = /* @__PURE__ */ new Map(), lt = function(h, O) {
      return "".concat(h.loadingTask.docId, "___").concat(O.num, "R").concat(O.gen === 0 ? "" : O.gen);
    }, bt = function(h, O) {
      var Y = lt(h, O);
      return Ce.has(Y) ? Ce.get(Y) : null;
    }, Et = function(h, O, Y) {
      Ce.set(lt(h, O), Y);
    }, oe = function() {
      Ce.clear(), Re.clear();
    }, He = function(h, O) {
      if (!h)
        return Promise.reject("The document is not loaded yet");
      var Y = "".concat(h.loadingTask.docId, "___").concat(O), ee = Re.get(Y);
      return ee ? Promise.resolve(ee) : new Promise(function(J, ae) {
        h.getPage(O + 1).then(function(se) {
          Re.set(Y, se), se.ref && Et(h, se.ref, O), J(se);
        });
      });
    }, at = function(h, O) {
      return new Promise(function(Y) {
        new Promise(function(ee) {
          typeof O == "string" ? h.getDestination(O).then(function(J) {
            ee(J);
          }) : ee(O);
        }).then(function(ee) {
          if (typeof ee[0] == "object" && ee[0] !== null) {
            var J = ee[0], ae = bt(h, J);
            ae === null ? h.getPageIndex(J).then(function(he) {
              Et(h, J, he), at(h, O).then(function(ne) {
                return Y(ne);
              });
            }) : Y(We(ae, ee));
          } else {
            var se = We(ee[0], ee);
            Y(se);
          }
        });
      });
    }, St = function(h, O) {
      var Y = t.useRef(!1);
      P(function() {
        O && !Y.current && (Y.current = !0, h());
      }, [h, O]);
    }, yt = function(h) {
      var O = h.targetRef, Y = h.onResize;
      P(function() {
        var ee = new ResizeObserver(function(ae) {
          ae.forEach(function(se) {
            Y(se.target);
          });
        }), J = O.current;
        if (J)
          return ee.observe(J), function() {
            ee.unobserve(J);
          };
      }, []);
    }, dt;
    (function(h) {
      h[h.Solid = 1] = "Solid", h[h.Dashed = 2] = "Dashed", h[h.Beveled = 3] = "Beveled", h[h.Inset = 4] = "Inset", h[h.Underline = 5] = "Underline";
    })(dt || (dt = {}));
    var ie = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"), te = function(h, O, Y, ee) {
      var J = parseInt(h, 10);
      return J >= O && J <= Y ? J : ee;
    }, we = function(h) {
      var O = ie.exec(h);
      if (!O)
        return null;
      var Y = parseInt(O[1], 10), ee = te(O[2], 1, 12, 1) - 1, J = te(O[3], 1, 31, 1), ae = te(O[4], 0, 23, 0), se = te(O[5], 0, 59, 0), he = te(O[6], 0, 59, 0), ne = O[7] || "Z", Se = te(O[8], 0, 23, 0), Fe = te(O[9], 0, 59, 0);
      switch (ne) {
        case "-":
          ae += Se, se += Fe;
          break;
        case "+":
          ae -= Se, se -= Fe;
          break;
      }
      return new Date(Date.UTC(Y, ee, J, ae, se, he));
    }, De = function(h) {
      return h.contentsObj ? h.contentsObj.str : h.contents || "";
    }, Ve = function(h) {
      return h.titleObj ? h.titleObj.str : h.title || "";
    }, Ye = function(h) {
      var O = h.annotation, Y = t.useContext(N).direction, ee = Ve(O), J = De(O), ae = Y === e.TextDirection.RightToLeft, se = t.useRef(), he = "";
      if (O.modificationDate) {
        var ne = we(O.modificationDate);
        he = ne ? "".concat(ne.toLocaleDateString(), ", ").concat(ne.toLocaleTimeString()) : "";
      }
      return t.useLayoutEffect(function() {
        var Se = se.current;
        if (Se) {
          var Fe = document.querySelector('[data-annotation-id="'.concat(O.id, '"]'));
          if (Fe) {
            var ze = Fe;
            return ze.style.zIndex += 1, function() {
              ze.style.zIndex = "".concat(parseInt(ze.style.zIndex, 10) - 1);
            };
          }
        }
      }, []), t.createElement(
        "div",
        { ref: se, className: H({
          "rpv-core__annotation-popup-wrapper": !0,
          "rpv-core__annotation-popup-wrapper--rtl": ae
        }), style: {
          top: O.annotationType === e.AnnotationType.Popup ? "" : "100%"
        } },
        ee && t.createElement(
          t.Fragment,
          null,
          t.createElement("div", { className: H({
            "rpv-core__annotation-popup-title": !0,
            "rpv-core__annotation-popup-title--ltr": !ae,
            "rpv-core__annotation-popup-title--rtl": ae
          }) }, ee),
          t.createElement("div", { className: "rpv-core__annotation-popup-date" }, he)
        ),
        J && t.createElement("div", { className: "rpv-core__annotation-popup-content" }, J.split(`
`).map(function(Se, Fe) {
          return t.createElement(
            t.Fragment,
            { key: Fe },
            Se,
            t.createElement("br", null)
          );
        }))
      );
    }, Je;
    (function(h) {
      h.Click = "Click", h.Hover = "Hover";
    })(Je || (Je = {}));
    var Pt = function() {
      var h = me(!1), O = h.opened, Y = h.toggle, ee = t.useState(Je.Hover), J = ee[0], ae = ee[1], se = function() {
        switch (J) {
          case Je.Click:
            O && ae(Je.Hover), Y(e.ToggleStatus.Toggle);
            break;
          case Je.Hover:
            ae(Je.Click), Y(e.ToggleStatus.Open);
            break;
        }
      }, he = function() {
        J === Je.Hover && Y(e.ToggleStatus.Open);
      }, ne = function() {
        J === Je.Hover && Y(e.ToggleStatus.Close);
      };
      return {
        opened: O,
        closeOnHover: ne,
        openOnHover: he,
        toggleOnClick: se
      };
    }, mt = function(h) {
      var O = h.annotation, Y = h.children, ee = h.ignoreBorder, J = h.hasPopup, ae = h.isRenderable, se = h.page, he = h.viewport, ne = O.rect, Se = Pt(), Fe = Se.closeOnHover, ze = Se.opened, Ue = Se.openOnHover, ot = Se.toggleOnClick, Ze = function(Ht) {
        return [
          Math.min(Ht[0], Ht[2]),
          Math.min(Ht[1], Ht[3]),
          Math.max(Ht[0], Ht[2]),
          Math.max(Ht[1], Ht[3])
        ];
      }, gt = Ze([
        ne[0],
        se.view[3] + se.view[1] - ne[1],
        ne[2],
        se.view[3] + se.view[1] - ne[3]
      ]), et = ne[2] - ne[0], It = ne[3] - ne[1], Rt = {
        borderColor: "",
        borderRadius: "",
        borderStyle: "",
        borderWidth: ""
      };
      if (!ee && O.borderStyle.width > 0) {
        switch (O.borderStyle.style) {
          case dt.Dashed:
            Rt.borderStyle = "dashed";
            break;
          case dt.Solid:
            Rt.borderStyle = "solid";
            break;
          case dt.Underline:
            Rt = Object.assign({
              borderBottomStyle: "solid"
            }, Rt);
            break;
          case dt.Beveled:
          case dt.Inset:
        }
        var wt = O.borderStyle.width;
        Rt.borderWidth = "".concat(wt, "px"), O.borderStyle.style !== dt.Underline && (et = et - 2 * wt, It = It - 2 * wt);
        var En = O.borderStyle, Zt = En.horizontalCornerRadius, Bt = En.verticalCornerRadius;
        (Zt > 0 || Bt > 0) && (Rt.borderRadius = "".concat(Zt, "px / ").concat(Bt, "px")), O.color ? Rt.borderColor = "rgb(".concat(O.color[0] | 0, ", ").concat(O.color[1] | 0, ", ").concat(O.color[2] | 0, ")") : Rt.borderWidth = "0";
      }
      return t.createElement(t.Fragment, null, ae && Y({
        popup: {
          opened: ze,
          closeOnHover: Fe,
          openOnHover: Ue,
          toggleOnClick: ot
        },
        slot: {
          attrs: {
            style: Object.assign({
              height: "".concat(It, "px"),
              left: "".concat(gt[0], "px"),
              top: "".concat(gt[1], "px"),
              transform: "matrix(".concat(he.transform.join(","), ")"),
              transformOrigin: "-".concat(gt[0], "px -").concat(gt[1], "px"),
              width: "".concat(et, "px")
            }, Rt)
          },
          children: t.createElement(t.Fragment, null, J && ze && t.createElement(Ye, { annotation: O }))
        }
      }));
    }, pt = function(h) {
      var O = h.annotation, Y = h.page, ee = h.viewport, J = O.hasPopup === !1, ae = Ve(O), se = De(O), he = !!(O.hasPopup || ae || se);
      return t.createElement(mt, { annotation: O, hasPopup: J, ignoreBorder: !0, isRenderable: he, page: Y, viewport: ee }, function(ne) {
        return t.createElement("div", G({}, ne.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--caret", "data-annotation-id": O.id, onClick: ne.popup.toggleOnClick, onMouseEnter: ne.popup.openOnHover, onMouseLeave: ne.popup.closeOnHover }), ne.slot.children);
      });
    }, Ut = function(h) {
      var O = h.annotation, Y = h.page, ee = h.viewport, J = O.hasPopup === !1, ae = Ve(O), se = De(O), he = !!(O.hasPopup || ae || se), ne = O.rect, Se = ne[2] - ne[0], Fe = ne[3] - ne[1], ze = O.borderStyle.width;
      return t.createElement(mt, { annotation: O, hasPopup: J, ignoreBorder: !0, isRenderable: he, page: Y, viewport: ee }, function(Ue) {
        return t.createElement(
          "div",
          G({}, Ue.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--circle", "data-annotation-id": O.id, onClick: Ue.popup.toggleOnClick, onMouseEnter: Ue.popup.openOnHover, onMouseLeave: Ue.popup.closeOnHover }),
          t.createElement(
            "svg",
            { height: "".concat(Fe, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(Se, " ").concat(Fe), width: "".concat(Se, "px") },
            t.createElement("circle", { cy: Fe / 2, fill: "none", rx: Se / 2 - ze / 2, ry: Fe / 2 - ze / 2, stroke: "transparent", strokeWidth: ze || 1 })
          ),
          Ue.slot.children
        );
      });
    }, Ct = function(h) {
      var O = h.split("/").pop();
      return O ? O.split("#")[0].split("?")[0] : h;
    }, Mt = function(h, O) {
      var Y = typeof O == "string" ? "" : URL.createObjectURL(new Blob([O], { type: "" })), ee = document.createElement("a");
      ee.style.display = "none", ee.href = Y || h, ee.setAttribute("download", Ct(h)), document.body.appendChild(ee), ee.click(), document.body.removeChild(ee), Y && URL.revokeObjectURL(Y);
    }, zt = function(h) {
      var O = h.annotation, Y = h.page, ee = h.viewport, J = Ve(O), ae = De(O), se = O.hasPopup === !1 && (!!J || !!ae), he = function() {
        var ne = O.file;
        ne && Mt(ne.filename, ne.content);
      };
      return t.createElement(mt, { annotation: O, hasPopup: se, ignoreBorder: !0, isRenderable: !0, page: Y, viewport: ee }, function(ne) {
        return t.createElement("div", G({}, ne.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--file-attachment", "data-annotation-id": O.id, onClick: ne.popup.toggleOnClick, onDoubleClick: he, onMouseEnter: ne.popup.openOnHover, onMouseLeave: ne.popup.closeOnHover }), ne.slot.children);
      });
    }, Xt = function(h) {
      var O = h.annotation, Y = h.page, ee = h.viewport, J = O.hasPopup === !1, ae = Ve(O), se = De(O), he = !!(O.hasPopup || ae || se);
      return t.createElement(mt, { annotation: O, hasPopup: J, ignoreBorder: !0, isRenderable: he, page: Y, viewport: ee }, function(ne) {
        return t.createElement("div", G({}, ne.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--free-text", "data-annotation-id": O.id, onClick: ne.popup.toggleOnClick, onMouseEnter: ne.popup.openOnHover, onMouseLeave: ne.popup.closeOnHover }), ne.slot.children);
      });
    }, sn = function(h) {
      var O = h.annotation, Y = h.page, ee = h.viewport, J = Ve(O), ae = De(O), se = !!(J || ae), he = ["Circle", "Ink", "Line", "Polygon", "PolyLine", "Square"], ne = !O.parentType || he.indexOf(O.parentType) !== -1;
      return P(function() {
        if (O.parentId) {
          var Se = document.querySelector('[data-annotation-id="'.concat(O.parentId, '"]')), Fe = document.querySelector('[data-annotation-id="'.concat(O.id, '"]'));
          if (!(!Se || !Fe)) {
            var ze = parseFloat(Se.style.left), Ue = parseFloat(Se.style.top) + parseFloat(Se.style.height);
            Fe.style.left = "".concat(ze, "px"), Fe.style.top = "".concat(Ue, "px"), Fe.style.transformOrigin = "-".concat(ze, "px -").concat(Ue, "px");
          }
        }
      }, []), t.createElement(mt, { annotation: O, hasPopup: ne, ignoreBorder: !1, isRenderable: se, page: Y, viewport: ee }, function(Se) {
        return t.createElement(
          "div",
          G({}, Se.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--popup", "data-annotation-id": O.id }),
          t.createElement(Ye, { annotation: O })
        );
      });
    }, gn = function(h) {
      var O = h.annotation, Y = h.childAnnotation, ee = h.page, J = h.viewport, ae = O.hasPopup === !1, se = Ve(O), he = De(O), ne = !!(O.hasPopup || se || he), Se = O.quadPoints && O.quadPoints.length > 0;
      if (Se) {
        var Fe = O.quadPoints.map(function(ze) {
          return Object.assign({}, O, {
            rect: [ze[2].x, ze[2].y, ze[1].x, ze[1].y],
            quadPoints: []
          });
        });
        return t.createElement(t.Fragment, null, Fe.map(function(ze, Ue) {
          return t.createElement(gn, { key: Ue, annotation: ze, childAnnotation: Y, page: ee, viewport: J });
        }));
      }
      return t.createElement(mt, { annotation: O, hasPopup: ae, ignoreBorder: !0, isRenderable: ne, page: ee, viewport: J }, function(ze) {
        return t.createElement(
          t.Fragment,
          null,
          t.createElement("div", G({}, ze.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--highlight", "data-annotation-id": O.id, onClick: ze.popup.toggleOnClick, onMouseEnter: ze.popup.openOnHover, onMouseLeave: ze.popup.closeOnHover }), ze.slot.children),
          Y && Y.annotationType === e.AnnotationType.Popup && ze.popup.opened && t.createElement(sn, { annotation: Y, page: ee, viewport: J })
        );
      });
    }, Un = function(h) {
      var O = h.annotation, Y = h.page, ee = h.viewport, J = O.hasPopup === !1, ae = Ve(O), se = De(O), he = !!(O.hasPopup || ae || se), ne = O.rect, Se = ne[2] - ne[0], Fe = ne[3] - ne[1], ze = O.borderStyle.width;
      return t.createElement(mt, { annotation: O, hasPopup: J, ignoreBorder: !0, isRenderable: he, page: Y, viewport: ee }, function(Ue) {
        return t.createElement(
          "div",
          G({}, Ue.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--ink", "data-annotation-id": O.id, onClick: Ue.popup.toggleOnClick, onMouseEnter: Ue.popup.openOnHover, onMouseLeave: Ue.popup.closeOnHover }),
          O.inkLists && O.inkLists.length && t.createElement("svg", { height: "".concat(Fe, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(Se, " ").concat(Fe), width: "".concat(Se, "px") }, O.inkLists.map(function(ot, Ze) {
            return t.createElement("polyline", { key: Ze, fill: "none", stroke: "transparent", strokeWidth: ze || 1, points: ot.map(function(gt) {
              return "".concat(gt.x - ne[0], ",").concat(ne[3] - gt.y);
            }).join(" ") });
          })),
          Ue.slot.children
        );
      });
    }, xn = function(h) {
      var O = h.annotation, Y = h.page, ee = h.viewport, J = O.hasPopup === !1, ae = Ve(O), se = De(O), he = !!(O.hasPopup || ae || se), ne = O.rect, Se = ne[2] - ne[0], Fe = ne[3] - ne[1], ze = O.borderStyle.width;
      return t.createElement(mt, { annotation: O, hasPopup: J, ignoreBorder: !0, isRenderable: he, page: Y, viewport: ee }, function(Ue) {
        return t.createElement(
          "div",
          G({}, Ue.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--line", "data-annotation-id": O.id, onClick: Ue.popup.toggleOnClick, onMouseEnter: Ue.popup.openOnHover, onMouseLeave: Ue.popup.closeOnHover }),
          t.createElement(
            "svg",
            { height: "".concat(Fe, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(Se, " ").concat(Fe), width: "".concat(Se, "px") },
            t.createElement("line", { stroke: "transparent", strokeWidth: ze || 1, x1: ne[2] - O.lineCoordinates[0], x2: ne[2] - O.lineCoordinates[2], y1: ne[3] - O.lineCoordinates[1], y2: ne[3] - O.lineCoordinates[3] })
          ),
          Ue.slot.children
        );
      });
    }, lr = /^([^\w]*)(javascript|data|vbscript)/im, hr = /&#(\w+)(^\w|;)?/g, fr = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim, Fr = /^([^:]+):/gm, Ta = function(h) {
      return h.replace(hr, function(O, Y) {
        return String.fromCharCode(Y);
      });
    }, Aa = function(h, O) {
      var Y = Ta(h || "").replace(fr, "").trim();
      if (!Y)
        return O;
      var ee = Y[0];
      if (ee === "." || ee === "/")
        return Y;
      var J = Y.match(Fr);
      if (!J)
        return Y;
      var ae = J[0];
      return lr.test(ae) ? O : Y;
    }, Dr = function(h) {
      var O, Y = h.annotation, ee = h.annotationContainerRef, J = h.doc, ae = h.outlines, se = h.page, he = h.pageIndex, ne = h.scale, Se = h.viewport, Fe = h.onExecuteNamedAction, ze = h.onJumpFromLinkAnnotation, Ue = h.onJumpToDest, ot = t.useRef(), Ze = ae && ae.length && Y.dest && typeof Y.dest == "string" ? (O = ae.find(function(wt) {
        return wt.dest === Y.dest;
      })) === null || O === void 0 ? void 0 : O.title : "", gt = function(wt) {
        wt.preventDefault(), Y.action ? Fe(Y.action) : at(J, Y.dest).then(function(En) {
          var Zt = ot.current, Bt = ee.current;
          if (Zt && Bt) {
            var Ht = Zt.getBoundingClientRect();
            Bt.style.setProperty("height", "100%"), Bt.style.setProperty("width", "100%");
            var An = Bt.getBoundingClientRect();
            Bt.style.removeProperty("height"), Bt.style.removeProperty("width");
            var $n = (Ht.left - An.left) / ne, Dn = (An.bottom - Ht.bottom + Ht.height) / ne;
            ze({
              bottomOffset: Dn,
              label: Ze,
              leftOffset: $n,
              pageIndex: he
            });
          }
          Ue(En);
        });
      }, et = !!(Y.url || Y.dest || Y.action || Y.unsafeUrl), It = {};
      if (Y.url || Y.unsafeUrl) {
        var Rt = Aa(Y.url || Y.unsafeUrl, "");
        Rt ? It = {
          "data-target": "external",
          href: Rt,
          rel: "noopener noreferrer nofollow",
          target: Y.newWindow ? "_blank" : "",
          title: Rt
        } : et = !1;
      } else
        It = {
          href: "",
          "data-annotation-link": Y.id,
          onClick: gt
        };
      return Ze && (It = Object.assign({}, It, {
        title: Ze,
        "aria-label": Ze
      })), t.createElement(mt, { annotation: Y, hasPopup: !1, ignoreBorder: !1, isRenderable: et, page: se, viewport: Se }, function(wt) {
        return t.createElement(
          "div",
          G({}, wt.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--link", "data-annotation-id": Y.id, "data-testid": "core__annotation--link-".concat(Y.id) }),
          t.createElement("a", G({ ref: ot }, It))
        );
      });
    }, xa = function(h) {
      var O = h.annotation, Y = h.page, ee = h.viewport, J = O.hasPopup === !1, ae = Ve(O), se = De(O), he = !!(O.hasPopup || ae || se), ne = O.rect, Se = ne[2] - ne[0], Fe = ne[3] - ne[1], ze = O.borderStyle.width;
      return t.createElement(mt, { annotation: O, hasPopup: J, ignoreBorder: !0, isRenderable: he, page: Y, viewport: ee }, function(Ue) {
        return t.createElement(
          "div",
          G({}, Ue.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--polygon", "data-annotation-id": O.id, onClick: Ue.popup.toggleOnClick, onMouseEnter: Ue.popup.openOnHover, onMouseLeave: Ue.popup.closeOnHover }),
          O.vertices && O.vertices.length && t.createElement(
            "svg",
            { height: "".concat(Fe, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(Se, " ").concat(Fe), width: "".concat(Se, "px") },
            t.createElement("polygon", { fill: "none", stroke: "transparent", strokeWidth: ze || 1, points: O.vertices.map(function(ot) {
              return "".concat(ot.x - ne[0], ",").concat(ne[3] - ot.y);
            }).join(" ") })
          ),
          Ue.slot.children
        );
      });
    }, La = function(h) {
      var O = h.annotation, Y = h.page, ee = h.viewport, J = O.hasPopup === !1, ae = Ve(O), se = De(O), he = !!(O.hasPopup || ae || se), ne = O.rect, Se = ne[2] - ne[0], Fe = ne[3] - ne[1], ze = O.borderStyle.width;
      return t.createElement(mt, { annotation: O, hasPopup: J, ignoreBorder: !0, isRenderable: he, page: Y, viewport: ee }, function(Ue) {
        return t.createElement(
          "div",
          G({}, Ue.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--polyline", "data-annotation-id": O.id, onClick: Ue.popup.toggleOnClick, onMouseEnter: Ue.popup.openOnHover, onMouseLeave: Ue.popup.closeOnHover }),
          O.vertices && O.vertices.length && t.createElement(
            "svg",
            { height: "".concat(Fe, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(Se, " ").concat(Fe), width: "".concat(Se, "px") },
            t.createElement("polyline", { fill: "none", stroke: "transparent", strokeWidth: ze || 1, points: O.vertices.map(function(ot) {
              return "".concat(ot.x - ne[0], ",").concat(ne[3] - ot.y);
            }).join(" ") })
          ),
          Ue.slot.children
        );
      });
    }, Ia = function(h) {
      var O = h.annotation, Y = h.page, ee = h.viewport, J = O.hasPopup === !1, ae = Ve(O), se = De(O), he = !!(O.hasPopup || ae || se), ne = O.rect, Se = ne[2] - ne[0], Fe = ne[3] - ne[1], ze = O.borderStyle.width;
      return t.createElement(mt, { annotation: O, hasPopup: J, ignoreBorder: !0, isRenderable: he, page: Y, viewport: ee }, function(Ue) {
        return t.createElement(
          "div",
          G({}, Ue.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--square", "data-annotation-id": O.id, onClick: Ue.popup.toggleOnClick, onMouseEnter: Ue.popup.openOnHover, onMouseLeave: Ue.popup.closeOnHover }),
          t.createElement(
            "svg",
            { height: "".concat(Fe, "px"), preserveAspectRatio: "none", version: "1.1", viewBox: "0 0 ".concat(Se, " ").concat(Fe), width: "".concat(Se, "px") },
            t.createElement("rect", { height: Fe - ze, fill: "none", stroke: "transparent", strokeWidth: ze || 1, x: ze / 2, y: ze / 2, width: Se - ze })
          ),
          Ue.slot.children
        );
      });
    }, Fa = function(h) {
      var O = h.annotation, Y = h.page, ee = h.viewport, J = O.hasPopup === !1, ae = Ve(O), se = De(O), he = !!(O.hasPopup || ae || se);
      return t.createElement(mt, { annotation: O, hasPopup: J, ignoreBorder: !0, isRenderable: he, page: Y, viewport: ee }, function(ne) {
        return t.createElement("div", G({}, ne.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--squiggly", "data-annotation-id": O.id, onClick: ne.popup.toggleOnClick, onMouseEnter: ne.popup.openOnHover, onMouseLeave: ne.popup.closeOnHover }), ne.slot.children);
      });
    }, Da = function(h) {
      var O = h.annotation, Y = h.page, ee = h.viewport, J = O.hasPopup === !1, ae = Ve(O), se = De(O), he = !!(O.hasPopup || ae || se);
      return t.createElement(mt, { annotation: O, hasPopup: J, ignoreBorder: !0, isRenderable: he, page: Y, viewport: ee }, function(ne) {
        return t.createElement("div", G({}, ne.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--stamp", "data-annotation-id": O.id, onClick: ne.popup.toggleOnClick, onMouseEnter: ne.popup.openOnHover, onMouseLeave: ne.popup.closeOnHover }), ne.slot.children);
      });
    }, Oa = function(h) {
      var O = h.annotation, Y = h.page, ee = h.viewport, J = O.hasPopup === !1, ae = Ve(O), se = De(O), he = !!(O.hasPopup || ae || se);
      return t.createElement(mt, { annotation: O, hasPopup: J, ignoreBorder: !0, isRenderable: he, page: Y, viewport: ee }, function(ne) {
        return t.createElement("div", G({}, ne.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--strike-out", "data-annotation-id": O.id, onClick: ne.popup.toggleOnClick, onMouseEnter: ne.popup.openOnHover, onMouseLeave: ne.popup.closeOnHover }), ne.slot.children);
      });
    }, Or = function() {
      return t.createElement(
        s,
        { size: 16 },
        t.createElement("path", { d: "M.5,16.5a1,1,0,0,0,1,1h2v4l4-4h15a1,1,0,0,0,1-1V3.5a1,1,0,0,0-1-1H1.5a1,1,0,0,0-1,1Z" }),
        t.createElement("path", { d: "M7.25,9.75A.25.25,0,1,1,7,10a.25.25,0,0,1,.25-.25" }),
        t.createElement("path", { d: "M12,9.75a.25.25,0,1,1-.25.25A.25.25,0,0,1,12,9.75" }),
        t.createElement("path", { d: "M16.75,9.75a.25.25,0,1,1-.25.25.25.25,0,0,1,.25-.25" })
      );
    }, ia = function() {
      return t.createElement(
        s,
        { size: 16 },
        t.createElement("path", { d: "M0.500 12.001 A11.500 11.500 0 1 0 23.500 12.001 A11.500 11.500 0 1 0 0.500 12.001 Z" }),
        t.createElement("path", { d: "M6.000 12.001 A6.000 6.000 0 1 0 18.000 12.001 A6.000 6.000 0 1 0 6.000 12.001 Z" }),
        t.createElement("path", { d: "M21.423 5.406L17.415 9.414" }),
        t.createElement("path", { d: "M14.587 6.585L18.607 2.565" }),
        t.createElement("path", { d: "M5.405 21.424L9.413 17.416" }),
        t.createElement("path", { d: "M6.585 14.588L2.577 18.596" }),
        t.createElement("path", { d: "M18.602 21.419L14.595 17.412" }),
        t.createElement("path", { d: "M17.419 14.58L21.428 18.589" }),
        t.createElement("path", { d: "M2.582 5.399L6.588 9.406" }),
        t.createElement("path", { d: "M9.421 6.581L5.412 2.572" })
      );
    }, oa = function() {
      return t.createElement(
        s,
        { size: 16 },
        t.createElement("path", { d: "M4.000 18.500 A1.500 1.500 0 1 0 7.000 18.500 A1.500 1.500 0 1 0 4.000 18.500 Z" }),
        t.createElement("path", { d: "M20.5.5l-9.782,9.783a7,7,0,1,0,3,3L17,10h1.5V8.5L19,8h1.5V6.5L21,6h1.5V4.5l1-1V.5Z" })
      );
    }, Na = function() {
      return t.createElement(
        s,
        { size: 16 },
        t.createElement("path", { d: "M2.000 2.500 L22.000 2.500 L22.000 23.500 L2.000 23.500 Z" }),
        t.createElement("path", { d: "M6 4.5L6 0.5" }),
        t.createElement("path", { d: "M18 4.5L18 0.5" }),
        t.createElement("path", { d: "M10 4.5L10 0.5" }),
        t.createElement("path", { d: "M14 4.5L14 0.5" })
      );
    }, Tr = function() {
      return t.createElement(
        s,
        { size: 16 },
        t.createElement("path", { d: "M17.5 0.498L17.5 23.498" }),
        t.createElement("path", { d: "M10.5 0.498L10.5 23.498" }),
        t.createElement("path", { d: "M23.5.5H6.5a6,6,0,0,0,0,12h4" })
      );
    }, Ba = function() {
      return t.createElement(
        s,
        { size: 16 },
        t.createElement("path", { d: "M2.5 22.995L12 6.005 21.5 22.995 2.5 22.995z" })
      );
    }, za = function(h) {
      var O = h.annotation, Y = h.childAnnotation, ee = h.page, J = h.viewport, ae = O.hasPopup === !1, se = Ve(O), he = De(O), ne = !!(O.hasPopup || se || he), Se = O.name ? O.name.toLowerCase() : "";
      return t.createElement(mt, { annotation: O, hasPopup: ae, ignoreBorder: !1, isRenderable: ne, page: ee, viewport: J }, function(Fe) {
        return t.createElement(
          t.Fragment,
          null,
          t.createElement(
            "div",
            G({}, Fe.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--text", "data-annotation-id": O.id, onClick: Fe.popup.toggleOnClick, onMouseEnter: Fe.popup.openOnHover, onMouseLeave: Fe.popup.closeOnHover }),
            Se && t.createElement(
              "div",
              { className: "rpv-core__annotation-text-icon" },
              Se === "check" && t.createElement(w, null),
              Se === "comment" && t.createElement(Or, null),
              Se === "help" && t.createElement(ia, null),
              Se === "insert" && t.createElement(Ba, null),
              Se === "key" && t.createElement(oa, null),
              Se === "note" && t.createElement(Na, null),
              (Se === "newparagraph" || Se === "paragraph") && t.createElement(Tr, null)
            ),
            Fe.slot.children
          ),
          Y && Y.annotationType === e.AnnotationType.Popup && Fe.popup.opened && t.createElement(sn, { annotation: Y, page: ee, viewport: J })
        );
      });
    }, ja = function(h) {
      var O = h.annotation, Y = h.page, ee = h.viewport, J = O.hasPopup === !1, ae = Ve(O), se = De(O), he = !!(O.hasPopup || ae || se);
      return t.createElement(mt, { annotation: O, hasPopup: J, ignoreBorder: !0, isRenderable: he, page: Y, viewport: ee }, function(ne) {
        return t.createElement("div", G({}, ne.slot.attrs, { className: "rpv-core__annotation rpv-core__annotation--underline", "data-annotation-id": O.id, onClick: ne.popup.toggleOnClick, onMouseEnter: ne.popup.openOnHover, onMouseLeave: ne.popup.closeOnHover }), ne.slot.children);
      });
    }, Ur = function(h) {
      var O = h.annotations, Y = h.doc, ee = h.outlines, J = h.page, ae = h.pageIndex, se = h.plugins, he = h.rotation, ne = h.scale, Se = h.onExecuteNamedAction, Fe = h.onJumpFromLinkAnnotation, ze = h.onJumpToDest, Ue = t.useRef(), ot = J.getViewport({ rotation: he, scale: ne }), Ze = ot.clone({ dontFlip: !0 }), gt = O.filter(function(et) {
        return !et.parentId;
      });
      return P(function() {
        var et = Ue.current;
        et && se.forEach(function(It) {
          It.onAnnotationLayerRender && It.onAnnotationLayerRender({
            annotations: gt,
            container: et,
            pageIndex: ae,
            rotation: he,
            scale: ne
          });
        });
      }, []), t.createElement("div", { ref: Ue, className: "rpv-core__annotation-layer", "data-testid": "core__annotation-layer-".concat(ae) }, gt.map(function(et) {
        var It = O.find(function(Rt) {
          return Rt.parentId === et.id;
        });
        switch (et.annotationType) {
          case e.AnnotationType.Caret:
            return t.createElement(pt, { key: et.id, annotation: et, page: J, viewport: Ze });
          case e.AnnotationType.Circle:
            return t.createElement(Ut, { key: et.id, annotation: et, page: J, viewport: Ze });
          case e.AnnotationType.FileAttachment:
            return t.createElement(zt, { key: et.id, annotation: et, page: J, viewport: Ze });
          case e.AnnotationType.FreeText:
            return t.createElement(Xt, { key: et.id, annotation: et, page: J, viewport: Ze });
          case e.AnnotationType.Highlight:
            return t.createElement(gn, { key: et.id, annotation: et, childAnnotation: It, page: J, viewport: Ze });
          case e.AnnotationType.Ink:
            return t.createElement(Un, { key: et.id, annotation: et, page: J, viewport: Ze });
          case e.AnnotationType.Line:
            return t.createElement(xn, { key: et.id, annotation: et, page: J, viewport: Ze });
          case e.AnnotationType.Link:
            return t.createElement(Dr, { key: et.id, annotation: et, annotationContainerRef: Ue, doc: Y, outlines: ee, page: J, pageIndex: ae, scale: ne, viewport: Ze, onExecuteNamedAction: Se, onJumpFromLinkAnnotation: Fe, onJumpToDest: ze });
          case e.AnnotationType.Polygon:
            return t.createElement(xa, { key: et.id, annotation: et, page: J, viewport: Ze });
          case e.AnnotationType.Polyline:
            return t.createElement(La, { key: et.id, annotation: et, page: J, viewport: Ze });
          case e.AnnotationType.Popup:
            return t.createElement(sn, { key: et.id, annotation: et, page: J, viewport: Ze });
          case e.AnnotationType.Square:
            return t.createElement(Ia, { key: et.id, annotation: et, page: J, viewport: Ze });
          case e.AnnotationType.Squiggly:
            return t.createElement(Fa, { key: et.id, annotation: et, page: J, viewport: Ze });
          case e.AnnotationType.Stamp:
            return t.createElement(Da, { key: et.id, annotation: et, page: J, viewport: Ze });
          case e.AnnotationType.StrikeOut:
            return t.createElement(Oa, { key: et.id, annotation: et, page: J, viewport: Ze });
          case e.AnnotationType.Text:
            return t.createElement(za, { key: et.id, annotation: et, childAnnotation: It, page: J, viewport: Ze });
          case e.AnnotationType.Underline:
            return t.createElement(ja, { key: et.id, annotation: et, page: J, viewport: Ze });
          default:
            return t.createElement(t.Fragment, { key: et.id });
        }
      }));
    }, Va = function(h) {
      var O = h.page, Y = h.renderAnnotations, ee = F(), J = t.useState({
        loading: !0,
        annotations: []
      }), ae = J[0], se = J[1];
      return t.useEffect(function() {
        O.getAnnotations({ intent: "display" }).then(function(he) {
          ee.current && se({
            loading: !1,
            annotations: he
          });
        });
      }, []), ae.loading ? t.createElement(t.Fragment, null) : Y(ae.annotations);
    }, Ha = function(h) {
      var O = h.doc, Y = h.outlines, ee = h.page, J = h.pageIndex, ae = h.plugins, se = h.rotation, he = h.scale, ne = h.onExecuteNamedAction, Se = h.onJumpFromLinkAnnotation, Fe = h.onJumpToDest, ze = function(Ue) {
        return t.createElement(Ur, { annotations: Ue, doc: O, outlines: Y, page: ee, pageIndex: J, plugins: ae, rotation: se, scale: he, onExecuteNamedAction: ne, onJumpFromLinkAnnotation: Se, onJumpToDest: Fe });
      };
      return t.createElement(Va, { page: ee, renderAnnotations: ze });
    }, sa = function(h, O) {
      var Y, ee;
      if (Math.floor(h) === h)
        return [h, 1];
      var J = 1 / h;
      if (J > O)
        return [1, O];
      if (Math.floor(J) === J)
        return [1, J];
      for (var ae = h > 1 ? J : h, se = 0, he = 1, ne = 1, Se = 1; ; ) {
        var Fe = se + ne, ze = he + Se;
        if (ze > O)
          break;
        ae <= Fe / ze ? (Y = [Fe, ze], ne = Y[0], Se = Y[1]) : (ee = [Fe, ze], se = ee[0], he = ee[1]);
      }
      var Ue = (se / he + ne / Se) / 2;
      return ae < Ue ? ae === h ? [se, he] : [he, se] : ae === h ? [ne, Se] : [Se, ne];
    }, Ar = function(h, O) {
      var Y = h % O;
      return Y === 0 ? h : Math.floor(h - Y);
    }, qa = 4096 * 4096, Wa = function(h) {
      var O = h.canvasLayerRef, Y = h.height, ee = h.page, J = h.pageIndex, ae = h.plugins, se = h.rotation, he = h.scale, ne = h.width, Se = h.onRenderCanvasCompleted, Fe = t.useRef();
      return P(function() {
        var ze = Fe.current;
        ze && ze.cancel();
        var Ue = O.current;
        Ue.removeAttribute("data-testid"), ae.forEach(function(Ht) {
          Ht.onCanvasLayerRender && Ht.onCanvasLayerRender({
            ele: Ue,
            pageIndex: J,
            rotation: se,
            scale: he,
            status: e.LayerRenderStatus.PreRender
          });
        });
        var ot = ee.getViewport({
          rotation: se,
          scale: he
        }), Ze = window.devicePixelRatio || 1, gt = Math.sqrt(qa / (ot.width * ot.height)), et = Ze > gt;
        et ? Ue.style.transform = "scale(1, 1)" : Ue.style.removeProperty("transform");
        var It = Math.min(gt, Ze), Rt = sa(It, 8), wt = Rt[0], En = Rt[1];
        Ue.width = Ar(ot.width * It, wt), Ue.height = Ar(ot.height * It, wt), Ue.style.width = "".concat(Ar(ot.width, En), "px"), Ue.style.height = "".concat(Ar(ot.height, En), "px"), Ue.hidden = !0;
        var Zt = Ue.getContext("2d", { alpha: !1 }), Bt = et || Ze !== 1 ? [It, 0, 0, It, 0, 0] : null;
        return Fe.current = ee.render({ canvasContext: Zt, transform: Bt, viewport: ot }), Fe.current.promise.then(function() {
          Ue.hidden = !1, Ue.setAttribute("data-testid", "core__canvas-layer-".concat(J)), ae.forEach(function(Ht) {
            Ht.onCanvasLayerRender && Ht.onCanvasLayerRender({
              ele: Ue,
              pageIndex: J,
              rotation: se,
              scale: he,
              status: e.LayerRenderStatus.DidRender
            });
          }), Se();
        }, function() {
          Se();
        }), function() {
          Ue && (Ue.width = 0, Ue.height = 0);
        };
      }, []), t.createElement(
        "div",
        { className: "rpv-core__canvas-layer", style: {
          height: "".concat(Y, "px"),
          width: "".concat(ne, "px")
        } },
        t.createElement("canvas", { ref: O })
      );
    }, $r = function(h) {
      var O = h.height, Y = h.page, ee = h.rotation, J = h.scale, ae = h.width, se = t.useRef(), he = function() {
        var ne = se.current;
        ne && (ne.innerHTML = "");
      };
      return P(function() {
        var ne = se.current, Se = Y.getViewport({ rotation: ee, scale: J });
        Y.getOperatorList().then(function(Fe) {
          he();
          var ze = new l.SVGGraphics(Y.commonObjs, Y.objs);
          ze.getSVG(Fe, Se).then(function(Ue) {
            Ue.style.height = "".concat(O, "px"), Ue.style.width = "".concat(ae, "px"), ne.appendChild(Ue);
          });
        });
      }, []), t.createElement("div", { className: "rpv-core__svg-layer", ref: se });
    }, Ua = function(h) {
      var O = h.containerRef, Y = h.page, ee = h.pageIndex, J = h.plugins, ae = h.rotation, se = h.scale, he = h.onRenderTextCompleted, ne = t.useRef(), Se = function() {
        var Fe = O.current;
        if (Fe) {
          var ze = [].slice.call(Fe.querySelectorAll(".rpv-core__text-layer-text"));
          ze.forEach(function(ot) {
            return Fe.removeChild(ot);
          });
          var Ue = [].slice.call(Fe.querySelectorAll('br[role="presentation"]'));
          Ue.forEach(function(ot) {
            return Fe.removeChild(ot);
          });
        }
      };
      return P(function() {
        var Fe = ne.current;
        Fe && Fe.cancel();
        var ze = O.current;
        if (ze) {
          ze.removeAttribute("data-testid");
          var Ue = Y.getViewport({ rotation: ae, scale: se });
          return J.forEach(function(ot) {
            ot.onTextLayerRender && ot.onTextLayerRender({
              ele: ze,
              pageIndex: ee,
              scale: se,
              status: e.LayerRenderStatus.PreRender
            });
          }), Y.getTextContent().then(function(ot) {
            Se(), ne.current = l.renderTextLayer({
              container: ze,
              textContent: ot,
              textContentSource: ot,
              viewport: Ue
            }), ne.current.promise.then(function() {
              ze.setAttribute("data-testid", "core__text-layer-".concat(ee));
              var Ze = [].slice.call(ze.children);
              Ze.forEach(function(gt) {
                gt.classList.contains("rpv-core__text-layer-text--not") || gt.classList.add("rpv-core__text-layer-text");
              }), J.forEach(function(gt) {
                gt.onTextLayerRender && gt.onTextLayerRender({
                  ele: ze,
                  pageIndex: ee,
                  scale: se,
                  status: e.LayerRenderStatus.DidRender
                });
              }), he();
            }, function() {
              ze.removeAttribute("data-testid"), he();
            });
          }), function() {
            var ot;
            Se(), (ot = ne.current) === null || ot === void 0 || ot.cancel();
          };
        }
      }, []), t.createElement("div", { className: "rpv-core__text-layer", ref: O });
    }, ca = function(h) {
      var O = h.doc, Y = h.measureRef, ee = h.outlines, J = h.pageIndex, ae = h.pageRotation, se = h.pageSize, he = h.plugins, ne = h.renderPage, Se = h.renderQueueKey, Fe = h.rotation, ze = h.scale, Ue = h.shouldRender, ot = h.viewMode, Ze = h.onExecuteNamedAction, gt = h.onJumpFromLinkAnnotation, et = h.onJumpToDest, It = h.onRenderCompleted, Rt = h.onRotatePage, wt = F(), En = t.useState(null), Zt = En[0], Bt = En[1], Ht = t.useState(!1), An = Ht[0], $n = Ht[1], Dn = t.useState(!1), Jn = Dn[0], Vn = Dn[1], ar = t.useRef(), On = t.useRef(), Sr = Math.abs(Fe + ae) % 180 === 0, ir = se.pageWidth * ze, Yn = se.pageHeight * ze, Zn = Sr ? ir : Yn, Gn = Sr ? Yn : ir, nr = (se.rotation + Fe + ae) % 360, rr = t.useRef(0), _r = function() {
        He(O, J).then(function(cn) {
          wt.current && (rr.current = Se, Bt(cn));
        });
      }, wr = function(cn) {
        return t.createElement(
          t.Fragment,
          null,
          cn.canvasLayer.children,
          cn.textLayer.children,
          cn.annotationLayer.children
        );
      }, pr = ne || wr, gr = function() {
        wt.current && $n(!0);
      }, tn = function() {
        wt.current && Vn(!0);
      };
      return t.useEffect(function() {
        Bt(null), $n(!1), Vn(!1);
      }, [ae, Fe, ze]), t.useEffect(function() {
        Ue && wt.current && !Zt && _r();
      }, [Ue, Zt]), t.useEffect(function() {
        An && Jn && (Se !== rr.current ? (Bt(null), $n(!1), Vn(!1)) : It(J));
      }, [An, Jn]), t.createElement("div", { className: H({
        "rpv-core__page-layer": !0,
        "rpv-core__page-layer--dual": ot === e.ViewMode.DualPage,
        "rpv-core__page-layer--dual-cover": ot === e.ViewMode.DualPageWithCover,
        "rpv-core__page-layer--single": ot === e.ViewMode.SinglePage
      }), "data-testid": "core__page-layer-".concat(J), ref: Y, style: {
        height: "".concat(Gn, "px"),
        width: "".concat(Zn, "px")
      } }, Zt ? t.createElement(
        t.Fragment,
        null,
        pr({
          annotationLayer: {
            attrs: {},
            children: t.createElement(Ha, { doc: O, outlines: ee, page: Zt, pageIndex: J, plugins: he, rotation: nr, scale: ze, onExecuteNamedAction: Ze, onJumpFromLinkAnnotation: gt, onJumpToDest: et })
          },
          canvasLayer: {
            attrs: {},
            children: t.createElement(Wa, { canvasLayerRef: ar, height: Gn, page: Zt, pageIndex: J, plugins: he, rotation: nr, scale: ze, width: Zn, onRenderCanvasCompleted: gr })
          },
          canvasLayerRendered: An,
          doc: O,
          height: Gn,
          pageIndex: J,
          rotation: nr,
          scale: ze,
          svgLayer: {
            attrs: {},
            children: t.createElement($r, { height: Gn, page: Zt, rotation: nr, scale: ze, width: Zn })
          },
          textLayer: {
            attrs: {},
            children: t.createElement(Ua, { containerRef: On, page: Zt, pageIndex: J, plugins: he, rotation: nr, scale: ze, onRenderTextCompleted: tn })
          },
          textLayerRendered: Jn,
          width: Zn,
          markRendered: It,
          onRotatePage: function(cn) {
            return Rt(J, cn);
          }
        }),
        he.map(function(cn, yn) {
          return cn.renderPageLayer ? t.createElement(t.Fragment, { key: yn }, cn.renderPageLayer({
            canvasLayerRef: ar,
            canvasLayerRendered: An,
            doc: O,
            height: Gn,
            pageIndex: J,
            rotation: nr,
            scale: ze,
            textLayerRef: On,
            textLayerRendered: Jn,
            width: Zn
          })) : t.createElement(t.Fragment, { key: yn });
        })
      ) : t.createElement(v, { testId: "core__page-layer-loading-".concat(J) }));
    }, la = function(h) {
      var O = h.split(/\./).pop();
      return O ? O.toLowerCase() : "";
    }, $a = function(h, O) {
      var Y = O.rect;
      return h.height !== Y.height || h.width !== Y.width ? Y : h;
    }, Gr = function(h) {
      var O = h.elementRef, Y = t.useState(O.current), ee = Y[0], J = Y[1], ae = t.useRef(!1), se = t.useReducer($a, { height: 0, width: 0 }), he = se[0], ne = se[1];
      return P(function() {
        O.current !== ee && J(O.current);
      }), P(function() {
        if (ee && !ae.current) {
          ae.current = !0;
          var Se = ee.getBoundingClientRect(), Fe = Se.height, ze = Se.width;
          ne({
            rect: { height: Fe, width: ze }
          });
        }
      }, [ee]), t.useEffect(function() {
        if (ee) {
          var Se = new ResizeObserver(function(Fe, ze) {
            Fe.forEach(function(Ue) {
              if (Ue.target === ee) {
                var ot = Ue.contentRect, Ze = ot.height, gt = ot.width;
                ne({
                  rect: { height: Ze, width: gt }
                });
              }
            });
          });
          return Se.observe(ee), function() {
            Se.unobserve(ee);
          };
        }
      }, [ee]), he;
    }, Sn;
    (function(h) {
      h.Horizontal = "Horizontal", h.Vertical = "Vertical", h.Both = "Both";
    })(Sn || (Sn = {}));
    var Ga = function(h) {
      return 1 - Math.pow(1 - h, 4);
    }, br = 1e-4, Ka = function(h, O, Y, ee, J, ae) {
      J === void 0 && (J = function(Ze) {
        return Ze;
      }), ae === void 0 && (ae = function() {
      });
      var se = 0, he = 0, ne = !1;
      switch (O) {
        case Sn.Horizontal:
          he = h.scrollLeft, se = 0;
        case Sn.Both:
          he = h.scrollLeft, se = h.scrollTop;
          break;
        case Sn.Vertical:
        default:
          he = 0, se = h.scrollTop;
          break;
      }
      var Se = function() {
        ne || (ne = !0, h.scrollLeft = Y.left, h.scrollTop = Y.top, ae());
      };
      if (Math.abs(se - Y.top) <= br && O === Sn.Vertical) {
        Se();
        return;
      }
      if (Math.abs(he - Y.left) <= br && O === Sn.Horizontal) {
        Se();
        return;
      }
      var Fe = -1, ze, Ue = {
        left: he - Y.left,
        top: se - Y.top
      }, ot = function(Ze) {
        Fe === -1 && (Fe = Ze);
        var gt = Ze - Fe, et = Math.min(gt / ee, 1), It = J(et), Rt = {
          left: he - Ue.left * It,
          top: se - Ue.top * It
        };
        switch (O) {
          case Sn.Horizontal:
            h.scrollLeft = Rt.left;
            break;
          case Sn.Both:
            h.scrollLeft = Rt.left, h.scrollTop = Rt.top;
            break;
          case Sn.Vertical:
          default:
            h.scrollTop = Rt.top;
            break;
        }
        Math.abs(Rt.top - Y.top) <= br && Math.abs(Rt.left - Y.left) <= br && !ne && (window.cancelAnimationFrame(ze), Se()), gt < ee ? ze = window.requestAnimationFrame(ot) : window.cancelAnimationFrame(ze);
      };
      ze = window.requestAnimationFrame(ot);
    }, Kr = {
      left: 0,
      top: 0
    }, ua = {
      capture: !1,
      passive: !0
    }, Nr = 400, Xr = function(h) {
      var O = h.elementRef, Y = h.enableSmoothScroll, ee = h.isRtl, J = h.scrollDirection, ae = h.onSmoothScroll, se = t.useState(Kr), he = se[0], ne = se[1], Se = t.useState(O.current), Fe = Se[0], ze = Se[1], Ue = ee ? -1 : 1, ot = t.useRef(J);
      ot.current = J;
      var Ze = t.useRef(Kr), gt = t.useRef(!0), et = t.useCallback(function() {
        gt.current = !0, Y && ne(Ze.current), ae(!1);
      }, []), It = t.useCallback(function() {
        if (Fe) {
          switch (ot.current) {
            case Sn.Horizontal:
              Ze.current = {
                left: Ue * Fe.scrollLeft,
                top: 0
              };
              break;
            case Sn.Both:
              Ze.current = {
                left: Ue * Fe.scrollLeft,
                top: Fe.scrollTop
              };
              break;
            case Sn.Vertical:
            default:
              Ze.current = {
                left: 0,
                top: Fe.scrollTop
              };
              break;
          }
          (!Y || gt.current) && ne(Ze.current);
        }
      }, [Fe]);
      P(function() {
        ze(O.current);
      }), P(function() {
        if (Fe)
          return Fe.addEventListener("scroll", It, ua), function() {
            Fe.removeEventListener("scroll", It, ua);
          };
      }, [Fe]);
      var Rt = t.useCallback(function(wt, En) {
        var Zt = O.current;
        if (!Zt)
          return Promise.resolve();
        var Bt = {
          left: 0,
          top: 0
        };
        switch (ot.current) {
          case Sn.Horizontal:
            Bt.left = Ue * wt.left;
            break;
          case Sn.Both:
            Bt.left = Ue * wt.left, Bt.top = wt.top;
            break;
          case Sn.Vertical:
          default:
            Bt.top = wt.top;
            break;
        }
        return En ? (gt.current = !1, ae(!0), new Promise(function(Ht, An) {
          Ka(Zt, ot.current, Bt, Nr, Ga, function() {
            et(), Ht();
          });
        })) : new Promise(function(Ht, An) {
          switch (ot.current) {
            case Sn.Horizontal:
              Zt.scrollLeft = Bt.left;
              break;
            case Sn.Both:
              Zt.scrollLeft = Bt.left, Zt.scrollTop = Bt.top;
              break;
            case Sn.Vertical:
            default:
              Zt.scrollTop = Bt.top;
              break;
          }
          Ht();
        });
      }, [O]);
      return {
        scrollOffset: he,
        scrollTo: Rt
      };
    }, xr = function(h, O, Y) {
      return Math.max(h, Math.min(Y, O));
    }, da = function(h) {
      return h.reduce(function(O, Y, ee, J) {
        return Y > J[O] ? ee : O;
      }, 0);
    }, ha = function(h, O) {
      switch (O) {
        case e.ScrollMode.Horizontal:
          return {
            position: "relative",
            height: "100%",
            width: "".concat(h.width, "px")
          };
        case e.ScrollMode.Vertical:
        default:
          return {
            position: "relative",
            height: "".concat(h.height, "px"),
            width: "100%"
          };
      }
    }, Yr = function(h, O, Y) {
      return Y !== e.ScrollMode.Page ? {} : {
        height: "".concat(O.height, "px"),
        width: "100%",
        position: "absolute",
        top: 0,
        transform: "translateY(".concat(h.start.top, "px)")
      };
    }, Xa = function(h) {
      var O = h.length;
      if (O === 1)
        return !1;
      for (var Y = 1; Y < O; Y++)
        if (h[Y].height !== h[0].height || h[Y].width !== h[0].width)
          return !0;
      return !1;
    }, Ya = function(h, O) {
      if (O !== e.ViewMode.DualPageWithCover)
        return 0;
      if (!Xa(h))
        return 2 * h[0].width;
      var Y = ct(h.slice(1), 2).map(function(J) {
        return J.length === 2 ? J[0].width + J[1].width : J[0].width;
      }), ee = [h[0].width].concat(Y);
      return Math.max.apply(Math, ee);
    }, Za = function(h, O, Y, ee, J) {
      var ae, se, he, ne, Se, Fe, ze, Ue = O ? "right" : "left", ot = O ? -1 : 1, Ze = Y.length, gt = h.start.left * ot, et = h.size, It = et.height, Rt = et.width;
      if (ee === e.ViewMode.DualPageWithCover) {
        var wt = J === e.ScrollMode.Page ? 0 : h.start.top;
        return h.index === 0 || Ze % 2 === 0 && h.index === Ze - 1 ? (ae = {
          height: "".concat(It, "px"),
          minWidth: "".concat(Ya(Y, ee), "px"),
          width: "100%"
        }, ae[Ue] = 0, ae.position = "absolute", ae.top = 0, ae.transform = "translate(".concat(gt, "px, ").concat(wt, "px)"), ae) : (se = {
          height: "".concat(It, "px"),
          width: "".concat(Rt, "px")
        }, se[Ue] = 0, se.position = "absolute", se.top = 0, se.transform = "translate(".concat(gt, "px, ").concat(wt, "px)"), se);
      }
      if (ee === e.ViewMode.DualPage)
        return he = {
          height: "".concat(It, "px"),
          width: "".concat(Rt, "px")
        }, he[Ue] = 0, he.position = "absolute", he.top = 0, he.transform = "translate(".concat(gt, "px, ").concat(J === e.ScrollMode.Page ? 0 : h.start.top, "px)"), he;
      switch (J) {
        case e.ScrollMode.Horizontal:
          return ne = {
            height: "100%",
            width: "".concat(Rt, "px")
          }, ne[Ue] = 0, ne.position = "absolute", ne.top = 0, ne.transform = "translateX(".concat(gt, "px)"), ne;
        case e.ScrollMode.Page:
          return Se = {
            height: "".concat(It, "px"),
            width: "".concat(Rt, "px")
          }, Se[Ue] = 0, Se.position = "absolute", Se.top = 0, Se;
        case e.ScrollMode.Wrapped:
          return Fe = {
            height: "".concat(It, "px"),
            width: "".concat(Rt, "px")
          }, Fe[Ue] = 0, Fe.position = "absolute", Fe.top = 0, Fe.transform = "translate(".concat(gt, "px, ").concat(h.start.top, "px)"), Fe;
        case e.ScrollMode.Vertical:
        default:
          return ze = {
            height: "".concat(It, "px"),
            width: "100%"
          }, ze[Ue] = 0, ze.position = "absolute", ze.top = 0, ze.transform = "translateY(".concat(h.start.top, "px)"), ze;
      }
    }, z = function(h, O, Y, ee) {
      for (; h <= O; ) {
        var J = (h + O) / 2 | 0, ae = ee(J);
        if (ae < Y)
          h = J + 1;
        else if (ae > Y)
          O = J - 1;
        else
          return J;
      }
      return h > 0 ? h - 1 : 0;
    }, K = function(h, O, Y, ee) {
      var J = 0;
      switch (h) {
        case Sn.Horizontal:
          J = ee.left;
          break;
        case Sn.Vertical:
        default:
          J = ee.top;
          break;
      }
      var ae = O.length - 1, se = function(Ue) {
        switch (h) {
          case Sn.Horizontal:
            return O[Ue].start.left;
          case Sn.Both:
          case Sn.Vertical:
          default:
            return O[Ue].start.top;
        }
      }, he = z(0, ae, J, se);
      if (h === Sn.Both)
        for (var ne = O[he].start.top; he - 1 >= 0 && O[he - 1].start.top === ne && O[he - 1].start.left >= ee.left; )
          he--;
      for (var Se = he; Se <= ae; ) {
        var Fe = {
          top: O[Se].start.top - ee.top,
          left: O[Se].start.left - ee.left
        }, ze = {
          height: Y.height - Fe.top,
          width: Y.width - Fe.left
        };
        if (h === Sn.Horizontal && ze.width < 0 || h === Sn.Vertical && ze.height < 0 || h === Sn.Both && (ze.width < 0 || ze.height < 0))
          break;
        Se++;
      }
      return {
        start: he,
        end: Se
      };
    }, ue = {
      left: 0,
      top: 0
    }, ve = function(h, O, Y, ee) {
      for (var J = [], ae = 0, se = {
        left: 0,
        top: 0
      }, he = 0, ne = ue, Se = 0; Se < h; Se++) {
        var Fe = Y[Se];
        if (Se === 0)
          ae = Fe.width, se = {
            left: 0,
            top: 0
          }, he = Fe.height;
        else
          switch (ee) {
            case e.ScrollMode.Wrapped:
              ae += Fe.width, ae < O.width ? (ne = {
                left: J[Se - 1].end.left,
                top: se.top
              }, he = Math.max(he, Fe.height)) : (ae = Fe.width, ne = {
                left: se.left,
                top: se.top + he
              }, se = {
                left: ne.left,
                top: ne.top
              }, he = Fe.height);
              break;
            case e.ScrollMode.Horizontal:
            case e.ScrollMode.Vertical:
            default:
              ne = J[Se - 1].end;
              break;
          }
        var ze = {
          left: ne.left + Fe.width,
          top: ne.top + Fe.height
        };
        J[Se] = {
          index: Se,
          start: ne,
          size: Fe,
          end: ze,
          visibility: -1
        };
      }
      return J;
    }, Pe = {
      left: 0,
      top: 0
    }, Me = function(h, O, Y, ee) {
      for (var J = [], ae = 0, se = 0, he = Pe, ne = 0; ne < h; ne++) {
        var Se = {
          height: ee === e.ScrollMode.Page ? Math.max(O.height, Y[ne].height) : Y[ne].height,
          width: Math.max(O.width / 2, Y[ne].width)
        };
        ee === e.ScrollMode.Page ? he = {
          left: ne % 2 === 0 ? 0 : Se.width,
          top: Math.floor(ne / 2) * Se.height
        } : ne % 2 === 0 ? (ae = ae + se, he = {
          left: 0,
          top: ae
        }, se = ne === h - 1 ? Y[ne].height : Math.max(Y[ne].height, Y[ne + 1].height)) : he = {
          left: J[ne - 1].end.left,
          top: ae
        };
        var Fe = {
          left: he.left + Se.width,
          top: he.top + Se.height
        };
        J[ne] = {
          index: ne,
          start: he,
          size: Se,
          end: Fe,
          visibility: -1
        };
      }
      return J;
    }, Oe = {
      left: 0,
      top: 0
    }, xe = function(h, O, Y, ee) {
      for (var J = [], ae = 0, se = 0, he = Oe, ne = 0; ne < h; ne++) {
        var Se = ne === 0 ? {
          height: ee === e.ScrollMode.Page ? Math.max(O.height, Y[ne].height) : Y[ne].height,
          width: ee === e.ScrollMode.Page ? Math.max(O.width, Y[ne].width) : Y[ne].width
        } : {
          height: ee === e.ScrollMode.Page ? Math.max(O.height, Y[ne].height) : Y[ne].height,
          width: Math.max(O.width / 2, Y[ne].width)
        };
        ee === e.ScrollMode.Page ? he = ne === 0 ? Oe : {
          left: ne % 2 === 0 ? Se.width : 0,
          top: Math.floor((ne - 1) / 2) * Se.height + J[0].end.top
        } : ne === 0 ? (he = Oe, ae = Y[0].height, se = 0) : ne % 2 === 1 ? (ae = ae + se, he = {
          left: 0,
          top: ae
        }, se = ne === h - 1 ? Y[ne].height : Math.max(Y[ne].height, Y[ne + 1].height)) : he = {
          left: J[ne - 1].end.left,
          top: ae
        };
        var Fe = {
          left: he.left + Se.width,
          top: he.top + Se.height
        };
        J[ne] = {
          index: ne,
          start: he,
          size: Se,
          end: Fe,
          visibility: -1
        };
      }
      return J;
    }, Ee = {
      left: 0,
      top: 0
    }, Ie = function(h, O, Y) {
      for (var ee = [], J = 0; J < h; J++) {
        var ae = {
          height: Math.max(O.height, Y[J].height),
          width: Math.max(O.width, Y[J].width)
        }, se = J === 0 ? Ee : ee[J - 1].end, he = {
          left: se.left + ae.width,
          top: se.top + ae.height
        };
        ee[J] = {
          index: J,
          start: se,
          size: ae,
          end: he,
          visibility: -1
        };
      }
      return ee;
    }, Le = {
      height: 0,
      width: 0
    }, rt = {
      left: 0,
      top: 0
    }, nt = 1e-12, Qe = "data-virtual-index", vt = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1], ft = function(h) {
      var O = h.enableSmoothScroll, Y = h.isRtl, ee = h.numberOfItems, J = h.parentRef, ae = h.setRenderRange, se = h.sizes, he = h.scrollMode, ne = h.viewMode, Se = t.useState(!1), Fe = Se[0], ze = Se[1], Ue = t.useCallback(function(tn) {
        return ze(tn);
      }, []), ot = t.useRef(he);
      ot.current = he;
      var Ze = t.useRef(ne);
      Ze.current = ne;
      var gt = he === e.ScrollMode.Wrapped || ne === e.ViewMode.DualPageWithCover || ne === e.ViewMode.DualPage ? Sn.Both : he === e.ScrollMode.Horizontal ? Sn.Horizontal : Sn.Vertical, et = Xr({
        elementRef: J,
        enableSmoothScroll: O,
        isRtl: Y,
        scrollDirection: gt,
        onSmoothScroll: Ue
      }), It = et.scrollOffset, Rt = et.scrollTo, wt = Gr({
        elementRef: J
      }), En = t.useRef({
        scrollOffset: rt,
        measurements: []
      });
      En.current.scrollOffset = It;
      var Zt = t.useMemo(function() {
        return Array(ee).fill(-1);
      }, []), Bt = t.useState(Zt), Ht = Bt[0], An = Bt[1], $n = t.useMemo(function() {
        var tn = new IntersectionObserver(function(cn) {
          cn.forEach(function(yn) {
            var dn = yn.isIntersecting ? yn.intersectionRatio : -1, nn = yn.target, wn = nn.getAttribute(Qe);
            if (wn) {
              var kn = parseInt(wn, 10);
              0 <= kn && kn < ee && An(function(Ke) {
                return Ke[kn] = dn, X([], Ke);
              });
            }
          });
        }, {
          threshold: vt
        });
        return tn;
      }, []), Dn = t.useMemo(function() {
        return he === e.ScrollMode.Page && ne === e.ViewMode.SinglePage ? Ie(ee, wt, se) : ne === e.ViewMode.DualPageWithCover ? xe(ee, wt, se, he) : ne === e.ViewMode.DualPage ? Me(ee, wt, se, he) : ve(ee, wt, se, he);
      }, [he, se, ne, wt]), Jn = Dn[ee - 1] ? {
        height: Dn[ee - 1].end.top,
        width: Dn[ee - 1].end.left
      } : Le;
      En.current.measurements = Dn;
      var Vn = t.useMemo(function() {
        var tn = K(gt, Dn, wt, It), cn = tn.start, yn = tn.end, dn = Ht.slice(xr(0, ee, cn), xr(0, ee, yn)), nn = cn + da(dn);
        nn = xr(0, ee - 1, nn);
        var wn = nn, kn = ae({
          endPage: yn,
          numPages: ee,
          startPage: cn
        }), Ke = kn.startPage, Ot = kn.endPage;
        switch (Ke = Math.max(Ke, 0), Ot = Math.min(Ot, ee - 1), ne) {
          case e.ViewMode.DualPageWithCover:
            nn > 0 && (wn = nn % 2 === 1 ? nn : nn - 1), Ke = Ke === 0 ? 0 : Ke % 2 === 1 ? Ke : Ke - 1, Ot = Ot % 2 === 1 ? Ot - 1 : Ot, ee - Ot <= 2 && (Ot = ee - 1);
            break;
          case e.ViewMode.DualPage:
            wn = nn % 2 === 0 ? nn : nn - 1, Ke = Ke % 2 === 0 ? Ke : Ke - 1, Ot = Ot % 2 === 1 ? Ot : Ot - 1;
            break;
          case e.ViewMode.SinglePage:
          default:
            wn = nn;
            break;
        }
        return {
          startPage: Ke,
          endPage: Ot,
          maxVisbilityIndex: wn
        };
      }, [Dn, wt, It, ne, Ht]), ar = Vn.startPage, On = Vn.endPage, Sr = Vn.maxVisbilityIndex, ir = t.useMemo(function() {
        for (var tn = [], cn = function(dn) {
          var nn = Dn[dn], wn = G(G({}, nn), { visibility: Ht[dn] !== void 0 ? Ht[dn] : -1, measureRef: function(kn) {
            kn && (kn.setAttribute(Qe, "".concat(dn)), $n.observe(kn));
          } });
          tn.push(wn);
        }, yn = ar; yn <= On; yn++)
          cn(yn);
        return tn;
      }, [ar, On, Ht, Dn]), Yn = t.useCallback(function(tn, cn) {
        var yn = En.current.measurements, dn = xr(0, ee - 1, tn), nn = yn[dn], wn = ot.current === e.ScrollMode.Page ? rt : cn;
        return nn ? Rt({
          left: wn.left + nn.start.left,
          top: wn.top + nn.start.top
        }, O) : Promise.resolve();
      }, [Rt, O]), Zn = t.useCallback(function(tn, cn) {
        var yn = En.current.measurements, dn = yn[tn].start, nn = yn.find(function(kn) {
          return kn.start.top - dn.top > nt;
        });
        if (!nn)
          return Promise.resolve();
        var wn = nn.index;
        switch (Ze.current) {
          case e.ViewMode.DualPage:
            wn = wn % 2 === 0 ? wn : wn + 1;
            break;
          case e.ViewMode.DualPageWithCover:
            wn = wn % 2 === 1 ? wn : wn + 1;
            break;
        }
        return Yn(wn, cn);
      }, []), Gn = t.useCallback(function(tn, cn) {
        for (var yn = En.current.measurements, dn = yn[tn].start, nn = tn, wn = !1, kn = ee - 1; kn >= 0; kn--)
          if (dn.top - yn[kn].start.top > nt) {
            wn = !0, nn = yn[kn].index;
            break;
          }
        if (!wn)
          return Promise.resolve();
        switch (Ze.current) {
          case e.ViewMode.DualPage:
            nn = nn % 2 === 0 ? nn : nn - 1;
            break;
          case e.ViewMode.DualPageWithCover:
            nn = nn % 2 === 0 ? nn - 1 : nn;
            break;
        }
        return nn === tn && (nn = tn - 1), Yn(nn, cn);
      }, []), nr = t.useCallback(function(tn, cn) {
        if (Ze.current === e.ViewMode.DualPageWithCover || Ze.current === e.ViewMode.DualPage)
          return Zn(tn, cn);
        switch (ot.current) {
          case e.ScrollMode.Wrapped:
            return Zn(tn, cn);
          case e.ScrollMode.Horizontal:
          case e.ScrollMode.Vertical:
          default:
            return Yn(tn + 1, cn);
        }
      }, []), rr = t.useCallback(function(tn, cn) {
        if (Ze.current === e.ViewMode.DualPageWithCover || Ze.current === e.ViewMode.DualPage)
          return Gn(tn, cn);
        switch (ot.current) {
          case e.ScrollMode.Wrapped:
            return Gn(tn, cn);
          case e.ScrollMode.Horizontal:
          case e.ScrollMode.Vertical:
          default:
            return Yn(tn - 1, cn);
        }
      }, []), _r = t.useCallback(function() {
        return ha(Jn, ot.current);
      }, [Jn]), wr = t.useCallback(function(tn) {
        return Yr(tn, wt, ot.current);
      }, [wt]), pr = t.useCallback(function(tn) {
        return Za(tn, Y, se, Ze.current, ot.current);
      }, [Y, se]), gr = t.useCallback(function(tn, cn) {
        var yn = En.current, dn = yn.measurements, nn = yn.scrollOffset, wn = xr(0, ee - 1, cn), kn = dn[wn];
        if (kn) {
          var Ke = ot.current === e.ScrollMode.Page ? {
            left: kn.start.left,
            top: kn.start.top
          } : {
            left: nn.left * tn,
            top: nn.top * tn
          };
          return Rt(Ke, !1);
        }
        return Promise.resolve();
      }, []);
      return t.useEffect(function() {
        return function() {
          $n.disconnect();
        };
      }, []), {
        boundingClientRect: wt,
        isSmoothScrolling: Fe,
        startPage: ar,
        endPage: On,
        maxVisbilityIndex: Sr,
        virtualItems: ir,
        getContainerStyles: _r,
        getItemContainerStyles: wr,
        getItemStyles: pr,
        scrollToItem: Yn,
        scrollToNextItem: nr,
        scrollToPreviousItem: rr,
        zoom: gr
      };
    }, ut = 17, en = 8, Nt = function(h, O, Y, ee, J, ae) {
      var se = Y;
      switch (!0) {
        case (J === e.ViewMode.DualPageWithCover && ae >= 3):
        case (J === e.ViewMode.DualPage && ae >= 3):
          se = 2 * Y;
          break;
        default:
          se = Y;
          break;
      }
      switch (ee) {
        case e.SpecialZoomLevel.ActualSize:
          return 1;
        case e.SpecialZoomLevel.PageFit:
          return Math.min((h.clientWidth - ut) / se, (h.clientHeight - 2 * en) / O);
        case e.SpecialZoomLevel.PageWidth:
          return (h.clientWidth - ut) / se;
      }
    }, jt = function(h) {
      var O = t.useRef([]), Y = function(ae) {
        return O.current.map(function(se) {
          return ae(se);
        });
      }, ee = function() {
        var ae = O.current, se = ae.length;
        if (se === 0)
          return null;
        var he = ae.pop();
        return O.current = ae, he;
      }, J = function(ae) {
        var se = O.current;
        se.length + 1 > h && se.shift(), se.push(ae), O.current = se;
      };
      return t.useEffect(function() {
        return function() {
          O.current = [];
        };
      }, []), {
        push: J,
        map: Y,
        pop: ee
      };
    }, $t = function(h) {
      var O = t.useRef([]), Y = function() {
        var ae = O.current, se = ae.length;
        if (se === 0)
          return null;
        var he = ae.shift();
        return O.current = ae, he || null;
      }, ee = function(ae) {
        var se = O.current;
        se.length + 1 > h && se.pop(), O.current = [ae].concat(se);
      }, J = function(ae) {
        return O.current.map(function(se) {
          return ae(se);
        });
      };
      return t.useEffect(function() {
        return function() {
          O.current = [];
        };
      }, []), {
        dequeue: Y,
        enqueue: ee,
        map: J
      };
    }, Tt = 50, Gt = function(h) {
      var O = h.getCurrentPage, Y = jt(Tt), ee = $t(Tt), J = function() {
        var he = ee.dequeue();
        return he && Y.push(he), he && he.pageIndex === O() ? J() : he;
      }, ae = function() {
        var he = Y.pop();
        return he && ee.enqueue(he), he && he.pageIndex === O() ? ae() : he;
      }, se = t.useCallback(function(he) {
        Y.push(he);
      }, []);
      return {
        getNextDestination: J,
        getPreviousDestination: ae,
        markVisitedDestination: se
      };
    }, Wt = function(h) {
      var O = [];
      return h.items && h.items.length > 0 && (O = O.concat(fn(h.items))), O;
    }, fn = function(h) {
      var O = [];
      return h.map(function(Y) {
        O = O.concat(Y).concat(Wt(Y));
      }), O;
    }, un = function(h) {
      var O = F(), Y = t.useState([]), ee = Y[0], J = Y[1];
      return t.useEffect(function() {
        h.getOutline().then(function(ae) {
          if (O.current && ae !== null) {
            var se = fn(ae);
            J(se);
          }
        });
      }, []), ee;
    }, mn = {
      capture: !1,
      passive: !0
    }, vn = {
      height: 0,
      width: 0
    }, bn = function() {
      var h = t.useState(vn), O = h[0], Y = h[1], ee = _(function() {
        Y({
          height: window.innerHeight,
          width: window.innerWidth
        });
      }, 100);
      return P(function() {
        return window.addEventListener("resize", ee, mn), function() {
          window.removeEventListener("resize", ee, mn);
        };
      }, []), O;
    }, Ln = {
      height: 0,
      width: 0
    }, Mn = function(h) {
      var O = h.getCurrentPage, Y = h.getCurrentScrollMode, ee = h.jumpToPage, J = h.targetRef, ae = t.useState(e.FullScreenMode.Normal), se = ae[0], he = ae[1], ne = bn(), Se = t.useState(Ln), Fe = Se[0], ze = Se[1], Ue = t.useRef(Ln), ot = t.useRef(O()), Ze = t.useRef(Ln), gt = t.useState(J.current), et = gt[0], It = gt[1], Rt = t.useRef();
      P(function() {
        J.current !== et && It(J.current);
      }, []), P(function() {
        if (et) {
          var Ht = new ResizeObserver(function(An) {
            An.forEach(function($n) {
              var Dn = $n.target.getBoundingClientRect(), Jn = Dn.height, Vn = Dn.width;
              ze({ height: Jn, width: Vn });
            });
          });
          return Ht.observe(et), function() {
            Ht.unobserve(et), Ht.disconnect();
          };
        }
      }, [et]);
      var wt = t.useCallback(function(Ht) {
        var An = A();
        return An && An !== Ht ? (he(e.FullScreenMode.Normal), j(An)) : Promise.resolve();
      }, []), En = t.useCallback(function(Ht) {
        !Ht || !T() || (It(Ht), wt(Ht).then(function() {
          Rt.current = Ht, he(e.FullScreenMode.Entering), d(Ht);
        }));
      }, []), Zt = t.useCallback(function() {
        var Ht = A();
        Ht && (he(e.FullScreenMode.Exitting), j(document));
      }, []), Bt = t.useCallback(function() {
        if (et) {
          var Ht = A();
          Ht !== et && he(e.FullScreenMode.Exitting);
        }
      }, [et]);
      return t.useEffect(function() {
        switch (se) {
          case e.FullScreenMode.Entering:
            Rt.current && (Rt.current.style.backgroundColor = "var(--rpv-core__full-screen-target-background-color)"), ot.current = O(), Ue.current = {
              height: window.innerHeight,
              width: window.innerWidth
            };
            break;
          case e.FullScreenMode.Entered:
            Y() === e.ScrollMode.Page ? ee(ot.current).then(function() {
              he(e.FullScreenMode.EnteredCompletely);
            }) : he(e.FullScreenMode.EnteredCompletely);
            break;
          case e.FullScreenMode.Exitting:
            Rt.current && (Rt.current.style.backgroundColor = "", Rt.current = null), ot.current = O();
            break;
          case e.FullScreenMode.Exited:
            he(e.FullScreenMode.Normal), Y() === e.ScrollMode.Page && ee(ot.current);
            break;
        }
      }, [se]), t.useEffect(function() {
        if (se !== e.FullScreenMode.Normal) {
          if (se === e.FullScreenMode.Entering && ne.height === Fe.height && ne.width === Fe.width && ne.height > 0 && ne.width > 0 && (Ze.current.height === 0 || ne.height == Ze.current.height)) {
            Ze.current = {
              height: window.innerHeight,
              width: window.innerWidth
            }, he(e.FullScreenMode.Entered);
            return;
          }
          se === e.FullScreenMode.Exitting && Ue.current.height === ne.height && Ue.current.width === ne.width && ne.height > 0 && ne.width > 0 && he(e.FullScreenMode.Exited);
        }
      }, [se, ne, Fe]), t.useEffect(function() {
        return y(Bt), function() {
          D(Bt);
        };
      }, [et]), {
        enterFullScreenMode: En,
        exitFullScreenMode: Zt,
        fullScreenMode: se
      };
    }, Hn = {
      buildPageStyles: function() {
        return {};
      },
      transformSize: function(h) {
        var O = h.size;
        return O;
      }
    }, Cn = {
      left: 0,
      top: 0
    }, Bn = function(h) {
      var O = h.currentFile, Y = h.defaultScale, ee = h.doc, J = h.enableSmoothScroll, ae = h.initialPage, se = h.initialRotation, he = h.initialScale, ne = h.pageLayout, Se = h.pageSizes, Fe = h.plugins, ze = h.renderPage, Ue = h.scrollMode, ot = h.setRenderRange, Ze = h.viewMode, gt = h.viewerState, et = h.onDocumentLoad, It = h.onOpenFile, Rt = h.onPageChange, wt = h.onRotate, En = h.onRotatePage, Zt = h.onZoom, Bt = ee.numPages, Ht = ee.loadingTask.docId, An = t.useContext(fe).l10n, $n = t.useContext(N), Dn = $n.direction === e.TextDirection.RightToLeft, Jn = t.useRef(), Vn = t.useRef(), ar = t.useState(ae), On = ar[0], Sr = ar[1], ir = t.useRef(null), Yn = Gt({
        getCurrentPage: function() {
          return ln.current.pageIndex;
        }
      }), Zn = t.useState(se), Gn = Zn[0], nr = Zn[1], rr = U(Gn), _r = t.useState(!1), wr = _r[0], pr = _r[1], gr = t.useState(/* @__PURE__ */ new Map()), tn = gr[0], cn = gr[1], yn = t.useState(Ue), dn = yn[0], nn = yn[1], wn = U(dn), kn = t.useState(Ze), Ke = kn[0], Ot = kn[1], on = U(Ke), pn = un(ee), hn = t.useState(he), Jt = hn[0], zn = hn[1], or = U(Jt), ln = t.useRef(gt), sr = t.useRef(typeof Y == "string" ? Y : null), Qn = t.useRef(-1), er = t.useRef(-1), cr = t.useRef(ae), qn = Mn({
        getCurrentPage: function() {
          return ln.current.pageIndex;
        },
        getCurrentScrollMode: function() {
          return ln.current.scrollMode;
        },
        jumpToPage: function(ht) {
          return Mr(ht);
        },
        targetRef: Vn
      }), Pr = t.useState(-1), xo = Pr[0], Ni = Pr[1], Bi = t.useState(0), zi = Bi[0], Lo = Bi[1], dr = re({ doc: ee });
      t.useEffect(function() {
        return function() {
          oe();
        };
      }, [Ht]);
      var ji = t.useMemo(function() {
        return Object.assign({}, Hn, ne);
      }, []), Io = t.useMemo(function() {
        return Array(Bt).fill(0).map(function(ht, rn) {
          var _n = [Se[rn].pageHeight, Se[rn].pageWidth], Nn = Math.abs(Gn) % 180 === 0 ? {
            height: _n[0],
            width: _n[1]
          } : {
            height: _n[1],
            width: _n[0]
          }, Wn = {
            height: Nn.height * Jt,
            width: Nn.width * Jt
          };
          return ji.transformSize({ numPages: Bt, pageIndex: rn, size: Wn });
        });
      }, [Gn, Jt]), Rn = ft({
        enableSmoothScroll: J,
        isRtl: Dn,
        numberOfItems: Bt,
        parentRef: Vn,
        scrollMode: dn,
        setRenderRange: ot,
        sizes: Io,
        viewMode: Ke
      }), Fo = _(function() {
        !sr.current || ln.current.fullScreenMode !== e.FullScreenMode.Normal || ae > 0 && cr.current === ae || Lr(sr.current);
      }, 200);
      yt({
        targetRef: Vn,
        onResize: Fo
      });
      var kr = function(ht) {
        var rn = ht;
        Fe.forEach(function(_n) {
          _n.onViewerStateChange && (rn = _n.onViewerStateChange(rn));
        }), ln.current = rn;
      }, Do = function() {
        return Vn.current;
      }, Oo = function() {
        return ln.current;
      }, No = t.useCallback(function(ht) {
        Yn.markVisitedDestination(ht);
      }, []), Ja = t.useCallback(function(ht) {
        var rn = ht.pageIndex, _n = ht.bottomOffset, Nn = ht.leftOffset, Wn = ht.scaleTo, Pn = Vn.current, tr = ln.current;
        return !Pn || !tr ? Promise.resolve() : new Promise(function(yr, ti) {
          He(ee, rn).then(function(fa) {
            var Rr = fa.getViewport({ scale: 1 }), ma = 0, Ki = (typeof _n == "function" ? _n(Rr.width, Rr.height) : _n) || 0, Br = (typeof Nn == "function" ? Nn(Rr.width, Rr.height) : Nn) || 0, zr = tr.scale;
            switch (Wn) {
              case e.SpecialZoomLevel.PageFit:
                ma = 0, Br = 0, Lr(e.SpecialZoomLevel.PageFit);
                break;
              case e.SpecialZoomLevel.PageWidth:
                zr = Nt(Pn, Se[rn].pageHeight, Se[rn].pageWidth, e.SpecialZoomLevel.PageWidth, Ze, Bt), ma = (Rr.height - Ki) * zr, Br = Br * zr, Lr(zr);
                break;
              default:
                ma = (Rr.height - Ki) * zr, Br = Br * zr;
                break;
            }
            switch (tr.scrollMode) {
              case e.ScrollMode.Horizontal:
                Rn.scrollToItem(rn, { left: Br, top: 0 }).then(function() {
                  yr();
                });
                break;
              case e.ScrollMode.Vertical:
              default:
                Rn.scrollToItem(rn, { left: 0, top: ma }).then(function() {
                  yr();
                });
                break;
            }
          });
        });
      }, []), Vi = t.useCallback(function(ht) {
        return Yn.markVisitedDestination(ht), Ja(ht);
      }, []), Bo = t.useCallback(function() {
        var ht = Yn.getNextDestination();
        return ht ? Ja(ht) : Promise.resolve();
      }, []), zo = t.useCallback(function() {
        var ht = Yn.getPreviousDestination();
        return ht ? Ja(ht) : Promise.resolve();
      }, []), jo = t.useCallback(function() {
        return Rn.scrollToNextItem(ln.current.pageIndex, Cn);
      }, []), Mr = t.useCallback(function(ht) {
        return 0 <= ht && ht < Bt ? Rn.scrollToItem(ht, Cn) : Promise.resolve();
      }, []), Vo = t.useCallback(function() {
        return Rn.scrollToPreviousItem(ln.current.pageIndex, Cn);
      }, []), Hi = t.useCallback(function(ht) {
        la(ht.name).toLowerCase() === "pdf" && new Promise(function(rn) {
          var _n = new FileReader();
          _n.readAsArrayBuffer(ht), _n.onload = function() {
            var Nn = new Uint8Array(_n.result);
            rn(Nn);
          };
        }).then(function(rn) {
          It(ht.name, rn);
        });
      }, [It]), qi = t.useCallback(function(ht) {
        var rn = ht === e.RotateDirection.Backward ? -90 : 90, _n = ln.current.rotation, Nn = _n === 360 || _n === -360 ? rn : _n + rn;
        dr.markNotRendered(), nr(Nn), kr(G(G({}, ln.current), { rotation: Nn })), wt({ direction: ht, doc: ee, rotation: Nn });
      }, []), Qa = t.useCallback(function(ht, rn) {
        var _n = rn === e.RotateDirection.Backward ? -90 : 90, Nn = ln.current.pagesRotation, Wn = Nn.has(ht) ? Nn.get(ht) : se, Pn = Wn + _n, tr = Nn.set(ht, Pn);
        cn(tr), pr(function(yr) {
          return !yr;
        }), kr(G(G({}, ln.current), { pagesRotation: tr, rotatedPage: ht })), En({ direction: rn, doc: ee, pageIndex: ht, rotation: Pn }), dr.markRendering(ht), Ni(ht);
      }, []), Wi = t.useCallback(function(ht) {
        kr(G(G({}, ln.current), { scrollMode: ht })), nn(ht);
      }, []), Ui = t.useCallback(function(ht) {
        kr(G(G({}, ln.current), { viewMode: ht })), Ot(ht);
      }, []), Lr = t.useCallback(function(ht) {
        var rn = Vn.current, _n = ln.current.pageIndex;
        if (!(_n < 0 || _n >= Bt)) {
          var Nn = Se[_n].pageHeight, Wn = Se[_n].pageWidth, Pn = rn ? typeof ht == "string" ? Nt(rn, Nn, Wn, ht, ln.current.viewMode, Bt) : ht : 1;
          sr.current = typeof ht == "string" ? ht : null, Pn !== ln.current.scale && (Lo(function(tr) {
            return tr + 1;
          }), dr.markNotRendered(), zn(Pn), Zt({ doc: ee, scale: Pn }), kr(G(G({}, ln.current), { scale: Pn })));
        }
      }, []), Ho = t.useCallback(function(ht) {
        qn.enterFullScreenMode(ht);
      }, []), qo = t.useCallback(function() {
        qn.exitFullScreenMode();
      }, []);
      t.useEffect(function() {
        kr(G(G({}, ln.current), { fullScreenMode: qn.fullScreenMode }));
      }, [qn.fullScreenMode]), t.useEffect(function() {
        var ht = {
          enterFullScreenMode: Ho,
          exitFullScreenMode: qo,
          getPagesContainer: Do,
          getViewerState: Oo,
          jumpToDestination: Vi,
          jumpToNextDestination: Bo,
          jumpToPreviousDestination: zo,
          jumpToNextPage: jo,
          jumpToPreviousPage: Vo,
          jumpToPage: Mr,
          openFile: Hi,
          rotate: qi,
          rotatePage: Qa,
          setViewerState: kr,
          switchScrollMode: Wi,
          switchViewMode: Ui,
          zoom: Lr
        };
        return Fe.forEach(function(rn) {
          rn.install && rn.install(ht);
        }), function() {
          Fe.forEach(function(rn) {
            rn.uninstall && rn.uninstall(ht);
          });
        };
      }, [Ht]), t.useEffect(function() {
        et({ doc: ee, file: O }), Fe.forEach(function(ht) {
          ht.onDocumentLoad && ht.onDocumentLoad({ doc: ee, file: O });
        });
      }, [Ht]);
      var $i = Rn.boundingClientRect;
      St(function() {
        ae && Mr(ae);
      }, $i.height > 0 && $i.width > 0), P(function() {
        var ht = ln.current.pageIndex;
        ht > -1 && wn !== dn && Rn.scrollToItem(ht, Cn).then(function() {
          qn.fullScreenMode === e.FullScreenMode.EnteredCompletely && (J || dr.markNotRendered(), Qn.current = -1);
        });
      }, [dn]), P(function() {
        var ht = ln.current.pageIndex;
        ht > -1 && rr !== Gn && Rn.scrollToItem(ht, Cn);
      }, [Gn]), P(function() {
        or != 0 && or != ln.current.scale && Rn.zoom(ln.current.scale / or, ln.current.pageIndex).then(function() {
          qn.fullScreenMode === e.FullScreenMode.EnteredCompletely && (er.current = -1);
        });
      }, [Jt]), P(function() {
        if (on !== ln.current.viewMode) {
          var ht = Rn.startPage, rn = Rn.endPage, _n = Rn.virtualItems;
          dr.markNotRendered(), dr.setRange(ht, rn);
          for (var Nn = function(Pn) {
            var tr = _n.find(function(yr) {
              return yr.index === Pn;
            });
            tr && dr.setVisibility(Pn, tr.visibility);
          }, Wn = ht; Wn <= rn; Wn++)
            Nn(Wn);
          ei();
        }
      }, [Ke]), P(function() {
        var ht = ln.current.pageIndex;
        ht > -1 && on !== Ke && Rn.scrollToItem(ht, Cn);
      }, [Ke]), P(function() {
        var ht = ln.current.pageIndex;
        ht > 0 && ht === ae && cr.current === ae && sr.current && (cr.current = -1, Lr(sr.current));
      }, [On]), t.useEffect(function() {
        var ht = Rn.isSmoothScrolling;
        ht || (ir.current === null || ir.current !== On) && (ir.current = On, Rt({ currentPage: On, doc: ee }));
      }, [On, Rn.isSmoothScrolling]), t.useEffect(function() {
        qn.fullScreenMode === e.FullScreenMode.Entering && ln.current.scrollMode === e.ScrollMode.Page && (Qn.current = ln.current.pageIndex), qn.fullScreenMode === e.FullScreenMode.EnteredCompletely && ln.current.scrollMode === e.ScrollMode.Page && J && (Qn.current = -1), qn.fullScreenMode === e.FullScreenMode.EnteredCompletely && sr.current && (er.current = ln.current.pageIndex, Lr(sr.current));
      }, [qn.fullScreenMode]), t.useEffect(function() {
        if (!(qn.fullScreenMode === e.FullScreenMode.Entering || qn.fullScreenMode === e.FullScreenMode.Exitting || Rn.isSmoothScrolling)) {
          var ht = Rn.startPage, rn = Rn.endPage, _n = Rn.maxVisbilityIndex, Nn = Rn.virtualItems, Wn = _n, Pn = qn.fullScreenMode === e.FullScreenMode.Entered || qn.fullScreenMode === e.FullScreenMode.EnteredCompletely;
          if (!(Pn && Wn !== Qn.current && Qn.current > -1) && !(Pn && Wn !== er.current && er.current > -1)) {
            Sr(Wn), kr(G(G({}, ln.current), { pageIndex: Wn })), dr.setRange(ht, rn);
            for (var tr = function(ti) {
              var fa = Nn.find(function(Rr) {
                return Rr.index === ti;
              });
              fa && dr.setVisibility(ti, fa.visibility);
            }, yr = ht; yr <= rn; yr++)
              tr(yr);
            ei();
          }
        }
      }, [
        Rn.startPage,
        Rn.endPage,
        Rn.isSmoothScrolling,
        Rn.maxVisbilityIndex,
        qn.fullScreenMode,
        wr,
        Gn,
        Jt
      ]);
      var Wo = t.useCallback(function(ht) {
        dr.markRendered(ht), ei();
      }, [zi]), ei = function() {
        var ht = dr.getHighestPriorityPage();
        ht > -1 && dr.isInRange(ht) && (dr.markRendering(ht), Ni(ht));
      }, Uo = function(ht) {
        var rn = On - 1, _n = On + 1;
        switch (ht) {
          case "FirstPage":
            Mr(0);
            break;
          case "LastPage":
            Mr(Bt - 1);
            break;
          case "NextPage":
            _n < Bt && Mr(_n);
            break;
          case "PrevPage":
            rn >= 0 && Mr(rn);
            break;
        }
      }, $o = t.useCallback(function() {
        var ht = Rn.virtualItems, rn = [];
        switch (Ke) {
          case e.ViewMode.DualPage:
            rn = ct(ht, 2);
            break;
          case e.ViewMode.DualPageWithCover:
            ht.length && (rn = ht[0].index === 0 ? [[ht[0]]].concat(ct(ht.slice(1), 2)) : ct(ht, 2));
            break;
          case e.ViewMode.SinglePage:
          default:
            rn = ct(ht, 1);
            break;
        }
        var _n = An && An.core ? An.core.pageLabel : "Page {{pageIndex}}", Nn = {
          attrs: {
            className: "rpv-core__inner-container",
            "data-testid": "core__inner-container",
            ref: Jn,
            style: {
              height: "100%"
            }
          },
          children: t.createElement(t.Fragment, null),
          subSlot: {
            attrs: {
              "data-testid": "core__inner-pages",
              className: H({
                "rpv-core__inner-pages": !0,
                "rpv-core__inner-pages--horizontal": dn === e.ScrollMode.Horizontal,
                "rpv-core__inner-pages--rtl": Dn,
                "rpv-core__inner-pages--single": dn === e.ScrollMode.Page,
                "rpv-core__inner-pages--vertical": dn === e.ScrollMode.Vertical,
                "rpv-core__inner-pages--wrapped": dn === e.ScrollMode.Wrapped
              }),
              ref: Vn,
              style: {
                height: "100%",
                position: "relative"
              }
            },
            children: t.createElement("div", { "data-testid": "core__inner-current-page-".concat(On), style: Object.assign({
              "--scale-factor": Jt
            }, Rn.getContainerStyles()) }, rn.map(function(Wn) {
              return t.createElement("div", { className: H({
                "rpv-core__inner-page-container": !0,
                "rpv-core__inner-page-container--single": dn === e.ScrollMode.Page
              }), style: Rn.getItemContainerStyles(Wn[0]), key: "".concat(Wn[0].index, "-").concat(Ke) }, Wn.map(function(Pn) {
                var tr = Ke === e.ViewMode.DualPageWithCover && (Pn.index === 0 || Bt % 2 === 0 && Pn.index === Bt - 1);
                return t.createElement(
                  "div",
                  { "aria-label": _n.replace("{{pageIndex}}", "".concat(Pn.index + 1)), className: H({
                    "rpv-core__inner-page": !0,
                    "rpv-core__inner-page--dual-even": Ke === e.ViewMode.DualPage && Pn.index % 2 === 0,
                    "rpv-core__inner-page--dual-odd": Ke === e.ViewMode.DualPage && Pn.index % 2 === 1,
                    "rpv-core__inner-page--dual-cover": tr,
                    "rpv-core__inner-page--dual-cover-even": Ke === e.ViewMode.DualPageWithCover && !tr && Pn.index % 2 === 0,
                    "rpv-core__inner-page--dual-cover-odd": Ke === e.ViewMode.DualPageWithCover && !tr && Pn.index % 2 === 1,
                    "rpv-core__inner-page--single": Ke === e.ViewMode.SinglePage && dn === e.ScrollMode.Page
                  }), role: "region", key: "".concat(Pn.index, "-").concat(Ke), style: Object.assign({}, Rn.getItemStyles(Pn), ji.buildPageStyles({
                    numPages: Bt,
                    pageIndex: Pn.index,
                    scrollMode: dn,
                    viewMode: Ke
                  })) },
                  t.createElement(ca, { doc: ee, measureRef: Pn.measureRef, outlines: pn, pageIndex: Pn.index, pageRotation: tn.has(Pn.index) ? tn.get(Pn.index) : 0, pageSize: Se[Pn.index], plugins: Fe, renderPage: ze, renderQueueKey: zi, rotation: Gn, scale: Jt, shouldRender: xo === Pn.index, viewMode: Ke, onExecuteNamedAction: Uo, onJumpFromLinkAnnotation: No, onJumpToDest: Vi, onRenderCompleted: Wo, onRotatePage: Qa })
                );
              }));
            }))
          }
        };
        return Fe.forEach(function(Wn) {
          Wn.renderViewer && (Nn = Wn.renderViewer({
            containerRef: Jn,
            doc: ee,
            pagesContainerRef: Vn,
            pagesRotation: tn,
            pageSizes: Se,
            rotation: Gn,
            slot: Nn,
            themeContext: $n,
            jumpToPage: Mr,
            openFile: Hi,
            rotate: qi,
            rotatePage: Qa,
            switchScrollMode: Wi,
            switchViewMode: Ui,
            zoom: Lr
          }));
        }), Nn;
      }, [Fe, Rn]), Gi = t.useCallback(function(ht) {
        return t.createElement(
          "div",
          G({}, ht.attrs, { style: ht.attrs && ht.attrs.style ? ht.attrs.style : {} }),
          ht.children,
          ht.subSlot && Gi(ht.subSlot)
        );
      }, []);
      return Gi($o());
    }, In = [
      0.1,
      0.2,
      0.3,
      0.4,
      0.5,
      0.6,
      0.7,
      0.8,
      0.9,
      1,
      1.1,
      1.3,
      1.5,
      1.7,
      1.9,
      2.1,
      2.4,
      2.7,
      3,
      3.3,
      3.7,
      4.1,
      4.6,
      5.1,
      5.7,
      6.3,
      7,
      7.7,
      8.5,
      9.4,
      10
    ], Fn = function(h) {
      var O = In.findIndex(function(Y) {
        return Y >= h;
      });
      return O === -1 || O === 0 ? h : In[O - 1];
    }, Kn = 45, mr = 45, ur = function(h) {
      var O = h.defaultScale, Y = h.doc, ee = h.render, J = h.scrollMode, ae = h.viewMode, se = t.useRef(), he = t.useState({
        pageSizes: [],
        scale: 0
      }), ne = he[0], Se = he[1];
      return t.useLayoutEffect(function() {
        var Fe = Array(Y.numPages).fill(0).map(function(ze, Ue) {
          return new Promise(function(ot, Ze) {
            He(Y, Ue).then(function(gt) {
              var et = gt.getViewport({ scale: 1 });
              ot({
                pageHeight: et.height,
                pageWidth: et.width,
                rotation: et.rotation
              });
            });
          });
        });
        Promise.all(Fe).then(function(ze) {
          var Ue = se.current;
          if (!(!Ue || ze.length === 0)) {
            var ot = ze[0].pageWidth, Ze = ze[0].pageHeight, gt = Ue.parentElement, et = (gt.clientWidth - mr) / ot, It = (gt.clientHeight - Kn) / Ze, Rt = et;
            switch (J) {
              case e.ScrollMode.Horizontal:
                Rt = Math.min(et, It);
                break;
              case e.ScrollMode.Vertical:
              default:
                Rt = et;
                break;
            }
            var wt = O ? typeof O == "string" ? Nt(gt, Ze, ot, O, ae, Y.numPages) : O : Fn(Rt);
            Se({ pageSizes: ze, scale: wt });
          }
        });
      }, [Y.loadingTask.docId]), ne.pageSizes.length === 0 || ne.scale === 0 ? t.createElement(
        "div",
        { className: "rpv-core__page-size-calculator", "data-testid": "core__page-size-calculating", ref: se },
        t.createElement(v, null)
      ) : ee(ne.pageSizes, ne.scale);
    }, jn = /* @__PURE__ */ function() {
      function h() {
      }
      return h;
    }(), Xn = function(h) {
      Q(O, h);
      function O(Y, ee) {
        var J = h.call(this) || this;
        return J.verifyPassword = Y, J.passwordStatus = ee, J;
      }
      return O;
    }(jn), Er = function(h) {
      var O = h.passwordStatus, Y = h.renderProtectedView, ee = h.verifyPassword, J = h.onDocumentAskPassword, ae = t.useContext(fe).l10n, se = t.useState(""), he = se[0], ne = se[1], Se = t.useContext(N).direction, Fe = Se === e.TextDirection.RightToLeft, ze = function() {
        return ee(he);
      }, Ue = function(ot) {
        ot.key === "Enter" && ze();
      };
      return t.useEffect(function() {
        J && J({
          verifyPassword: ee
        });
      }, []), Y ? Y({
        passwordStatus: O,
        verifyPassword: ee
      }) : t.createElement(
        "div",
        { className: "rpv-core__asking-password-wrapper" },
        t.createElement(
          "div",
          { className: H({
            "rpv-core__asking-password": !0,
            "rpv-core__asking-password--rtl": Fe
          }) },
          t.createElement(
            "div",
            { className: "rpv-core__asking-password-message" },
            O === e.PasswordStatus.RequiredPassword && ae.core.askingPassword.requirePasswordToOpen,
            O === e.PasswordStatus.WrongPassword && ae.core.wrongPassword.tryAgain
          ),
          t.createElement(
            "div",
            { className: "rpv-core__asking-password-body" },
            t.createElement(
              "div",
              { className: H({
                "rpv-core__asking-password-input": !0,
                "rpv-core__asking-password-input--ltr": !Fe,
                "rpv-core__asking-password-input--rtl": Fe
              }) },
              t.createElement(a, { testId: "core__asking-password-input", type: "password", value: he, onChange: ne, onKeyDown: Ue })
            ),
            t.createElement(b, { onClick: ze }, ae.core.askingPassword.submit)
          )
        )
      );
    }, qt = function(h) {
      Q(O, h);
      function O(Y) {
        var ee = h.call(this) || this;
        return ee.doc = Y, ee;
      }
      return O;
    }(jn), Vt = function(h) {
      Q(O, h);
      function O(Y) {
        var ee = h.call(this) || this;
        return ee.error = Y, ee;
      }
      return O;
    }(jn), At = function(h) {
      Q(O, h);
      function O(Y) {
        var ee = h.call(this) || this;
        return ee.percentages = Y, ee;
      }
      return O;
    }(jn), Dt = function(h) {
      var O = h.characterMap, Y = h.file, ee = h.httpHeaders, J = h.render, ae = h.renderError, se = h.renderLoader, he = h.renderProtectedView, ne = h.transformGetDocumentParams, Se = h.withCredentials, Fe = h.onDocumentAskPassword, ze = t.useContext(N).direction, Ue = ze === e.TextDirection.RightToLeft, ot = t.useState(new At(0)), Ze = ot[0], gt = ot[1], et = t.useRef(""), It = F();
      return t.useEffect(function() {
        et.current = "", gt(new At(0));
        var Rt = new l.PDFWorker({ name: "PDFWorker_".concat(Date.now()) }), wt = Object.assign({
          httpHeaders: ee,
          withCredentials: Se,
          worker: Rt
        }, typeof Y == "string" ? { url: Y } : { data: Y }, O ? {
          cMapUrl: O.url,
          cMapPacked: O.isCompressed
        } : {}), En = ne ? ne(wt) : wt, Zt = l.getDocument(En);
        return Zt.onPassword = function(Bt, Ht) {
          switch (Ht) {
            case l.PasswordResponses.NEED_PASSWORD:
              It.current && gt(new Xn(Bt, e.PasswordStatus.RequiredPassword));
              break;
            case l.PasswordResponses.INCORRECT_PASSWORD:
              It.current && gt(new Xn(Bt, e.PasswordStatus.WrongPassword));
              break;
          }
        }, Zt.onProgress = function(Bt) {
          var Ht = Bt.total > 0 ? Math.min(100, 100 * Bt.loaded / Bt.total) : 100;
          It.current && et.current === "" && gt(new At(Ht));
        }, Zt.promise.then(function(Bt) {
          et.current = Bt.loadingTask.docId, It.current && gt(new qt(Bt));
        }, function(Bt) {
          return It.current && !Rt.destroyed && gt(new Vt({
            message: Bt.message || "Cannot load document",
            name: Bt.name
          }));
        }), function() {
          Zt.destroy(), Rt.destroy();
        };
      }, [Y]), Ze instanceof Xn ? t.createElement(Er, { passwordStatus: Ze.passwordStatus, renderProtectedView: he, verifyPassword: Ze.verifyPassword, onDocumentAskPassword: Fe }) : Ze instanceof qt ? J(Ze.doc) : Ze instanceof Vt ? ae ? ae(Ze.error) : t.createElement(
        "div",
        { className: H({
          "rpv-core__doc-error": !0,
          "rpv-core__doc-error--rtl": Ue
        }) },
        t.createElement("div", { className: "rpv-core__doc-error-text" }, Ze.error.message)
      ) : t.createElement("div", { "data-testid": "core__doc-loading", className: H({
        "rpv-core__doc-loading": !0,
        "rpv-core__doc-loading--rtl": Ue
      }) }, se ? se(Ze.percentages) : t.createElement(v, null));
    }, Lt = function() {
      return typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    }, Kt = function(h, O) {
      var Y = t.useMemo(function() {
        return h === "auto" ? Lt() ? "dark" : "light" : h;
      }, []), ee = t.useState(Y), J = ee[0], ae = ee[1], se = U(J);
      return t.useEffect(function() {
        if (h === "auto") {
          var he = window.matchMedia("(prefers-color-scheme: dark)"), ne = function(Se) {
            ae(Se.matches ? "dark" : "light");
          };
          return he.addEventListener("change", ne), function() {
            return he.removeEventListener("change", ne);
          };
        }
      }, []), t.useEffect(function() {
        J !== se && O && O(J);
      }, [J]), t.useEffect(function() {
        h !== J && ae(h);
      }, [h]), {
        currentTheme: J,
        setCurrentTheme: ae
      };
    }, Yt = function(h, O) {
      var Y = typeof h, ee = typeof O;
      return Y === "string" && ee === "string" && h === O ? !0 : Y === "object" && ee === "object" ? h.length === O.length && h.every(function(J, ae) {
        return J === O[ae];
      }) : !1;
    }, Ft = 3, kt = function(h) {
      return {
        startPage: h.startPage - Ft,
        endPage: h.endPage + Ft
      };
    }, Qt = function(h) {
      var O = h.characterMap, Y = h.defaultScale, ee = h.enableSmoothScroll, J = ee === void 0 ? !0 : ee, ae = h.fileUrl, se = h.httpHeaders, he = se === void 0 ? {} : se, ne = h.initialPage, Se = ne === void 0 ? 0 : ne, Fe = h.pageLayout, ze = h.initialRotation, Ue = ze === void 0 ? 0 : ze, ot = h.localization, Ze = h.plugins, gt = Ze === void 0 ? [] : Ze, et = h.renderError, It = h.renderLoader, Rt = h.renderPage, wt = h.renderProtectedView, En = h.scrollMode, Zt = En === void 0 ? e.ScrollMode.Vertical : En, Bt = h.setRenderRange, Ht = Bt === void 0 ? kt : Bt, An = h.transformGetDocumentParams, $n = h.theme, Dn = $n === void 0 ? {
        direction: e.TextDirection.LeftToRight,
        theme: "light"
      } : $n, Jn = h.viewMode, Vn = Jn === void 0 ? e.ViewMode.SinglePage : Jn, ar = h.withCredentials, On = ar === void 0 ? !1 : ar, Sr = h.onDocumentAskPassword, ir = h.onDocumentLoad, Yn = ir === void 0 ? function() {
      } : ir, Zn = h.onPageChange, Gn = Zn === void 0 ? function() {
      } : Zn, nr = h.onRotate, rr = nr === void 0 ? function() {
      } : nr, _r = h.onRotatePage, wr = _r === void 0 ? function() {
      } : _r, pr = h.onSwitchTheme, gr = pr === void 0 ? function() {
      } : pr, tn = h.onZoom, cn = tn === void 0 ? function() {
      } : tn, yn = t.useState({
        data: ae,
        name: typeof ae == "string" ? ae : "",
        shouldLoad: !1
      }), dn = yn[0], nn = yn[1], wn = function(er, cr) {
        nn({
          data: cr,
          name: er,
          shouldLoad: !0
        });
      }, kn = t.useState(!1), Ke = kn[0], Ot = kn[1], on = U(dn);
      t.useEffect(function() {
        Yt(on.data, ae) || nn({
          data: ae,
          name: typeof ae == "string" ? ae : "",
          shouldLoad: Ke
        });
      }, [ae, Ke]);
      var pn = function(er) {
        Ot(er.isVisible), er.isVisible && nn(function(cr) {
          return Object.assign({}, cr, { shouldLoad: !0 });
        });
      }, hn = S({
        onVisibilityChanged: pn
      }), Jt = typeof Dn == "string" ? { direction: e.TextDirection.LeftToRight, theme: Dn } : Dn, zn = t.useState(ot || le), or = zn[0], ln = zn[1], sr = { l10n: or, setL10n: ln }, Qn = Object.assign({}, { direction: Jt.direction }, Kt(Jt.theme || "light", gr));
      return t.useEffect(function() {
        ot && ln(ot);
      }, [ot]), t.createElement(
        fe.Provider,
        { value: sr },
        t.createElement(
          N.Provider,
          { value: Qn },
          t.createElement("div", { ref: hn, className: "rpv-core__viewer rpv-core__viewer--".concat(Qn.currentTheme), "data-testid": "core__viewer", style: {
            height: "100%",
            width: "100%"
          } }, dn.shouldLoad && t.createElement(Dt, { characterMap: O, file: dn.data, httpHeaders: he, render: function(er) {
            return t.createElement(ur, { defaultScale: Y, doc: er, render: function(cr, qn) {
              return t.createElement(Bn, { currentFile: {
                data: dn.data,
                name: dn.name
              }, defaultScale: Y, doc: er, enableSmoothScroll: J, initialPage: Se, initialRotation: Ue, initialScale: qn, pageLayout: Fe, pageSizes: cr, plugins: gt, renderPage: Rt, scrollMode: Zt, setRenderRange: Ht, viewMode: Vn, viewerState: {
                file: dn,
                fullScreenMode: e.FullScreenMode.Normal,
                pageIndex: -1,
                pageHeight: cr[0].pageHeight,
                pageWidth: cr[0].pageWidth,
                pagesRotation: /* @__PURE__ */ new Map(),
                rotation: Ue,
                scale: qn,
                scrollMode: Zt,
                viewMode: Vn
              }, onDocumentLoad: Yn, onOpenFile: wn, onPageChange: Gn, onRotate: rr, onRotatePage: wr, onZoom: cn });
            }, scrollMode: Zt, viewMode: Vn });
          }, renderError: et, renderLoader: It, renderProtectedView: wt, transformGetDocumentParams: An, withCredentials: On, onDocumentAskPassword: Sr }))
        )
      );
    }, an = function(h) {
      var O = h.children, Y = h.workerUrl;
      return l.GlobalWorkerOptions.workerSrc = Y, t.createElement(t.Fragment, null, O);
    };
    e.Button = B, e.Icon = s, e.LazyRender = r, e.LocalizationContext = fe, e.Menu = u, e.MenuDivider = m, e.MenuItem = i, e.MinimalButton = o, e.Modal = Be, e.Popover = it, e.PrimaryButton = b, e.ProgressBar = g, e.Separator = c, e.Spinner = v, e.Splitter = k, e.TextBox = a, e.ThemeContext = N, e.Tooltip = tt, e.Viewer = Qt, e.Worker = an, e.chunk = ct, e.classNames = H, e.createStore = Xe, e.getDestination = at, e.getPage = He, e.isFullScreenEnabled = T, e.isMac = xt, e.useDebounceCallback = _, e.useIntersectionObserver = S, e.useIsMounted = F, e.useIsomorphicLayoutEffect = P, e.usePrevious = U, e.useRenderQueue = re;
  }(core)), core;
}
var hasRequiredLib$h;
function requireLib$h() {
  if (hasRequiredLib$h) return lib$h.exports;
  hasRequiredLib$h = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$h.exports = requireCore_min() : lib$h.exports = requireCore(), lib$h.exports;
}
var libExports$1 = requireLib$h(), lib$g = { exports: {} }, defaultLayout_min = {}, lib$f = { exports: {} }, attachment_min = {}, hasRequiredAttachment_min;
function requireAttachment_min() {
  if (hasRequiredAttachment_min) return attachment_min;
  hasRequiredAttachment_min = 1;
  var e = requireLib$h();
  function L(W) {
    var Q = /* @__PURE__ */ Object.create(null);
    return W && Object.keys(W).forEach(function(G) {
      if (G !== "default") {
        var X = Object.getOwnPropertyDescriptor(W, G);
        Object.defineProperty(Q, G, X.get ? X : { enumerable: !0, get: function() {
          return W[G];
        } });
      }
    }), Q.default = W, Object.freeze(Q);
  }
  var p = L(requireReact()), n = function(W) {
    var Q = W.files, G = p.useRef(), X = p.useContext(e.LocalizationContext).l10n, N = p.useContext(e.ThemeContext).direction === e.TextDirection.RightToLeft, H = p.useRef([]), B = X && X.attachment ? X.attachment.clickToDownload : "Click to download", P = function(S) {
      var r = G.current, u = [].slice.call(r.getElementsByClassName("rpv-attachment__item"));
      if (u.length !== 0) {
        u.forEach(function(w) {
          return w.setAttribute("tabindex", "-1");
        });
        var m = document.activeElement, s = u[Math.min(u.length - 1, Math.max(0, S(u, m)))];
        s.setAttribute("tabindex", "0"), s.focus();
      }
    };
    return e.useIsomorphicLayoutEffect(function() {
      var S = G.current;
      if (S) {
        var r = [].slice.call(S.getElementsByClassName("rpv-attachment__item"));
        if (H.current = r, r.length > 0) {
          var u = r[0];
          u.focus(), u.setAttribute("tabindex", "0");
        }
      }
    }, []), p.createElement("div", { "data-testid": "attachment__list", className: e.classNames({ "rpv-attachment__list": !0, "rpv-attachment__list--rtl": N }), ref: G, tabIndex: -1, onKeyDown: function(S) {
      switch (S.key) {
        case "ArrowDown":
          S.preventDefault(), P(function(r, u) {
            return r.indexOf(u) + 1;
          });
          break;
        case "ArrowUp":
          S.preventDefault(), P(function(r, u) {
            return r.indexOf(u) - 1;
          });
          break;
        case "End":
          S.preventDefault(), P(function(r, u) {
            return r.length - 1;
          });
          break;
        case "Home":
          S.preventDefault(), P(function(r, u) {
            return 0;
          });
      }
    } }, Q.map(function(S) {
      return p.createElement("button", { className: "rpv-attachment__item", key: S.fileName, tabIndex: -1, title: B, type: "button", onClick: function() {
        return r = S.fileName, u = S.data, m = typeof u == "string" ? "" : URL.createObjectURL(new Blob([u], { type: "" })), (s = document.createElement("a")).style.display = "none", s.href = m || r, s.setAttribute("download", function(w) {
          var i = w.split("/").pop();
          return i ? i.split("#")[0].split("?")[0] : w;
        }(r)), document.body.appendChild(s), s.click(), document.body.removeChild(s), void (m && URL.revokeObjectURL(m));
        var r, u, m, s;
      } }, S.fileName);
    }));
  }, t = function(W) {
    var Q = W.doc, G = p.useContext(e.LocalizationContext).l10n, X = p.useContext(e.ThemeContext).direction === e.TextDirection.RightToLeft, N = G && G.attachment ? G.attachment.noAttachment : "There is no attachment", H = p.useState({ files: [], isLoaded: !1 }), B = H[0], P = H[1];
    return p.useEffect(function() {
      Q.getAttachments().then(function(S) {
        var r = S ? Object.keys(S).map(function(u) {
          return { data: S[u].content, fileName: S[u].filename };
        }) : [];
        P({ files: r, isLoaded: !0 });
      });
    }, [Q]), B.isLoaded ? B.files.length === 0 ? p.createElement("div", { "data-testid": "attachment__empty", className: e.classNames({ "rpv-attachment__empty": !0, "rpv-attachment__empty--rtl": X }) }, N) : p.createElement(n, { files: B.files }) : p.createElement(e.Spinner, null);
  }, l = function(W) {
    var Q = W.store, G = p.useState(Q.get("doc")), X = G[0], N = G[1], H = function(B) {
      N(B);
    };
    return p.useEffect(function() {
      return Q.subscribe("doc", H), function() {
        Q.unsubscribe("doc", H);
      };
    }, []), X ? p.createElement(t, { doc: X }) : p.createElement("div", { className: "rpv-attachment__loader" }, p.createElement(e.Spinner, null));
  };
  return attachment_min.attachmentPlugin = function() {
    var W = p.useMemo(function() {
      return e.createStore({});
    }, []);
    return { onDocumentLoad: function(Q) {
      W.update("doc", Q.doc);
    }, Attachments: function() {
      return p.createElement(l, { store: W });
    } };
  }, attachment_min;
}
var attachment = {}, hasRequiredAttachment;
function requireAttachment() {
  if (hasRequiredAttachment) return attachment;
  hasRequiredAttachment = 1;
  var e = requireLib$h(), L = requireReact();
  function p(N) {
    var H = /* @__PURE__ */ Object.create(null);
    return N && Object.keys(N).forEach(function(B) {
      if (B !== "default") {
        var P = Object.getOwnPropertyDescriptor(N, B);
        Object.defineProperty(H, B, P.get ? P : {
          enumerable: !0,
          get: function() {
            return N[B];
          }
        });
      }
    }), H.default = N, Object.freeze(H);
  }
  var n = /* @__PURE__ */ p(L), t = function(N) {
    var H = N.split("/").pop();
    return H ? H.split("#")[0].split("?")[0] : N;
  }, l = function(N, H) {
    var B = typeof H == "string" ? "" : URL.createObjectURL(new Blob([H], { type: "" })), P = document.createElement("a");
    P.style.display = "none", P.href = B || N, P.setAttribute("download", t(N)), document.body.appendChild(P), P.click(), document.body.removeChild(P), B && URL.revokeObjectURL(B);
  }, W = function(N) {
    var H = N.files, B = n.useRef(), P = n.useContext(e.LocalizationContext).l10n, S = n.useContext(e.ThemeContext).direction, r = S === e.TextDirection.RightToLeft, u = n.useRef([]), m = P && P.attachment ? P.attachment.clickToDownload : "Click to download", s = function(i) {
      switch (i.key) {
        case "ArrowDown":
          i.preventDefault(), w(function(o, b) {
            return o.indexOf(b) + 1;
          });
          break;
        case "ArrowUp":
          i.preventDefault(), w(function(o, b) {
            return o.indexOf(b) - 1;
          });
          break;
        case "End":
          i.preventDefault(), w(function(o, b) {
            return o.length - 1;
          });
          break;
        case "Home":
          i.preventDefault(), w(function(o, b) {
            return 0;
          });
          break;
      }
    }, w = function(i) {
      var o = B.current, b = [].slice.call(o.getElementsByClassName("rpv-attachment__item"));
      if (b.length !== 0) {
        b.forEach(function(k) {
          return k.setAttribute("tabindex", "-1");
        });
        var g = document.activeElement, c = Math.min(b.length - 1, Math.max(0, i(b, g))), v = b[c];
        v.setAttribute("tabindex", "0"), v.focus();
      }
    };
    return e.useIsomorphicLayoutEffect(function() {
      var i = B.current;
      if (i) {
        var o = [].slice.call(i.getElementsByClassName("rpv-attachment__item"));
        if (u.current = o, o.length > 0) {
          var b = o[0];
          b.focus(), b.setAttribute("tabindex", "0");
        }
      }
    }, []), n.createElement("div", { "data-testid": "attachment__list", className: e.classNames({
      "rpv-attachment__list": !0,
      "rpv-attachment__list--rtl": r
    }), ref: B, tabIndex: -1, onKeyDown: s }, H.map(function(i) {
      return n.createElement("button", { className: "rpv-attachment__item", key: i.fileName, tabIndex: -1, title: m, type: "button", onClick: function() {
        return l(i.fileName, i.data);
      } }, i.fileName);
    }));
  }, Q = function(N) {
    var H = N.doc, B = n.useContext(e.LocalizationContext).l10n, P = n.useContext(e.ThemeContext).direction, S = P === e.TextDirection.RightToLeft, r = B && B.attachment ? B.attachment.noAttachment : "There is no attachment", u = n.useState({
      files: [],
      isLoaded: !1
    }), m = u[0], s = u[1];
    return n.useEffect(function() {
      H.getAttachments().then(function(w) {
        var i = w ? Object.keys(w).map(function(o) {
          return {
            data: w[o].content,
            fileName: w[o].filename
          };
        }) : [];
        s({
          files: i,
          isLoaded: !0
        });
      });
    }, [H]), m.isLoaded ? m.files.length === 0 ? n.createElement("div", { "data-testid": "attachment__empty", className: e.classNames({
      "rpv-attachment__empty": !0,
      "rpv-attachment__empty--rtl": S
    }) }, r) : n.createElement(W, { files: m.files }) : n.createElement(e.Spinner, null);
  }, G = function(N) {
    var H = N.store, B = n.useState(H.get("doc")), P = B[0], S = B[1], r = function(u) {
      S(u);
    };
    return n.useEffect(function() {
      return H.subscribe("doc", r), function() {
        H.unsubscribe("doc", r);
      };
    }, []), P ? n.createElement(Q, { doc: P }) : n.createElement(
      "div",
      { className: "rpv-attachment__loader" },
      n.createElement(e.Spinner, null)
    );
  }, X = function() {
    var N = n.useMemo(function() {
      return e.createStore({});
    }, []), H = function() {
      return n.createElement(G, { store: N });
    };
    return {
      onDocumentLoad: function(B) {
        N.update("doc", B.doc);
      },
      Attachments: H
    };
  };
  return attachment.attachmentPlugin = X, attachment;
}
var hasRequiredLib$g;
function requireLib$g() {
  if (hasRequiredLib$g) return lib$f.exports;
  hasRequiredLib$g = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$f.exports = requireAttachment_min() : lib$f.exports = requireAttachment(), lib$f.exports;
}
var lib$e = { exports: {} }, bookmark_min = {}, hasRequiredBookmark_min;
function requireBookmark_min() {
  if (hasRequiredBookmark_min) return bookmark_min;
  hasRequiredBookmark_min = 1;
  var e = requireLib$h();
  function L(B) {
    var P = /* @__PURE__ */ Object.create(null);
    return B && Object.keys(B).forEach(function(S) {
      if (S !== "default") {
        var r = Object.getOwnPropertyDescriptor(B, S);
        Object.defineProperty(P, S, r.get ? r : { enumerable: !0, get: function() {
          return B[S];
        } });
      }
    }), P.default = B, Object.freeze(P);
  }
  var p, n = L(requireReact()), t = function() {
    return t = Object.assign || function(B) {
      for (var P, S = 1, r = arguments.length; S < r; S++) for (var u in P = arguments[S]) Object.prototype.hasOwnProperty.call(P, u) && (B[u] = P[u]);
      return B;
    }, t.apply(this, arguments);
  }, l = function() {
    return n.createElement(e.Icon, { size: 16 }, n.createElement("path", { d: "M6.427,8.245A.5.5,0,0,1,6.862,7.5H17.138a.5.5,0,0,1,.435.749l-5.139,9a.5.5,0,0,1-.868,0Z" }));
  }, W = function() {
    return n.createElement(e.Icon, { size: 16 }, n.createElement("path", { d: "M9.248,17.572a.5.5,0,0,1-.748-.434V6.862a.5.5,0,0,1,.748-.434l8.992,5.138a.5.5,0,0,1,0,.868Z" }));
  }, Q = function(B) {
    var P = B.bookmark, S = B.depth, r = B.doc, u = B.index, m = B.isBookmarkExpanded, s = B.numberOfSiblings, w = B.pathFromRoot, i = B.renderBookmarkItem, o = B.store, b = w ? "".concat(w, ".").concat(u) : "".concat(u), g = n.useMemo(function() {
      return function(j) {
        var A = j.count, d = j.items;
        if (A >= 0) return !1;
        var _ = d.length;
        if (_ === 0) return !1;
        for (var F = d.concat([]); F.length > 0; ) {
          var U = F.shift(), V = U.items;
          U.count && V && U.count > 0 && V.length > 0 && (_ += V.length, F = F.concat(V));
        }
        return Math.abs(A) === _;
      }(P);
    }, [P]), c = o.get("bookmarkExpandedMap"), v = m ? m({ bookmark: P, doc: r, depth: S, index: u }) : c.has(b) ? c.get(b) : !g, k = n.useState(v), a = k[0], f = k[1], C = P.items && P.items.length > 0, R = function() {
      var j = !a;
      o.updateCurrentValue("bookmarkExpandedMap", function(A) {
        return A.set(b, j);
      }), f(j);
    }, M = function() {
      var j = P.dest, A = o.get("jumpToDestination");
      e.getDestination(r, j).then(function(d) {
        A && A(t({ label: P.title }, d));
      });
    }, I = function() {
      C && P.dest && M();
    }, E = function() {
      !C && P.dest && M();
    }, T = function(j, A) {
      return n.createElement("div", { className: "rpv-bookmark__item", style: { paddingLeft: "".concat(1.25 * S, "rem") }, onClick: j }, A);
    }, y = function(j, A) {
      return C ? n.createElement("span", { className: "rpv-bookmark__toggle", "data-testid": "bookmark__toggle-".concat(S, "-").concat(u), onClick: R }, a ? j : A) : n.createElement("span", { className: "rpv-bookmark__toggle" });
    }, D = function(j) {
      return P.url ? n.createElement("a", { className: "rpv-bookmark__title", href: P.url, rel: "noopener noreferrer nofollow", target: P.newWindow ? "_blank" : "" }, P.title) : n.createElement("div", { className: "rpv-bookmark__title", "aria-label": P.title, onClick: j }, P.title);
    };
    return n.createElement("li", { "aria-expanded": a ? "true" : "false", "aria-label": P.title, "aria-level": S + 1, "aria-posinset": u + 1, "aria-setsize": s, role: "treeitem", tabIndex: -1 }, i ? i({ bookmark: P, depth: S, hasSubItems: C, index: u, isExpanded: a, path: b, defaultRenderItem: T, defaultRenderTitle: D, defaultRenderToggle: y, onClickItem: E, onClickTitle: I, onToggleSubItems: R }) : T(E, n.createElement(n.Fragment, null, y(n.createElement(l, null), n.createElement(W, null)), D(I))), C && a && n.createElement(G, { bookmarks: P.items, depth: S + 1, doc: r, isBookmarkExpanded: m, isRoot: !1, pathFromRoot: b, renderBookmarkItem: i, store: o }));
  }, G = function(B) {
    var P = B.bookmarks, S = B.depth, r = S === void 0 ? 0 : S, u = B.doc, m = B.isBookmarkExpanded, s = B.isRoot, w = B.pathFromRoot, i = B.renderBookmarkItem, o = B.store;
    return n.createElement("ul", { className: "rpv-bookmark__list", role: s ? "tree" : "group", tabIndex: -1 }, P.map(function(b, g) {
      return n.createElement(Q, { bookmark: b, depth: r, doc: u, index: g, isBookmarkExpanded: m, key: g, numberOfSiblings: P.length, pathFromRoot: w, renderBookmarkItem: i, store: o });
    }));
  };
  (function(B) {
    B[B.Collapse = 0] = "Collapse", B[B.Expand = 1] = "Expand";
  })(p || (p = {}));
  var X = function(B) {
    var P = B.bookmarks, S = B.doc, r = B.isBookmarkExpanded, u = B.renderBookmarkItem, m = B.store, s = n.useRef(), w = function(g) {
      var c = s.current;
      if (c && g.target instanceof HTMLElement && c.contains(g.target)) switch (g.key) {
        case "ArrowDown":
          g.preventDefault(), o(function(v, k) {
            return v.indexOf(k) + 1;
          });
          break;
        case "ArrowLeft":
          g.preventDefault(), b(p.Collapse);
          break;
        case "ArrowRight":
          g.preventDefault(), b(p.Expand);
          break;
        case "ArrowUp":
          g.preventDefault, o(function(v, k) {
            return v.indexOf(k) - 1;
          });
          break;
        case "End":
          g.preventDefault(), o(function(v, k) {
            return v.length - 1;
          });
          break;
        case " ":
        case "Enter":
        case "Space":
          g.preventDefault(), i();
          break;
        case "Home":
          g.preventDefault(), o(function(v, k) {
            return 0;
          });
      }
    }, i = function() {
      var g = document.activeElement.closest(".rpv-bookmark__item").querySelector(".rpv-bookmark__title");
      g && g.click();
    }, o = function(g) {
      var c = s.current, v = [].slice.call(c.getElementsByClassName("rpv-bookmark__item"));
      if (v.length !== 0) {
        var k = document.activeElement, a = v[Math.min(v.length - 1, Math.max(0, g(v, k)))];
        k.setAttribute("tabindex", "-1"), a.setAttribute("tabindex", "0"), a.focus();
      }
    }, b = function(g) {
      var c = s.current;
      if ([].slice.call(c.getElementsByClassName("rpv-bookmark__item")).length !== 0) {
        var v = document.activeElement.closest(".rpv-bookmark__item"), k = g === p.Collapse ? "true" : "false";
        if (v && v.parentElement.getAttribute("aria-expanded") === k) {
          var a = v.querySelector(".rpv-bookmark__toggle");
          a && a.click();
        }
      }
    };
    return n.useEffect(function() {
      return document.addEventListener("keydown", w), function() {
        document.removeEventListener("keydown", w);
      };
    }, []), n.useEffect(function() {
      var g = s.current;
      if (g) {
        var c = [].slice.call(g.getElementsByClassName("rpv-bookmark__item"));
        c.length > 0 && (c[0].focus(), c[0].setAttribute("tabindex", "0"));
      }
    }, []), n.createElement("div", { ref: s }, n.createElement(G, { bookmarks: P, depth: 0, doc: S, isBookmarkExpanded: r, isRoot: !0, pathFromRoot: "", renderBookmarkItem: u, store: m }));
  }, N = function(B) {
    var P = B.doc, S = B.isBookmarkExpanded, r = B.renderBookmarkItem, u = B.store, m = n.useContext(e.LocalizationContext).l10n, s = n.useContext(e.ThemeContext).direction === e.TextDirection.RightToLeft, w = n.useState({ isLoaded: !1, items: [] }), i = w[0], o = w[1];
    return n.useEffect(function() {
      o({ isLoaded: !1, items: [] }), P.getOutline().then(function(b) {
        o({ isLoaded: !0, items: b || [] });
      });
    }, [P]), i.isLoaded ? i.items.length === 0 ? n.createElement("div", { "data-testid": "bookmark__empty", className: e.classNames({ "rpv-bookmark__empty": !0, "rpv-bookmark__empty--rtl": s }) }, m && m.bookmark ? m.bookmark.noBookmark : "There is no bookmark") : n.createElement("div", { "data-testid": "bookmark__container", className: e.classNames({ "rpv-bookmark__container": !0, "rpv-bookmark__container--rtl": s }) }, n.createElement(X, { bookmarks: i.items, doc: P, isBookmarkExpanded: S, renderBookmarkItem: r, store: u })) : n.createElement("div", { className: "rpv-bookmark__loader" }, n.createElement(e.Spinner, null));
  }, H = function(B) {
    var P = B.isBookmarkExpanded, S = B.renderBookmarkItem, r = B.store, u = n.useState(r.get("doc")), m = u[0], s = u[1], w = function(i) {
      s(i);
    };
    return n.useEffect(function() {
      return r.subscribe("doc", w), function() {
        r.unsubscribe("doc", w);
      };
    }, []), m ? n.createElement(N, { doc: m, isBookmarkExpanded: P, renderBookmarkItem: S, store: r }) : n.createElement("div", { className: "rpv-bookmark__loader" }, n.createElement(e.Spinner, null));
  };
  return bookmark_min.DownArrowIcon = l, bookmark_min.RightArrowIcon = W, bookmark_min.bookmarkPlugin = function() {
    var B = n.useMemo(function() {
      return e.createStore({ bookmarkExpandedMap: /* @__PURE__ */ new Map() });
    }, []);
    return { install: function(P) {
      B.update("jumpToDestination", P.jumpToDestination);
    }, onDocumentLoad: function(P) {
      B.update("doc", P.doc);
    }, Bookmarks: function(P) {
      return n.createElement(H, { isBookmarkExpanded: P == null ? void 0 : P.isBookmarkExpanded, renderBookmarkItem: P == null ? void 0 : P.renderBookmarkItem, store: B });
    } };
  }, bookmark_min;
}
var bookmark = {}, hasRequiredBookmark;
function requireBookmark() {
  if (hasRequiredBookmark) return bookmark;
  hasRequiredBookmark = 1;
  var e = requireLib$h(), L = requireReact();
  function p(r) {
    var u = /* @__PURE__ */ Object.create(null);
    return r && Object.keys(r).forEach(function(m) {
      if (m !== "default") {
        var s = Object.getOwnPropertyDescriptor(r, m);
        Object.defineProperty(u, m, s.get ? s : {
          enumerable: !0,
          get: function() {
            return r[m];
          }
        });
      }
    }), u.default = r, Object.freeze(u);
  }
  var n = /* @__PURE__ */ p(L), t = function() {
    return t = Object.assign || function(u) {
      for (var m, s = 1, w = arguments.length; s < w; s++) {
        m = arguments[s];
        for (var i in m) Object.prototype.hasOwnProperty.call(m, i) && (u[i] = m[i]);
      }
      return u;
    }, t.apply(this, arguments);
  }, l = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: "M6.427,8.245A.5.5,0,0,1,6.862,7.5H17.138a.5.5,0,0,1,.435.749l-5.139,9a.5.5,0,0,1-.868,0Z" })
    );
  }, W = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: "M9.248,17.572a.5.5,0,0,1-.748-.434V6.862a.5.5,0,0,1,.748-.434l8.992,5.138a.5.5,0,0,1,0,.868Z" })
    );
  }, Q = function(r) {
    var u = r.count, m = r.items;
    if (u >= 0)
      return !1;
    var s = m.length;
    if (s === 0)
      return !1;
    for (var w = m.concat([]); w.length > 0; ) {
      var i = w.shift(), o = i.items;
      i.count && o && i.count > 0 && o.length > 0 && (s += o.length, w = w.concat(o));
    }
    return Math.abs(u) === s;
  }, G = function(r) {
    var u = r.bookmark, m = r.depth, s = r.doc, w = r.index, i = r.isBookmarkExpanded, o = r.numberOfSiblings, b = r.pathFromRoot, g = r.renderBookmarkItem, c = r.store, v = b ? "".concat(b, ".").concat(w) : "".concat(w), k = n.useMemo(function() {
      return Q(u);
    }, [u]), a = c.get("bookmarkExpandedMap"), f = i ? i({ bookmark: u, doc: s, depth: m, index: w }) : a.has(v) ? a.get(v) : !k, C = n.useState(f), R = C[0], M = C[1], I = u.items && u.items.length > 0, E = function() {
      var _ = !R;
      c.updateCurrentValue("bookmarkExpandedMap", function(F) {
        return F.set(v, _);
      }), M(_);
    }, T = function() {
      var _ = u.dest, F = c.get("jumpToDestination");
      e.getDestination(s, _).then(function(U) {
        F && F(t({ label: u.title }, U));
      });
    }, y = function() {
      I && u.dest && T();
    }, D = function() {
      !I && u.dest && T();
    }, j = function(_, F) {
      return n.createElement("div", { className: "rpv-bookmark__item", style: {
        paddingLeft: "".concat(m * 1.25, "rem")
      }, onClick: _ }, F);
    }, A = function(_, F) {
      return I ? n.createElement("span", { className: "rpv-bookmark__toggle", "data-testid": "bookmark__toggle-".concat(m, "-").concat(w), onClick: E }, R ? _ : F) : n.createElement("span", { className: "rpv-bookmark__toggle" });
    }, d = function(_) {
      return u.url ? n.createElement("a", { className: "rpv-bookmark__title", href: u.url, rel: "noopener noreferrer nofollow", target: u.newWindow ? "_blank" : "" }, u.title) : n.createElement("div", { className: "rpv-bookmark__title", "aria-label": u.title, onClick: _ }, u.title);
    };
    return n.createElement(
      "li",
      { "aria-expanded": R ? "true" : "false", "aria-label": u.title, "aria-level": m + 1, "aria-posinset": w + 1, "aria-setsize": o, role: "treeitem", tabIndex: -1 },
      g ? g({
        bookmark: u,
        depth: m,
        hasSubItems: I,
        index: w,
        isExpanded: R,
        path: v,
        defaultRenderItem: j,
        defaultRenderTitle: d,
        defaultRenderToggle: A,
        onClickItem: D,
        onClickTitle: y,
        onToggleSubItems: E
      }) : j(D, n.createElement(
        n.Fragment,
        null,
        A(n.createElement(l, null), n.createElement(W, null)),
        d(y)
      )),
      I && R && n.createElement(X, { bookmarks: u.items, depth: m + 1, doc: s, isBookmarkExpanded: i, isRoot: !1, pathFromRoot: v, renderBookmarkItem: g, store: c })
    );
  }, X = function(r) {
    var u = r.bookmarks, m = r.depth, s = m === void 0 ? 0 : m, w = r.doc, i = r.isBookmarkExpanded, o = r.isRoot, b = r.pathFromRoot, g = r.renderBookmarkItem, c = r.store;
    return n.createElement("ul", { className: "rpv-bookmark__list", role: o ? "tree" : "group", tabIndex: -1 }, u.map(function(v, k) {
      return n.createElement(G, { bookmark: v, depth: s, doc: w, index: k, isBookmarkExpanded: i, key: k, numberOfSiblings: u.length, pathFromRoot: b, renderBookmarkItem: g, store: c });
    }));
  }, N;
  (function(r) {
    r[r.Collapse = 0] = "Collapse", r[r.Expand = 1] = "Expand";
  })(N || (N = {}));
  var H = function(r) {
    var u = r.bookmarks, m = r.doc, s = r.isBookmarkExpanded, w = r.renderBookmarkItem, i = r.store, o = n.useRef(), b = function(k) {
      var a = o.current;
      if (!(!a || !(k.target instanceof HTMLElement) || !a.contains(k.target)))
        switch (k.key) {
          case "ArrowDown":
            k.preventDefault(), c(function(f, C) {
              return f.indexOf(C) + 1;
            });
            break;
          case "ArrowLeft":
            k.preventDefault(), v(N.Collapse);
            break;
          case "ArrowRight":
            k.preventDefault(), v(N.Expand);
            break;
          case "ArrowUp":
            k.preventDefault, c(function(f, C) {
              return f.indexOf(C) - 1;
            });
            break;
          case "End":
            k.preventDefault(), c(function(f, C) {
              return f.length - 1;
            });
            break;
          case " ":
          case "Enter":
          case "Space":
            k.preventDefault(), g();
            break;
          case "Home":
            k.preventDefault(), c(function(f, C) {
              return 0;
            });
            break;
        }
    }, g = function() {
      var k = document.activeElement.closest(".rpv-bookmark__item"), a = k.querySelector(".rpv-bookmark__title");
      a && a.click();
    }, c = function(k) {
      var a = o.current, f = [].slice.call(a.getElementsByClassName("rpv-bookmark__item"));
      if (f.length !== 0) {
        var C = document.activeElement, R = Math.min(f.length - 1, Math.max(0, k(f, C))), M = f[R];
        C.setAttribute("tabindex", "-1"), M.setAttribute("tabindex", "0"), M.focus();
      }
    }, v = function(k) {
      var a = o.current, f = [].slice.call(a.getElementsByClassName("rpv-bookmark__item"));
      if (f.length !== 0) {
        var C = document.activeElement.closest(".rpv-bookmark__item"), R = k === N.Collapse ? "true" : "false";
        if (C && C.parentElement.getAttribute("aria-expanded") === R) {
          var M = C.querySelector(".rpv-bookmark__toggle");
          M && M.click();
        }
      }
    };
    return n.useEffect(function() {
      return document.addEventListener("keydown", b), function() {
        document.removeEventListener("keydown", b);
      };
    }, []), n.useEffect(function() {
      var k = o.current;
      if (k) {
        var a = [].slice.call(k.getElementsByClassName("rpv-bookmark__item"));
        a.length > 0 && (a[0].focus(), a[0].setAttribute("tabindex", "0"));
      }
    }, []), n.createElement(
      "div",
      { ref: o },
      n.createElement(X, { bookmarks: u, depth: 0, doc: m, isBookmarkExpanded: s, isRoot: !0, pathFromRoot: "", renderBookmarkItem: w, store: i })
    );
  }, B = function(r) {
    var u = r.doc, m = r.isBookmarkExpanded, s = r.renderBookmarkItem, w = r.store, i = n.useContext(e.LocalizationContext).l10n, o = n.useContext(e.ThemeContext).direction, b = o === e.TextDirection.RightToLeft, g = n.useState({
      isLoaded: !1,
      items: []
    }), c = g[0], v = g[1];
    return n.useEffect(function() {
      v({
        isLoaded: !1,
        items: []
      }), u.getOutline().then(function(k) {
        v({
          isLoaded: !0,
          items: k || []
        });
      });
    }, [u]), c.isLoaded ? c.items.length === 0 ? n.createElement("div", { "data-testid": "bookmark__empty", className: e.classNames({
      "rpv-bookmark__empty": !0,
      "rpv-bookmark__empty--rtl": b
    }) }, i && i.bookmark ? i.bookmark.noBookmark : "There is no bookmark") : n.createElement(
      "div",
      { "data-testid": "bookmark__container", className: e.classNames({
        "rpv-bookmark__container": !0,
        "rpv-bookmark__container--rtl": b
      }) },
      n.createElement(H, { bookmarks: c.items, doc: u, isBookmarkExpanded: m, renderBookmarkItem: s, store: w })
    ) : n.createElement(
      "div",
      { className: "rpv-bookmark__loader" },
      n.createElement(e.Spinner, null)
    );
  }, P = function(r) {
    var u = r.isBookmarkExpanded, m = r.renderBookmarkItem, s = r.store, w = n.useState(s.get("doc")), i = w[0], o = w[1], b = function(g) {
      o(g);
    };
    return n.useEffect(function() {
      return s.subscribe("doc", b), function() {
        s.unsubscribe("doc", b);
      };
    }, []), i ? n.createElement(B, { doc: i, isBookmarkExpanded: u, renderBookmarkItem: m, store: s }) : n.createElement(
      "div",
      { className: "rpv-bookmark__loader" },
      n.createElement(e.Spinner, null)
    );
  }, S = function() {
    var r = n.useMemo(function() {
      return e.createStore({
        bookmarkExpandedMap: /* @__PURE__ */ new Map()
      });
    }, []), u = function(m) {
      return n.createElement(P, { isBookmarkExpanded: m == null ? void 0 : m.isBookmarkExpanded, renderBookmarkItem: m == null ? void 0 : m.renderBookmarkItem, store: r });
    };
    return {
      install: function(m) {
        r.update("jumpToDestination", m.jumpToDestination);
      },
      onDocumentLoad: function(m) {
        r.update("doc", m.doc);
      },
      Bookmarks: u
    };
  };
  return bookmark.DownArrowIcon = l, bookmark.RightArrowIcon = W, bookmark.bookmarkPlugin = S, bookmark;
}
var hasRequiredLib$f;
function requireLib$f() {
  if (hasRequiredLib$f) return lib$e.exports;
  hasRequiredLib$f = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$e.exports = requireBookmark_min() : lib$e.exports = requireBookmark(), lib$e.exports;
}
var lib$d = { exports: {} }, thumbnail_min = {}, hasRequiredThumbnail_min;
function requireThumbnail_min() {
  return hasRequiredThumbnail_min || (hasRequiredThumbnail_min = 1, function(e) {
    var L = requireLib$h();
    function p(r) {
      var u = /* @__PURE__ */ Object.create(null);
      return r && Object.keys(r).forEach(function(m) {
        if (m !== "default") {
          var s = Object.getOwnPropertyDescriptor(r, m);
          Object.defineProperty(u, m, s.get ? s : { enumerable: !0, get: function() {
            return r[m];
          } });
        }
      }), u.default = r, Object.freeze(u);
    }
    var n, t = p(requireReact());
    e.ThumbnailDirection = void 0, (n = e.ThumbnailDirection || (e.ThumbnailDirection = {})).Horizontal = "Horizontal", n.Vertical = "Vertical";
    var l = function() {
      return l = Object.assign || function(r) {
        for (var u, m = 1, s = arguments.length; m < s; m++) for (var w in u = arguments[m]) Object.prototype.hasOwnProperty.call(u, w) && (r[w] = u[w]);
        return r;
      }, l.apply(this, arguments);
    }, W = function(r) {
      var u = r.doc, m = r.getPageIndex, s = r.renderSpinner, w = r.store, i = r.width, o = u.numPages, b = m ? m({ numPages: o }) : 0, g = Math.max(0, Math.min(b, o - 1)), c = w.get("pagesRotation") || /* @__PURE__ */ new Map(), v = c.has(g) ? c.get(g) : 0, k = t.useState(""), a = k[0], f = k[1], C = L.useIsMounted(), R = t.useRef(), M = t.useState(w.get("rotation") || 0), I = M[0], E = M[1], T = t.useState(v), y = T[0], D = T[1], j = t.useState(!1), A = j[0], d = j[1], _ = function(V) {
        var $ = V.has(g) ? V.get(g) : 0;
        D($);
      }, F = function(V) {
        E(V);
      }, U = L.useIntersectionObserver({ onVisibilityChanged: function(V) {
        d(V.isVisible);
      } });
      return t.useEffect(function() {
        if (A) {
          var V = U.current;
          V && (f(""), L.getPage(u, g).then(function($) {
            var re = $.getViewport({ scale: 1 }), ge = (re.rotation + I + y) % 360, be = Math.abs(I + y) % 180 == 0, le = be ? re.width : re.height, fe = be ? re.height : re.width, Ae = document.createElement("canvas"), qe = Ae.getContext("2d", { alpha: !1 }), ye = V.clientWidth, ce = V.clientHeight, q = i ? i / le : Math.min(ye / le, ce / fe), Z = q * le, pe = q * fe;
            Ae.height = pe, Ae.width = Z, Ae.style.opacity = "0";
            var me = $.getViewport({ rotation: ge, scale: q });
            R.current = $.render({ canvasContext: qe, viewport: me }), R.current.promise.then(function() {
              C.current && f(Ae.toDataURL()), Ae.width = 0, Ae.height = 0;
            }, function() {
            });
          }));
        }
      }, [y, A]), t.useEffect(function() {
        return w.subscribe("pagesRotation", _), w.subscribe("rotation", F), function() {
          w.unsubscribe("pagesRotation", _), w.unsubscribe("rotation", F);
        };
      }, []), t.useEffect(function() {
        return function() {
          var V;
          (V = R.current) === null || V === void 0 || V.cancel();
        };
      }, []), t.createElement("div", { ref: U, className: "rpv-thumbnail__cover-inner", "data-testid": "thumbnail__cover-inner" }, a ? t.createElement("img", { className: "rpv-thumbnail__cover-image", "data-testid": "thumbnail__cover-image", src: a }) : t.createElement("div", { className: "rpv-thumbnail__cover-loader", "data-testid": "thumbnail__cover-loader" }, s ? s() : t.createElement(L.Spinner, null)));
    }, Q = function(r) {
      var u = r.getPageIndex, m = r.renderSpinner, s = r.store, w = r.width, i = t.useState(s.get("doc")), o = i[0], b = i[1], g = function(c) {
        b(c);
      };
      return t.useEffect(function() {
        return s.subscribe("doc", g), function() {
          s.unsubscribe("doc", g);
        };
      }, []), t.createElement("div", { className: "rpv-thumbnail__cover" }, o ? t.createElement(W, { doc: o, getPageIndex: u, renderSpinner: m, store: s, width: w }) : t.createElement("div", { className: "rpv-thumbnail__cover-loader" }, m ? m() : t.createElement(L.Spinner, null)));
    }, G = function() {
      return t.createElement(L.Spinner, null);
    }, X = t.createContext({ renderSpinner: G }), N = function(r) {
      var u = r.children, m = r.doc, s = L.useIsMounted(), w = t.useState({ loading: !0, labels: [] }), i = w[0], o = w[1];
      return t.useEffect(function() {
        m.getPageLabels().then(function(b) {
          s.current && o({ loading: !1, labels: b || [] });
        });
      }, [m.loadingTask.docId]), i.loading ? t.createElement(t.Fragment, null) : u(i.labels);
    }, H = function(r) {
      var u = r.page, m = r.pageHeight, s = r.pageIndex, w = r.pageWidth, i = r.rotation, o = r.thumbnailHeight, b = r.thumbnailWidth, g = r.onRenderCompleted, c = t.useContext(L.LocalizationContext).l10n, v = t.useRef(), k = t.useState(""), a = k[0], f = k[1], C = c && c.thumbnail ? c.thumbnail.thumbnailLabel : "Thumbnail of page {{pageIndex}}";
      return t.useEffect(function() {
        var R = v.current;
        R && R.cancel();
        var M = document.createElement("canvas"), I = M.getContext("2d", { alpha: !1 }), E = b, T = E / (w / m), y = E / w;
        M.height = T, M.width = E, M.style.height = "".concat(T, "px"), M.style.width = "".concat(E, "px");
        var D = u.getViewport({ rotation: i, scale: y });
        return v.current = u.render({ canvasContext: I, viewport: D }), v.current.promise.then(function() {
          f(M.toDataURL()), g(s);
        }, function() {
          g(s);
        }), function() {
          var j;
          (j = v.current) === null || j === void 0 || j.cancel();
        };
      }, [i]), a ? t.createElement("img", { "aria-label": C.replace("{{pageIndex}}", "".concat(s + 1)), src: a, height: "".concat(o, "px"), width: "".concat(b, "px") }) : t.useContext(X).renderSpinner();
    }, B = function(r) {
      var u = r.doc, m = r.pageHeight, s = r.pageIndex, w = r.pageRotation, i = r.pageWidth, o = r.rotation, b = r.shouldRender, g = r.thumbnailWidth, c = r.onRenderCompleted, v = r.onVisibilityChanged, k = L.useIsMounted(), a = t.useState({ height: m, page: null, viewportRotation: 0, width: i }), f = a[0], C = a[1], R = f.page, M = f.height, I = f.width, E = I / M, T = Math.abs(o + w) % 180 == 0, y = T ? g : g / E, D = T ? g / E : g;
      t.useEffect(function() {
        b && L.getPage(u, s).then(function(d) {
          var _ = d.getViewport({ scale: 1 });
          k.current && C({ height: _.height, page: d, viewportRotation: _.rotation, width: _.width });
        });
      }, [b]);
      var j = (f.viewportRotation + o + w) % 360, A = L.useIntersectionObserver({ onVisibilityChanged: function(d) {
        v(s, d);
      } });
      return t.createElement("div", { className: "rpv-thumbnail__container", "data-testid": "thumbnail__container-".concat(s), ref: A, style: { height: "".concat(D, "px"), width: "".concat(y, "px") } }, R ? t.createElement(H, { page: R, pageHeight: T ? M : I, pageIndex: s, pageWidth: T ? I : M, rotation: j, thumbnailHeight: D, thumbnailWidth: y, onRenderCompleted: c }) : t.useContext(X).renderSpinner());
    }, P = function(r) {
      var u = r.currentPage, m = r.doc, s = r.labels, w = r.pagesRotation, i = r.pageHeight, o = r.pageWidth, b = r.renderCurrentPageLabel, g = r.renderThumbnailItem, c = r.rotatedPage, v = r.rotation, k = r.thumbnailDirection, a = r.thumbnailWidth, f = r.viewMode, C = r.onJumpToPage, R = r.onRotatePage, M = m.numPages, I = m.loadingTask.docId, E = t.useRef(null), T = t.useRef([]), y = t.useState(u), D = y[0], j = y[1], A = t.useContext(L.ThemeContext).direction === L.TextDirection.RightToLeft, d = t.useState(-1), _ = d[0], F = d[1], U = L.useIsMounted(), V = L.usePrevious(f), $ = t.useRef(!1), re = L.useRenderQueue({ doc: m }), ge = t.useMemo(function() {
        return Array(M).fill(0).map(function(q, Z) {
          return Z;
        });
      }, [I]), be = t.useMemo(function() {
        switch (f) {
          case L.ViewMode.DualPage:
            return L.chunk(ge, 2);
          case L.ViewMode.DualPageWithCover:
            return [[ge[0]]].concat(L.chunk(ge.slice(1), 2));
          case L.ViewMode.SinglePage:
          default:
            return L.chunk(ge, 1);
        }
      }, [I, f]), le = function() {
        if (E.current) {
          var q = T.current, Z = D + 1;
          Z < q.length && (D >= 0 && q[D].setAttribute("tabindex", "-1"), j(Z));
        }
      }, fe = function() {
        if (E.current) {
          var q = T.current, Z = D - 1;
          Z >= 0 && (D >= 0 && q[D].setAttribute("tabindex", "-1"), j(Z));
        }
      }, Ae = function() {
        D >= 0 && D < M && C(D);
      };
      L.useIsomorphicLayoutEffect(function() {
        var q = E.current;
        q && (T.current = Array.from(q.querySelectorAll(".rpv-thumbnail__item")));
      }, [f]), t.useEffect(function() {
        var q = T.current;
        if (!(q.length === 0 || D < 0 || D > q.length)) {
          var Z = q[D];
          Z.setAttribute("tabindex", "0"), Z.focus();
        }
      }, [D]), L.useIsomorphicLayoutEffect(function() {
        var q = E.current, Z = T.current;
        if (!(!q || Z.length === 0 || u < 0 || u > Z.length)) {
          var pe = Z[u].closest(".rpv-thumbnail__items");
          pe && (k === e.ThumbnailDirection.Vertical ? function(me, _e) {
            var Be = me.getBoundingClientRect().top - _e.getBoundingClientRect().top, ke = me.clientHeight, de = _e.clientHeight;
            Be < 0 ? _e.scrollTop += Be : Be + ke <= de || (_e.scrollTop += Be + ke - de);
          }(pe, q) : function(me, _e) {
            var Be = me.getBoundingClientRect().left - _e.getBoundingClientRect().left, ke = me.clientWidth, de = _e.clientWidth;
            Be < 0 ? _e.scrollLeft += Be : Be + ke <= de || (_e.scrollLeft += Be + ke - de);
          }(pe, q));
        }
      }, [u, k]);
      var qe = t.useCallback(function(q) {
        U.current && (re.markRendered(q), $.current = !1, ce());
      }, [I]), ye = t.useCallback(function(q, Z) {
        Z.isVisible ? re.setVisibility(q, Z.ratio) : re.setOutOfRange(q), ce();
      }, [I]), ce = t.useCallback(function() {
        if (!$.current) {
          var q = re.getHighestPriorityPage();
          q > -1 && (re.markRendering(q), $.current = !0, F(q));
        }
      }, [I]);
      return t.useEffect(function() {
        c >= 0 && (re.markRendering(c), $.current = !0, F(c));
      }, [I, c]), L.useIsomorphicLayoutEffect(function() {
        V !== f && (re.markNotRendered(), ce());
      }, [f]), t.createElement("div", { ref: E, "data-testid": "thumbnail__list", className: L.classNames({ "rpv-thumbnail__list": !0, "rpv-thumbnail__list--horizontal": k === e.ThumbnailDirection.Horizontal, "rpv-thumbnail__list--rtl": A, "rpv-thumbnail__list--vertical": k === e.ThumbnailDirection.Vertical }), onKeyDown: function(q) {
        switch (q.key) {
          case "ArrowDown":
            le();
            break;
          case "ArrowUp":
            fe();
            break;
          case "Enter":
            Ae();
        }
      } }, be.map(function(q, Z) {
        var pe = !1;
        switch (f) {
          case L.ViewMode.DualPage:
            pe = u === 2 * Z || u === 2 * Z + 1;
            break;
          case L.ViewMode.DualPageWithCover:
            pe = u === 0 && Z === 0 || Z > 0 && u === 2 * Z - 1 || Z > 0 && u === 2 * Z;
            break;
          case L.ViewMode.SinglePage:
          default:
            pe = u === Z;
        }
        return t.createElement("div", { className: L.classNames({ "rpv-thumbnail__items": !0, "rpv-thumbnail__items--dual": f === L.ViewMode.DualPage, "rpv-thumbnail__items--dual-cover": f === L.ViewMode.DualPageWithCover, "rpv-thumbnail__items--single": f === L.ViewMode.SinglePage, "rpv-thumbnail__items--selected": pe }), key: "".concat(Z, "___").concat(f) }, q.map(function(me) {
          return function(_e) {
            var Be = f === L.ViewMode.DualPageWithCover && (_e === 0 || M % 2 == 0 && _e === M - 1), ke = "".concat(m.loadingTask.docId, "___").concat(_e), de = s.length === M ? s[_e] : "".concat(_e + 1), $e = b ? b({ currentPage: u, pageIndex: _e, numPages: M, pageLabel: de }) : de, Ge = w.has(_e) ? w.get(_e) : 0, st = t.createElement(B, { doc: m, pageHeight: i, pageIndex: _e, pageRotation: Ge, pageWidth: o, rotation: v, shouldRender: _ === _e, thumbnailWidth: a, onRenderCompleted: qe, onVisibilityChanged: ye });
            return g ? g({ currentPage: u, key: ke, numPages: M, pageIndex: _e, renderPageLabel: t.createElement(t.Fragment, null, $e), renderPageThumbnail: st, onJumpToPage: function() {
              return C(_e);
            }, onRotatePage: function(it) {
              return R(_e, it);
            } }) : t.createElement("div", { key: ke }, t.createElement("div", { className: L.classNames({ "rpv-thumbnail__item": !0, "rpv-thumbnail__item--dual-even": f === L.ViewMode.DualPage && _e % 2 == 0, "rpv-thumbnail__item--dual-odd": f === L.ViewMode.DualPage && _e % 2 == 1, "rpv-thumbnail__item--dual-cover": Be, "rpv-thumbnail__item--dual-cover-even": f === L.ViewMode.DualPageWithCover && !Be && _e % 2 == 0, "rpv-thumbnail__item--dual-cover-odd": f === L.ViewMode.DualPageWithCover && !Be && _e % 2 == 1, "rpv-thumbnail__item--single": f === L.ViewMode.SinglePage, "rpv-thumbnail__item--selected": u === _e }), role: "button", tabIndex: u === _e ? 0 : -1, onClick: function() {
              return C(_e);
            } }, st), t.createElement("div", { "data-testid": "thumbnail__label-".concat(_e), className: "rpv-thumbnail__label" }, $e));
          }(me);
        }));
      }));
    }, S = function(r) {
      var u = r.renderCurrentPageLabel, m = r.renderThumbnailItem, s = r.store, w = r.thumbnailDirection, i = r.thumbnailWidth, o = t.useState(s.get("doc")), b = o[0], g = o[1], c = t.useState(s.get("currentPage") || 0), v = c[0], k = c[1], a = t.useState(s.get("pageHeight") || 0), f = a[0], C = a[1], R = t.useState(s.get("pageWidth") || 0), M = R[0], I = R[1], E = t.useState(s.get("rotation") || 0), T = E[0], y = E[1], D = t.useState(s.get("pagesRotation") || /* @__PURE__ */ new Map()), j = D[0], A = D[1], d = t.useState(s.get("rotatedPage") || -1), _ = d[0], F = d[1], U = t.useState(s.get("viewMode")), V = U[0], $ = U[1], re = function(Z) {
        k(Z);
      }, ge = function(Z) {
        g(Z);
      }, be = function(Z) {
        C(Z);
      }, le = function(Z) {
        I(Z);
      }, fe = function(Z) {
        y(Z);
      }, Ae = function(Z) {
        A(Z);
      }, qe = function(Z) {
        F(Z);
      }, ye = function(Z) {
        $(Z);
      }, ce = function(Z) {
        var pe = s.get("jumpToPage");
        pe && pe(Z);
      }, q = function(Z, pe) {
        s.get("rotatePage")(Z, pe);
      };
      return t.useEffect(function() {
        return s.subscribe("doc", ge), s.subscribe("pageHeight", be), s.subscribe("pageWidth", le), s.subscribe("rotatedPage", qe), s.subscribe("rotation", fe), s.subscribe("pagesRotation", Ae), s.subscribe("viewMode", ye), function() {
          s.unsubscribe("doc", ge), s.unsubscribe("pageHeight", be), s.unsubscribe("pageWidth", le), s.unsubscribe("rotatedPage", qe), s.unsubscribe("rotation", fe), s.unsubscribe("pagesRotation", Ae), s.unsubscribe("viewMode", ye);
        };
      }, []), L.useIsomorphicLayoutEffect(function() {
        return s.subscribe("currentPage", re), function() {
          s.unsubscribe("currentPage", re);
        };
      }, []), b ? t.createElement(L.LazyRender, { testId: "thumbnail__list-container", attrs: { className: "rpv-thumbnail__list-container" } }, t.createElement(N, { doc: b }, function(Z) {
        return t.createElement(P, { currentPage: v, doc: b, labels: Z, pagesRotation: j, pageHeight: f, pageWidth: M, renderCurrentPageLabel: u, renderThumbnailItem: m, rotatedPage: _, rotation: T, thumbnailDirection: w, thumbnailWidth: i, viewMode: V, onJumpToPage: ce, onRotatePage: q });
      })) : t.createElement("div", { "data-testid": "thumbnail-list__loader", className: "rpv-thumbnail__loader" }, t.useContext(X).renderSpinner());
    };
    e.thumbnailPlugin = function(r) {
      var u = t.useMemo(function() {
        return L.createStore({ rotatePage: function() {
        }, viewMode: L.ViewMode.SinglePage });
      }, []), m = t.useState(""), s = m[0], w = m[1];
      return { install: function(i) {
        u.update("jumpToPage", i.jumpToPage), u.update("rotatePage", i.rotatePage);
      }, onDocumentLoad: function(i) {
        w(i.doc.loadingTask.docId), u.update("doc", i.doc);
      }, onViewerStateChange: function(i) {
        return u.update("currentPage", i.pageIndex), u.update("pagesRotation", i.pagesRotation), u.update("pageHeight", i.pageHeight), u.update("pageWidth", i.pageWidth), u.update("rotation", i.rotation), u.update("rotatedPage", i.rotatedPage), u.update("viewMode", i.viewMode), i;
      }, Cover: function(i) {
        return t.createElement(Q, l({}, i, { renderSpinner: r == null ? void 0 : r.renderSpinner, store: u }));
      }, Thumbnails: t.useCallback(function(i) {
        return t.createElement(X.Provider, { value: { renderSpinner: (r == null ? void 0 : r.renderSpinner) || G } }, t.createElement(S, { renderCurrentPageLabel: r == null ? void 0 : r.renderCurrentPageLabel, renderThumbnailItem: i == null ? void 0 : i.renderThumbnailItem, store: u, thumbnailDirection: (i == null ? void 0 : i.thumbnailDirection) || e.ThumbnailDirection.Vertical, thumbnailWidth: (r == null ? void 0 : r.thumbnailWidth) || 100 }));
      }, [s]) };
    };
  }(thumbnail_min)), thumbnail_min;
}
var thumbnail = {}, hasRequiredThumbnail;
function requireThumbnail() {
  return hasRequiredThumbnail || (hasRequiredThumbnail = 1, function(e) {
    var L = requireLib$h(), p = requireReact();
    function n(s) {
      var w = /* @__PURE__ */ Object.create(null);
      return s && Object.keys(s).forEach(function(i) {
        if (i !== "default") {
          var o = Object.getOwnPropertyDescriptor(s, i);
          Object.defineProperty(w, i, o.get ? o : {
            enumerable: !0,
            get: function() {
              return s[i];
            }
          });
        }
      }), w.default = s, Object.freeze(w);
    }
    var t = /* @__PURE__ */ n(p);
    e.ThumbnailDirection = void 0, function(s) {
      s.Horizontal = "Horizontal", s.Vertical = "Vertical";
    }(e.ThumbnailDirection || (e.ThumbnailDirection = {}));
    var l = function() {
      return l = Object.assign || function(w) {
        for (var i, o = 1, b = arguments.length; o < b; o++) {
          i = arguments[o];
          for (var g in i) Object.prototype.hasOwnProperty.call(i, g) && (w[g] = i[g]);
        }
        return w;
      }, l.apply(this, arguments);
    }, W = function(s) {
      var w = s.doc, i = s.getPageIndex, o = s.renderSpinner, b = s.store, g = s.width, c = w.numPages, v = i ? i({ numPages: c }) : 0, k = Math.max(0, Math.min(v, c - 1)), a = b.get("pagesRotation") || /* @__PURE__ */ new Map(), f = a.has(k) ? a.get(k) : 0, C = t.useState(""), R = C[0], M = C[1], I = L.useIsMounted(), E = t.useRef(), T = t.useState(b.get("rotation") || 0), y = T[0], D = T[1], j = t.useState(f), A = j[0], d = j[1], _ = t.useState(!1), F = _[0], U = _[1], V = function(be) {
        var le = be.has(k) ? be.get(k) : 0;
        d(le);
      }, $ = function(be) {
        D(be);
      }, re = function(be) {
        U(be.isVisible);
      }, ge = L.useIntersectionObserver({
        onVisibilityChanged: re
      });
      return t.useEffect(function() {
        if (F) {
          var be = ge.current;
          be && (M(""), L.getPage(w, k).then(function(le) {
            var fe = le.getViewport({ scale: 1 }), Ae = fe.rotation, qe = (Ae + y + A) % 360, ye = Math.abs(y + A) % 180 === 0, ce = ye ? fe.width : fe.height, q = ye ? fe.height : fe.width, Z = document.createElement("canvas"), pe = Z.getContext("2d", { alpha: !1 }), me = be.clientWidth, _e = be.clientHeight, Be = g ? g / ce : Math.min(me / ce, _e / q), ke = Be * ce, de = Be * q;
            Z.height = de, Z.width = ke, Z.style.opacity = "0";
            var $e = le.getViewport({
              rotation: qe,
              scale: Be
            });
            E.current = le.render({ canvasContext: pe, viewport: $e }), E.current.promise.then(function() {
              I.current && M(Z.toDataURL()), Z.width = 0, Z.height = 0;
            }, function() {
            });
          }));
        }
      }, [A, F]), t.useEffect(function() {
        return b.subscribe("pagesRotation", V), b.subscribe("rotation", $), function() {
          b.unsubscribe("pagesRotation", V), b.unsubscribe("rotation", $);
        };
      }, []), t.useEffect(function() {
        return function() {
          var be;
          (be = E.current) === null || be === void 0 || be.cancel();
        };
      }, []), t.createElement("div", { ref: ge, className: "rpv-thumbnail__cover-inner", "data-testid": "thumbnail__cover-inner" }, R ? t.createElement("img", { className: "rpv-thumbnail__cover-image", "data-testid": "thumbnail__cover-image", src: R }) : t.createElement("div", { className: "rpv-thumbnail__cover-loader", "data-testid": "thumbnail__cover-loader" }, o ? o() : t.createElement(L.Spinner, null)));
    }, Q = function(s) {
      var w = s.getPageIndex, i = s.renderSpinner, o = s.store, b = s.width, g = t.useState(o.get("doc")), c = g[0], v = g[1], k = function(a) {
        v(a);
      };
      return t.useEffect(function() {
        return o.subscribe("doc", k), function() {
          o.unsubscribe("doc", k);
        };
      }, []), t.createElement("div", { className: "rpv-thumbnail__cover" }, c ? t.createElement(W, { doc: c, getPageIndex: w, renderSpinner: i, store: o, width: b }) : t.createElement("div", { className: "rpv-thumbnail__cover-loader" }, i ? i() : t.createElement(L.Spinner, null)));
    }, G = function() {
      return t.createElement(L.Spinner, null);
    }, X = t.createContext({
      renderSpinner: G
    }), N = function(s) {
      var w = s.children, i = s.doc, o = L.useIsMounted(), b = t.useState({
        loading: !0,
        labels: []
      }), g = b[0], c = b[1];
      return t.useEffect(function() {
        i.getPageLabels().then(function(v) {
          o.current && c({ loading: !1, labels: v || [] });
        });
      }, [i.loadingTask.docId]), g.loading ? t.createElement(t.Fragment, null) : w(g.labels);
    }, H = function(s, w) {
      var i = s.getBoundingClientRect().top - w.getBoundingClientRect().top, o = s.clientHeight, b = w.clientHeight;
      if (i < 0) {
        w.scrollTop += i;
        return;
      }
      i + o <= b || (w.scrollTop += i + o - b);
    }, B = function(s, w) {
      var i = s.getBoundingClientRect().left - w.getBoundingClientRect().left, o = s.clientWidth, b = w.clientWidth;
      if (i < 0) {
        w.scrollLeft += i;
        return;
      }
      i + o <= b || (w.scrollLeft += i + o - b);
    }, P = function(s) {
      var w = s.page, i = s.pageHeight, o = s.pageIndex, b = s.pageWidth, g = s.rotation, c = s.thumbnailHeight, v = s.thumbnailWidth, k = s.onRenderCompleted, a = t.useContext(L.LocalizationContext).l10n, f = t.useRef(), C = t.useState(""), R = C[0], M = C[1], I = a && a.thumbnail ? a.thumbnail.thumbnailLabel : "Thumbnail of page {{pageIndex}}";
      return t.useEffect(function() {
        var E = f.current;
        E && E.cancel();
        var T = document.createElement("canvas"), y = T.getContext("2d", { alpha: !1 }), D = v, j = D / (b / i), A = D / b;
        T.height = j, T.width = D, T.style.height = "".concat(j, "px"), T.style.width = "".concat(D, "px");
        var d = w.getViewport({ rotation: g, scale: A });
        return f.current = w.render({ canvasContext: y, viewport: d }), f.current.promise.then(function() {
          M(T.toDataURL()), k(o);
        }, function() {
          k(o);
        }), function() {
          var _;
          (_ = f.current) === null || _ === void 0 || _.cancel();
        };
      }, [g]), R ? t.createElement("img", { "aria-label": I.replace("{{pageIndex}}", "".concat(o + 1)), src: R, height: "".concat(c, "px"), width: "".concat(v, "px") }) : t.useContext(X).renderSpinner();
    }, S = function(s) {
      var w = s.doc, i = s.pageHeight, o = s.pageIndex, b = s.pageRotation, g = s.pageWidth, c = s.rotation, v = s.shouldRender, k = s.thumbnailWidth, a = s.onRenderCompleted, f = s.onVisibilityChanged, C = L.useIsMounted(), R = t.useState({
        height: i,
        page: null,
        viewportRotation: 0,
        width: g
      }), M = R[0], I = R[1], E = M.page, T = M.height, y = M.width, D = y / T, j = Math.abs(c + b) % 180 === 0, A = j ? k : k / D, d = j ? k / D : k;
      t.useEffect(function() {
        v && L.getPage(w, o).then(function(U) {
          var V = U.getViewport({ scale: 1 });
          C.current && I({
            height: V.height,
            page: U,
            viewportRotation: V.rotation,
            width: V.width
          });
        });
      }, [v]);
      var _ = (M.viewportRotation + c + b) % 360, F = L.useIntersectionObserver({
        onVisibilityChanged: function(U) {
          f(o, U);
        }
      });
      return t.createElement("div", { className: "rpv-thumbnail__container", "data-testid": "thumbnail__container-".concat(o), ref: F, style: {
        height: "".concat(d, "px"),
        width: "".concat(A, "px")
      } }, E ? t.createElement(P, { page: E, pageHeight: j ? T : y, pageIndex: o, pageWidth: j ? y : T, rotation: _, thumbnailHeight: d, thumbnailWidth: A, onRenderCompleted: a }) : t.useContext(X).renderSpinner());
    }, r = function(s) {
      var w = s.currentPage, i = s.doc, o = s.labels, b = s.pagesRotation, g = s.pageHeight, c = s.pageWidth, v = s.renderCurrentPageLabel, k = s.renderThumbnailItem, a = s.rotatedPage, f = s.rotation, C = s.thumbnailDirection, R = s.thumbnailWidth, M = s.viewMode, I = s.onJumpToPage, E = s.onRotatePage, T = i.numPages, y = i.loadingTask.docId, D = t.useRef(null), j = t.useRef([]), A = t.useState(w), d = A[0], _ = A[1], F = t.useContext(L.ThemeContext).direction, U = F === L.TextDirection.RightToLeft, V = t.useState(-1), $ = V[0], re = V[1], ge = L.useIsMounted(), be = L.usePrevious(M), le = t.useRef(!1), fe = L.useRenderQueue({ doc: i }), Ae = t.useMemo(function() {
        return Array(T).fill(0).map(function(ke, de) {
          return de;
        });
      }, [y]), qe = t.useMemo(function() {
        switch (M) {
          case L.ViewMode.DualPage:
            return L.chunk(Ae, 2);
          case L.ViewMode.DualPageWithCover:
            return [[Ae[0]]].concat(L.chunk(Ae.slice(1), 2));
          case L.ViewMode.SinglePage:
          default:
            return L.chunk(Ae, 1);
        }
      }, [y, M]), ye = function(ke) {
        switch (ke.key) {
          case "ArrowDown":
            ce();
            break;
          case "ArrowUp":
            q();
            break;
          case "Enter":
            Z();
            break;
        }
      }, ce = function() {
        var ke = D.current;
        if (ke) {
          var de = j.current, $e = d + 1;
          $e < de.length && (d >= 0 && de[d].setAttribute("tabindex", "-1"), _($e));
        }
      }, q = function() {
        var ke = D.current;
        if (ke) {
          var de = j.current, $e = d - 1;
          $e >= 0 && (d >= 0 && de[d].setAttribute("tabindex", "-1"), _($e));
        }
      }, Z = function() {
        d >= 0 && d < T && I(d);
      };
      L.useIsomorphicLayoutEffect(function() {
        var ke = D.current;
        ke && (j.current = Array.from(ke.querySelectorAll(".rpv-thumbnail__item")));
      }, [M]), t.useEffect(function() {
        var ke = j.current;
        if (!(ke.length === 0 || d < 0 || d > ke.length)) {
          var de = ke[d];
          de.setAttribute("tabindex", "0"), de.focus();
        }
      }, [d]), L.useIsomorphicLayoutEffect(function() {
        var ke = D.current, de = j.current;
        if (!(!ke || de.length === 0 || w < 0 || w > de.length)) {
          var $e = de[w].closest(".rpv-thumbnail__items");
          $e && (C === e.ThumbnailDirection.Vertical ? H($e, ke) : B($e, ke));
        }
      }, [w, C]);
      var pe = t.useCallback(function(ke) {
        ge.current && (fe.markRendered(ke), le.current = !1, _e());
      }, [y]), me = t.useCallback(function(ke, de) {
        de.isVisible ? fe.setVisibility(ke, de.ratio) : fe.setOutOfRange(ke), _e();
      }, [y]), _e = t.useCallback(function() {
        if (!le.current) {
          var ke = fe.getHighestPriorityPage();
          ke > -1 && (fe.markRendering(ke), le.current = !0, re(ke));
        }
      }, [y]);
      t.useEffect(function() {
        a >= 0 && (fe.markRendering(a), le.current = !0, re(a));
      }, [y, a]), L.useIsomorphicLayoutEffect(function() {
        be !== M && (fe.markNotRendered(), _e());
      }, [M]);
      var Be = function(ke) {
        var de = M === L.ViewMode.DualPageWithCover && (ke === 0 || T % 2 === 0 && ke === T - 1), $e = "".concat(i.loadingTask.docId, "___").concat(ke), Ge = o.length === T ? o[ke] : "".concat(ke + 1), st = v ? v({ currentPage: w, pageIndex: ke, numPages: T, pageLabel: Ge }) : Ge, it = b.has(ke) ? b.get(ke) : 0, _t = t.createElement(S, { doc: i, pageHeight: g, pageIndex: ke, pageRotation: it, pageWidth: c, rotation: f, shouldRender: $ === ke, thumbnailWidth: R, onRenderCompleted: pe, onVisibilityChanged: me });
        return k ? k({
          currentPage: w,
          key: $e,
          numPages: T,
          pageIndex: ke,
          renderPageLabel: t.createElement(t.Fragment, null, st),
          renderPageThumbnail: _t,
          onJumpToPage: function() {
            return I(ke);
          },
          onRotatePage: function(tt) {
            return E(ke, tt);
          }
        }) : t.createElement(
          "div",
          { key: $e },
          t.createElement("div", { className: L.classNames({
            "rpv-thumbnail__item": !0,
            "rpv-thumbnail__item--dual-even": M === L.ViewMode.DualPage && ke % 2 === 0,
            "rpv-thumbnail__item--dual-odd": M === L.ViewMode.DualPage && ke % 2 === 1,
            "rpv-thumbnail__item--dual-cover": de,
            "rpv-thumbnail__item--dual-cover-even": M === L.ViewMode.DualPageWithCover && !de && ke % 2 === 0,
            "rpv-thumbnail__item--dual-cover-odd": M === L.ViewMode.DualPageWithCover && !de && ke % 2 === 1,
            "rpv-thumbnail__item--single": M === L.ViewMode.SinglePage,
            "rpv-thumbnail__item--selected": w === ke
          }), role: "button", tabIndex: w === ke ? 0 : -1, onClick: function() {
            return I(ke);
          } }, _t),
          t.createElement("div", { "data-testid": "thumbnail__label-".concat(ke), className: "rpv-thumbnail__label" }, st)
        );
      };
      return t.createElement("div", { ref: D, "data-testid": "thumbnail__list", className: L.classNames({
        "rpv-thumbnail__list": !0,
        "rpv-thumbnail__list--horizontal": C === e.ThumbnailDirection.Horizontal,
        "rpv-thumbnail__list--rtl": U,
        "rpv-thumbnail__list--vertical": C === e.ThumbnailDirection.Vertical
      }), onKeyDown: ye }, qe.map(function(ke, de) {
        var $e = !1;
        switch (M) {
          case L.ViewMode.DualPage:
            $e = w === 2 * de || w === 2 * de + 1;
            break;
          case L.ViewMode.DualPageWithCover:
            $e = w === 0 && de === 0 || de > 0 && w === 2 * de - 1 || de > 0 && w === 2 * de;
            break;
          case L.ViewMode.SinglePage:
          default:
            $e = w === de;
            break;
        }
        return t.createElement("div", { className: L.classNames({
          "rpv-thumbnail__items": !0,
          "rpv-thumbnail__items--dual": M === L.ViewMode.DualPage,
          "rpv-thumbnail__items--dual-cover": M === L.ViewMode.DualPageWithCover,
          "rpv-thumbnail__items--single": M === L.ViewMode.SinglePage,
          "rpv-thumbnail__items--selected": $e
        }), key: "".concat(de, "___").concat(M) }, ke.map(function(Ge) {
          return Be(Ge);
        }));
      }));
    }, u = function(s) {
      var w = s.renderCurrentPageLabel, i = s.renderThumbnailItem, o = s.store, b = s.thumbnailDirection, g = s.thumbnailWidth, c = t.useState(o.get("doc")), v = c[0], k = c[1], a = t.useState(o.get("currentPage") || 0), f = a[0], C = a[1], R = t.useState(o.get("pageHeight") || 0), M = R[0], I = R[1], E = t.useState(o.get("pageWidth") || 0), T = E[0], y = E[1], D = t.useState(o.get("rotation") || 0), j = D[0], A = D[1], d = t.useState(o.get("pagesRotation") || /* @__PURE__ */ new Map()), _ = d[0], F = d[1], U = t.useState(o.get("rotatedPage") || -1), V = U[0], $ = U[1], re = t.useState(o.get("viewMode")), ge = re[0], be = re[1], le = function(_e) {
        C(_e);
      }, fe = function(_e) {
        k(_e);
      }, Ae = function(_e) {
        I(_e);
      }, qe = function(_e) {
        y(_e);
      }, ye = function(_e) {
        A(_e);
      }, ce = function(_e) {
        F(_e);
      }, q = function(_e) {
        $(_e);
      }, Z = function(_e) {
        be(_e);
      }, pe = function(_e) {
        var Be = o.get("jumpToPage");
        Be && Be(_e);
      }, me = function(_e, Be) {
        o.get("rotatePage")(_e, Be);
      };
      return t.useEffect(function() {
        return o.subscribe("doc", fe), o.subscribe("pageHeight", Ae), o.subscribe("pageWidth", qe), o.subscribe("rotatedPage", q), o.subscribe("rotation", ye), o.subscribe("pagesRotation", ce), o.subscribe("viewMode", Z), function() {
          o.unsubscribe("doc", fe), o.unsubscribe("pageHeight", Ae), o.unsubscribe("pageWidth", qe), o.unsubscribe("rotatedPage", q), o.unsubscribe("rotation", ye), o.unsubscribe("pagesRotation", ce), o.unsubscribe("viewMode", Z);
        };
      }, []), L.useIsomorphicLayoutEffect(function() {
        return o.subscribe("currentPage", le), function() {
          o.unsubscribe("currentPage", le);
        };
      }, []), v ? t.createElement(
        L.LazyRender,
        { testId: "thumbnail__list-container", attrs: {
          className: "rpv-thumbnail__list-container"
        } },
        t.createElement(N, { doc: v }, function(_e) {
          return t.createElement(r, { currentPage: f, doc: v, labels: _e, pagesRotation: _, pageHeight: M, pageWidth: T, renderCurrentPageLabel: w, renderThumbnailItem: i, rotatedPage: V, rotation: j, thumbnailDirection: b, thumbnailWidth: g, viewMode: ge, onJumpToPage: pe, onRotatePage: me });
        })
      ) : t.createElement("div", { "data-testid": "thumbnail-list__loader", className: "rpv-thumbnail__loader" }, t.useContext(X).renderSpinner());
    }, m = function(s) {
      var w = t.useMemo(function() {
        return L.createStore({
          rotatePage: function() {
          },
          viewMode: L.ViewMode.SinglePage
        });
      }, []), i = t.useState(""), o = i[0], b = i[1], g = function(v) {
        return t.createElement(Q, l({}, v, { renderSpinner: s == null ? void 0 : s.renderSpinner, store: w }));
      }, c = t.useCallback(function(v) {
        return t.createElement(
          X.Provider,
          { value: { renderSpinner: (s == null ? void 0 : s.renderSpinner) || G } },
          t.createElement(u, { renderCurrentPageLabel: s == null ? void 0 : s.renderCurrentPageLabel, renderThumbnailItem: v == null ? void 0 : v.renderThumbnailItem, store: w, thumbnailDirection: (v == null ? void 0 : v.thumbnailDirection) || e.ThumbnailDirection.Vertical, thumbnailWidth: (s == null ? void 0 : s.thumbnailWidth) || 100 })
        );
      }, [o]);
      return {
        install: function(v) {
          w.update("jumpToPage", v.jumpToPage), w.update("rotatePage", v.rotatePage);
        },
        onDocumentLoad: function(v) {
          b(v.doc.loadingTask.docId), w.update("doc", v.doc);
        },
        onViewerStateChange: function(v) {
          return w.update("currentPage", v.pageIndex), w.update("pagesRotation", v.pagesRotation), w.update("pageHeight", v.pageHeight), w.update("pageWidth", v.pageWidth), w.update("rotation", v.rotation), w.update("rotatedPage", v.rotatedPage), w.update("viewMode", v.viewMode), v;
        },
        Cover: g,
        Thumbnails: c
      };
    };
    e.thumbnailPlugin = m;
  }(thumbnail)), thumbnail;
}
var hasRequiredLib$e;
function requireLib$e() {
  if (hasRequiredLib$e) return lib$d.exports;
  hasRequiredLib$e = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$d.exports = requireThumbnail_min() : lib$d.exports = requireThumbnail(), lib$d.exports;
}
var lib$c = { exports: {} }, toolbar_min = {}, lib$b = { exports: {} }, selectionMode_min = {}, hasRequiredSelectionMode_min;
function requireSelectionMode_min() {
  return hasRequiredSelectionMode_min || (hasRequiredSelectionMode_min = 1, function(e) {
    var L = requireLib$h();
    function p(S) {
      var r = /* @__PURE__ */ Object.create(null);
      return S && Object.keys(S).forEach(function(u) {
        if (u !== "default") {
          var m = Object.getOwnPropertyDescriptor(S, u);
          Object.defineProperty(r, u, m.get ? m : { enumerable: !0, get: function() {
            return S[u];
          } });
        }
      }), r.default = S, Object.freeze(r);
    }
    var n, t = p(requireReact()), l = function() {
      return t.createElement(L.Icon, { size: 16 }, t.createElement("path", { d: `M11.5,5.5v-2C11.5,2.672,12.172,2,13,2s1.5,0.672,1.5,1.5v2 M14.5,11.5v-6C14.5,4.672,15.172,4,16,4
            c0.828,0,1.5,0.672,1.5,1.5v3 M17.5,13V8.5C17.5,7.672,18.172,7,19,7s1.5,0.672,1.5,1.5v10c0,2.761-2.239,5-5,5h-3.335
            c-1.712-0.001-3.305-0.876-4.223-2.321C6.22,18.467,4.083,14,4.083,14c-0.378-0.545-0.242-1.292,0.303-1.67
            c0.446-0.309,1.044-0.281,1.458,0.07L8.5,15.5v-10C8.5,4.672,9.172,4,10,4s1.5,0.672,1.5,1.5v6` }));
    }, W = function() {
      return W = Object.assign || function(S) {
        for (var r, u = 1, m = arguments.length; u < m; u++) for (var s in r = arguments[u]) Object.prototype.hasOwnProperty.call(r, s) && (S[s] = r[s]);
        return S;
      }, W.apply(this, arguments);
    };
    e.SelectionMode = void 0, (n = e.SelectionMode || (e.SelectionMode = {})).Hand = "Hand", n.Text = "Text";
    var Q = function() {
      return t.createElement(L.Icon, { size: 16 }, t.createElement("path", { d: `M13.675,11.671l2.941-2.941c0.195-0.196,0.195-0.512-0.001-0.707C16.563,7.971,16.5,7.931,16.43,7.906
            L4.168,3.527C3.908,3.434,3.622,3.57,3.529,3.83c-0.039,0.109-0.039,0.228,0,0.336l4.379,12.262
            c0.093,0.26,0.379,0.396,0.639,0.303c0.07-0.025,0.133-0.065,0.185-0.117l2.943-2.943l6.146,6.146c0.195,0.195,0.512,0.195,0.707,0
            l1.293-1.293c0.195-0.195,0.195-0.512,0-0.707L13.675,11.671z` }));
    }, G = function(S) {
      var r = S.children, u = S.mode, m = S.onClick, s = t.useContext(L.LocalizationContext).l10n, w = "", i = t.createElement(Q, null);
      switch (u) {
        case e.SelectionMode.Hand:
          w = s && s.selectionMode ? s.selectionMode.handTool : "Hand tool", i = t.createElement(l, null);
          break;
        case e.SelectionMode.Text:
        default:
          w = s && s.selectionMode ? s.selectionMode.textSelectionTool : "Text selection tool", i = t.createElement(Q, null);
      }
      return r({ icon: i, label: w, onClick: m });
    }, X = { left: 0, top: 8 }, N = function(S) {
      var r = S.isSelected, u = S.mode, m = S.onClick, s = "";
      switch (u) {
        case e.SelectionMode.Hand:
          s = "selection-mode__hand-button";
          break;
        case e.SelectionMode.Text:
        default:
          s = "selection-mode__text-button";
      }
      return t.createElement(G, { mode: u, onClick: m }, function(w) {
        return t.createElement(L.Tooltip, { ariaControlsSuffix: "selection-mode-switch", position: L.Position.BottomCenter, target: t.createElement(L.MinimalButton, { ariaLabel: w.label, isSelected: r, testId: s, onClick: w.onClick }, w.icon), content: function() {
          return w.label;
        }, offset: X });
      });
    }, H = function(S) {
      var r = S.children, u = S.mode, m = S.store, s = u === m.get("selectionMode");
      return (r || function(w) {
        return t.createElement(N, { isSelected: s, mode: w.mode, onClick: w.onClick });
      })({ isSelected: s, mode: u, onClick: function() {
        return m.update("selectionMode", u);
      } });
    }, B = function(S) {
      var r = S.isSelected, u = S.mode, m = S.onClick, s = "";
      switch (u) {
        case e.SelectionMode.Hand:
          s = "selection-mode__hand-menu";
          break;
        case e.SelectionMode.Text:
        default:
          s = "selection-mode__text-menu";
      }
      return t.createElement(G, { mode: u, onClick: m }, function(w) {
        return t.createElement(L.MenuItem, { checked: r, icon: w.icon, testId: s, onClick: w.onClick }, w.label);
      });
    }, P = function(S) {
      var r = S.store, u = t.useRef(null), m = t.useState(e.SelectionMode.Text), s = m[0], w = m[1], i = t.useRef({ top: 0, left: 0, x: 0, y: 0 }), o = function(k) {
        var a = u.current;
        a && (a.scrollTop = i.current.top - (k.clientY - i.current.y), a.scrollLeft = i.current.left - (k.clientX - i.current.x));
      }, b = function() {
        var k = u.current;
        k && (k.classList.add("rpv-selection-mode__grab"), k.classList.remove("rpv-selection-mode__grabbing"), document.removeEventListener("mousemove", o), document.removeEventListener("mouseup", b));
      }, g = function(k) {
        var a = u.current;
        a && s !== e.SelectionMode.Text && (a.classList.remove("rpv-selection-mode__grab"), a.classList.add("rpv-selection-mode__grabbing"), k.preventDefault(), k.stopPropagation(), i.current = { left: a.scrollLeft, top: a.scrollTop, x: k.clientX, y: k.clientY }, document.addEventListener("mousemove", o), document.addEventListener("mouseup", b));
      }, c = function(k) {
        u.current = k();
      }, v = function(k) {
        w(k);
      };
      return t.useEffect(function() {
        var k = u.current;
        if (k) return s === e.SelectionMode.Hand ? k.classList.add("rpv-selection-mode__grab") : k.classList.remove("rpv-selection-mode__grab"), k.addEventListener("mousedown", g), function() {
          k.removeEventListener("mousedown", g);
        };
      }, [s]), t.useEffect(function() {
        return r.subscribe("getPagesContainer", c), r.subscribe("selectionMode", v), function() {
          r.unsubscribe("getPagesContainer", c), r.unsubscribe("selectionMode", v);
        };
      }, []), t.createElement(t.Fragment, null);
    };
    e.HandToolIcon = l, e.TextSelectionIcon = Q, e.selectionModePlugin = function(S) {
      var r = t.useMemo(function() {
        return L.createStore();
      }, []), u = function(m) {
        return t.createElement(H, W({}, m, { store: r }));
      };
      return { install: function(m) {
        r.update("selectionMode", S && S.selectionMode ? S.selectionMode : e.SelectionMode.Text), r.update("getPagesContainer", m.getPagesContainer);
      }, renderViewer: function(m) {
        var s = m.slot;
        return s.subSlot && s.subSlot.children && (s.subSlot.children = t.createElement(t.Fragment, null, t.createElement(P, { store: r }), s.subSlot.children)), s;
      }, SwitchSelectionMode: u, SwitchSelectionModeButton: function(m) {
        return t.createElement(u, { mode: m.mode }, function(s) {
          return t.createElement(N, { isSelected: s.isSelected, mode: s.mode, onClick: function() {
            s.onClick();
          } });
        });
      }, SwitchSelectionModeMenuItem: function(m) {
        return t.createElement(u, { mode: m.mode }, function(s) {
          return t.createElement(B, { isSelected: s.isSelected, mode: s.mode, onClick: function() {
            s.onClick(), m.onClick();
          } });
        });
      } };
    };
  }(selectionMode_min)), selectionMode_min;
}
var selectionMode = {}, hasRequiredSelectionMode;
function requireSelectionMode() {
  return hasRequiredSelectionMode || (hasRequiredSelectionMode = 1, function(e) {
    var L = requireLib$h(), p = requireReact();
    function n(r) {
      var u = /* @__PURE__ */ Object.create(null);
      return r && Object.keys(r).forEach(function(m) {
        if (m !== "default") {
          var s = Object.getOwnPropertyDescriptor(r, m);
          Object.defineProperty(u, m, s.get ? s : {
            enumerable: !0,
            get: function() {
              return r[m];
            }
          });
        }
      }), u.default = r, Object.freeze(u);
    }
    var t = /* @__PURE__ */ n(p), l = function() {
      return t.createElement(
        L.Icon,
        { size: 16 },
        t.createElement("path", { d: `M11.5,5.5v-2C11.5,2.672,12.172,2,13,2s1.5,0.672,1.5,1.5v2 M14.5,11.5v-6C14.5,4.672,15.172,4,16,4
            c0.828,0,1.5,0.672,1.5,1.5v3 M17.5,13V8.5C17.5,7.672,18.172,7,19,7s1.5,0.672,1.5,1.5v10c0,2.761-2.239,5-5,5h-3.335
            c-1.712-0.001-3.305-0.876-4.223-2.321C6.22,18.467,4.083,14,4.083,14c-0.378-0.545-0.242-1.292,0.303-1.67
            c0.446-0.309,1.044-0.281,1.458,0.07L8.5,15.5v-10C8.5,4.672,9.172,4,10,4s1.5,0.672,1.5,1.5v6` })
      );
    }, W = function() {
      return W = Object.assign || function(u) {
        for (var m, s = 1, w = arguments.length; s < w; s++) {
          m = arguments[s];
          for (var i in m) Object.prototype.hasOwnProperty.call(m, i) && (u[i] = m[i]);
        }
        return u;
      }, W.apply(this, arguments);
    };
    e.SelectionMode = void 0, function(r) {
      r.Hand = "Hand", r.Text = "Text";
    }(e.SelectionMode || (e.SelectionMode = {}));
    var Q = function() {
      return t.createElement(
        L.Icon,
        { size: 16 },
        t.createElement("path", { d: `M13.675,11.671l2.941-2.941c0.195-0.196,0.195-0.512-0.001-0.707C16.563,7.971,16.5,7.931,16.43,7.906
            L4.168,3.527C3.908,3.434,3.622,3.57,3.529,3.83c-0.039,0.109-0.039,0.228,0,0.336l4.379,12.262
            c0.093,0.26,0.379,0.396,0.639,0.303c0.07-0.025,0.133-0.065,0.185-0.117l2.943-2.943l6.146,6.146c0.195,0.195,0.512,0.195,0.707,0
            l1.293-1.293c0.195-0.195,0.195-0.512,0-0.707L13.675,11.671z` })
      );
    }, G = function(r) {
      var u = r.children, m = r.mode, s = r.onClick, w = t.useContext(L.LocalizationContext).l10n, i = "", o = t.createElement(Q, null);
      switch (m) {
        case e.SelectionMode.Hand:
          i = w && w.selectionMode ? w.selectionMode.handTool : "Hand tool", o = t.createElement(l, null);
          break;
        case e.SelectionMode.Text:
        default:
          i = w && w.selectionMode ? w.selectionMode.textSelectionTool : "Text selection tool", o = t.createElement(Q, null);
          break;
      }
      return u({ icon: o, label: i, onClick: s });
    }, X = { left: 0, top: 8 }, N = function(r) {
      var u = r.isSelected, m = r.mode, s = r.onClick, w = "";
      switch (m) {
        case e.SelectionMode.Hand:
          w = "selection-mode__hand-button";
          break;
        case e.SelectionMode.Text:
        default:
          w = "selection-mode__text-button";
      }
      return t.createElement(G, { mode: m, onClick: s }, function(i) {
        return t.createElement(L.Tooltip, { ariaControlsSuffix: "selection-mode-switch", position: L.Position.BottomCenter, target: t.createElement(L.MinimalButton, { ariaLabel: i.label, isSelected: u, testId: w, onClick: i.onClick }, i.icon), content: function() {
          return i.label;
        }, offset: X });
      });
    }, H = function(r) {
      var u = r.children, m = r.mode, s = r.store, w = function() {
        return s.update("selectionMode", m);
      }, i = m === s.get("selectionMode"), o = function(g) {
        return t.createElement(N, { isSelected: i, mode: g.mode, onClick: g.onClick });
      }, b = u || o;
      return b({
        isSelected: i,
        mode: m,
        onClick: w
      });
    }, B = function(r) {
      var u = r.isSelected, m = r.mode, s = r.onClick, w = "";
      switch (m) {
        case e.SelectionMode.Hand:
          w = "selection-mode__hand-menu";
          break;
        case e.SelectionMode.Text:
        default:
          w = "selection-mode__text-menu";
      }
      return t.createElement(G, { mode: m, onClick: s }, function(i) {
        return t.createElement(L.MenuItem, { checked: u, icon: i.icon, testId: w, onClick: i.onClick }, i.label);
      });
    }, P = function(r) {
      var u = r.store, m = t.useRef(null), s = t.useState(e.SelectionMode.Text), w = s[0], i = s[1], o = t.useRef({ top: 0, left: 0, x: 0, y: 0 }), b = function(a) {
        var f = m.current;
        f && (f.scrollTop = o.current.top - (a.clientY - o.current.y), f.scrollLeft = o.current.left - (a.clientX - o.current.x));
      }, g = function() {
        var a = m.current;
        a && (a.classList.add("rpv-selection-mode__grab"), a.classList.remove("rpv-selection-mode__grabbing"), document.removeEventListener("mousemove", b), document.removeEventListener("mouseup", g));
      }, c = function(a) {
        var f = m.current;
        !f || w === e.SelectionMode.Text || (f.classList.remove("rpv-selection-mode__grab"), f.classList.add("rpv-selection-mode__grabbing"), a.preventDefault(), a.stopPropagation(), o.current = {
          left: f.scrollLeft,
          top: f.scrollTop,
          x: a.clientX,
          y: a.clientY
        }, document.addEventListener("mousemove", b), document.addEventListener("mouseup", g));
      }, v = function(a) {
        m.current = a();
      }, k = function(a) {
        i(a);
      };
      return t.useEffect(function() {
        var a = m.current;
        if (a)
          return w === e.SelectionMode.Hand ? a.classList.add("rpv-selection-mode__grab") : a.classList.remove("rpv-selection-mode__grab"), a.addEventListener("mousedown", c), function() {
            a.removeEventListener("mousedown", c);
          };
      }, [w]), t.useEffect(function() {
        return u.subscribe("getPagesContainer", v), u.subscribe("selectionMode", k), function() {
          u.unsubscribe("getPagesContainer", v), u.unsubscribe("selectionMode", k);
        };
      }, []), t.createElement(t.Fragment, null);
    }, S = function(r) {
      var u = t.useMemo(function() {
        return L.createStore();
      }, []), m = function(o) {
        return t.createElement(H, W({}, o, { store: u }));
      }, s = function(o) {
        return t.createElement(m, { mode: o.mode }, function(b) {
          return t.createElement(N, { isSelected: b.isSelected, mode: b.mode, onClick: function() {
            b.onClick();
          } });
        });
      }, w = function(o) {
        return t.createElement(m, { mode: o.mode }, function(b) {
          return t.createElement(B, { isSelected: b.isSelected, mode: b.mode, onClick: function() {
            b.onClick(), o.onClick();
          } });
        });
      }, i = function(o) {
        var b = o.slot;
        return b.subSlot && b.subSlot.children && (b.subSlot.children = t.createElement(
          t.Fragment,
          null,
          t.createElement(P, { store: u }),
          b.subSlot.children
        )), b;
      };
      return {
        install: function(o) {
          u.update("selectionMode", r && r.selectionMode ? r.selectionMode : e.SelectionMode.Text), u.update("getPagesContainer", o.getPagesContainer);
        },
        renderViewer: i,
        SwitchSelectionMode: m,
        SwitchSelectionModeButton: s,
        SwitchSelectionModeMenuItem: w
      };
    };
    e.HandToolIcon = l, e.TextSelectionIcon = Q, e.selectionModePlugin = S;
  }(selectionMode)), selectionMode;
}
var hasRequiredLib$d;
function requireLib$d() {
  if (hasRequiredLib$d) return lib$b.exports;
  hasRequiredLib$d = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$b.exports = requireSelectionMode_min() : lib$b.exports = requireSelectionMode(), lib$b.exports;
}
var lib$a = { exports: {} }, fullScreen_min = {}, hasRequiredFullScreen_min;
function requireFullScreen_min() {
  if (hasRequiredFullScreen_min) return fullScreen_min;
  hasRequiredFullScreen_min = 1;
  var e = requireLib$h();
  function L(m) {
    var s = /* @__PURE__ */ Object.create(null);
    return m && Object.keys(m).forEach(function(w) {
      if (w !== "default") {
        var i = Object.getOwnPropertyDescriptor(m, w);
        Object.defineProperty(s, w, i.get ? i : { enumerable: !0, get: function() {
          return m[w];
        } });
      }
    }), s.default = m, Object.freeze(s);
  }
  var p = L(requireReact()), n = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: "M11.5 23.499L11.5 14.499" }), p.createElement("path", { d: "M7.5 18.499L11.5 14.499 15.5 18.499" }), p.createElement("path", { d: "M11.5 1.499L11.5 10.499" }), p.createElement("path", { d: "M7.5 6.499L11.5 10.499 15.5 6.499" }), p.createElement("path", { d: "M20.5 12.499L1.5 12.499" }));
  }, t = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: "M0.5 12L23.5 12" }), p.createElement("path", { d: "M11.5 1L11.5 23" }), p.createElement("path", { d: "M8.5 4L11.5 1 14.5 4" }), p.createElement("path", { d: "M20.5 9L23.5 12 20.5 15" }), p.createElement("path", { d: "M3.5 15L0.5 12 3.5 9" }), p.createElement("path", { d: "M14.5 20L11.5 23 8.5 20" }));
  }, l = function() {
    return l = Object.assign || function(m) {
      for (var s, w = 1, i = arguments.length; w < i; w++) for (var o in s = arguments[w]) Object.prototype.hasOwnProperty.call(s, o) && (m[o] = s[o]);
      return m;
    }, l.apply(this, arguments);
  }, W = { left: 0, top: 8 }, Q = function(m) {
    var s = m.enableShortcuts, w = m.onClick, i = p.useContext(e.LocalizationContext).l10n, o = i && i.fullScreen ? i.fullScreen.enterFullScreen : "Full screen", b = s ? e.isMac() ? "Meta+Ctrl+F" : "F11" : "";
    return p.createElement(e.Tooltip, { ariaControlsSuffix: "full-screen-enter", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaKeyShortcuts: b, ariaLabel: o, isDisabled: !e.isFullScreenEnabled(), testId: "full-screen__enter-button", onClick: w }, p.createElement(t, null)), content: function() {
      return o;
    }, offset: W });
  }, G = { left: 0, top: 8 }, X = function(m) {
    var s = m.onClick, w = p.useContext(e.LocalizationContext).l10n, i = w && w.fullScreen ? w.fullScreen.exitFullScreen : "Exit full screen";
    return p.createElement(e.Tooltip, { ariaControlsSuffix: "full-screen-exit", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaKeyShortcuts: "Esc", ariaLabel: i, testId: "full-screen__exit-button-with-tooltip", onClick: s }, p.createElement(n, null)), content: function() {
      return i;
    }, offset: G });
  }, N = function(m, s) {
    var w = p.useState(s.get("fullScreenMode")), i = w[0], o = w[1], b = p.useCallback(function(g) {
      o(g);
    }, []);
    return p.useEffect(function() {
      return s.subscribe("fullScreenMode", b), function() {
        s.unsubscribe("fullScreenMode", b);
      };
    }, []), { enterFullScreen: function() {
      var g = s.get("getPagesContainer");
      if (g) {
        var c = m(g());
        s.get("enterFullScreenMode")(c);
      }
    }, exitFullScreen: function() {
      s.get("exitFullScreenMode")();
    }, isFullScreen: i === e.FullScreenMode.Entering || i === e.FullScreenMode.EnteredCompletely };
  }, H = function(m) {
    var s = m.children, w = m.enableShortcuts, i = m.getFullScreenTarget, o = m.store, b = N(i, o), g = b.enterFullScreen, c = b.exitFullScreen, v = b.isFullScreen;
    return (s || function(k) {
      return v ? p.createElement(X, { onClick: k.onClick }) : p.createElement(Q, { enableShortcuts: w, onClick: k.onClick });
    })({ onClick: v ? c : g });
  }, B = function(m) {
    var s = m.onClick, w = p.useContext(e.LocalizationContext).l10n, i = w && w.fullScreen ? w.fullScreen.enterFullScreen : "Full screen";
    return p.createElement(e.MenuItem, { icon: p.createElement(t, null), isDisabled: !e.isFullScreenEnabled(), testId: "full-screen__enter-menu", onClick: s }, i);
  }, P = function(m) {
    var s = m.onClick, w = p.useContext(e.LocalizationContext).l10n, i = p.useContext(e.ThemeContext).direction === e.TextDirection.RightToLeft, o = w && w.fullScreen ? w.fullScreen.exitFullScreen : "Exit full screen";
    return p.createElement("div", { className: e.classNames({ "rpv-full-screen__exit-button": !0, "rpv-full-screen__exit-button--ltr": !i, "rpv-full-screen__exit-button--rtl": i }) }, p.createElement(e.MinimalButton, { ariaLabel: o, testId: "full-screen__exit-button", onClick: s }, p.createElement(n, null)));
  }, S = function(m) {
    var s = m.children, w = m.getFullScreenTarget, i = m.store, o = N(w, i), b = o.enterFullScreen, g = o.exitFullScreen, c = o.isFullScreen;
    return c && (s || function(v) {
      return p.createElement(P, { onClick: v.onClick });
    })({ onClick: c ? g : b });
  }, r = function(m) {
    var s = m.store, w = m.onEnterFullScreen, i = m.onExitFullScreen, o = p.useState(s.get("fullScreenMode")), b = o[0], g = o[1], c = p.useCallback(function(v) {
      g(v);
    }, []);
    return p.useEffect(function() {
      switch (b) {
        case e.FullScreenMode.EnteredCompletely:
          w(s.get("zoom"));
          break;
        case e.FullScreenMode.Exited:
          i(s.get("zoom"));
      }
    }, [b]), p.useEffect(function() {
      return s.subscribe("fullScreenMode", c), function() {
        s.unsubscribe("fullScreenMode", c);
      };
    }, []), (b === e.FullScreenMode.Entering || b === e.FullScreenMode.Entered) && p.createElement("div", { className: "rpv-full-screen__overlay" }, p.createElement(e.Spinner, null));
  }, u = function(m) {
    var s = m.containerRef, w = m.getFullScreenTarget, i = m.store, o = N(w, i).enterFullScreen, b = function(g) {
      if (!g.shiftKey && !g.altKey && (e.isMac() ? g.metaKey && g.ctrlKey && g.key === "f" : g.key === "F11")) {
        var c = s.current;
        c && document.activeElement && c.contains(document.activeElement) && (g.preventDefault(), o());
      }
    };
    return p.useEffect(function() {
      if (s.current) return document.addEventListener("keydown", b), function() {
        document.removeEventListener("keydown", b);
      };
    }, [s.current]), p.createElement(p.Fragment, null);
  };
  return fullScreen_min.ExitFullScreenIcon = n, fullScreen_min.FullScreenIcon = t, fullScreen_min.fullScreenPlugin = function(m) {
    var s = (m == null ? void 0 : m.getFullScreenTarget) || function(g) {
      return g;
    }, w = p.useMemo(function() {
      return Object.assign({}, { enableShortcuts: !0, onEnterFullScreen: function() {
      }, onExitFullScreen: function() {
      } }, m);
    }, []), i = p.useMemo(function() {
      return e.createStore({ enterFullScreenMode: function() {
      }, exitFullScreenMode: function() {
      }, fullScreenMode: e.FullScreenMode.Normal, zoom: function() {
      } });
    }, []), o = function(g) {
      return p.createElement(H, l({}, g, { enableShortcuts: w.enableShortcuts, getFullScreenTarget: s, store: i }));
    }, b = function() {
      return p.createElement(S, { getFullScreenTarget: s, store: i }, m == null ? void 0 : m.renderExitFullScreenButton);
    };
    return { install: function(g) {
      i.update("enterFullScreenMode", g.enterFullScreenMode), i.update("exitFullScreenMode", g.exitFullScreenMode), i.update("getPagesContainer", g.getPagesContainer), i.update("zoom", g.zoom);
    }, onViewerStateChange: function(g) {
      return i.update("fullScreenMode", g.fullScreenMode), g;
    }, renderViewer: function(g) {
      var c = g.slot;
      return c.subSlot && (c.subSlot.children = p.createElement(p.Fragment, null, w.enableShortcuts && p.createElement(u, { containerRef: g.containerRef, getFullScreenTarget: s, store: i }), p.createElement(r, { store: i, onEnterFullScreen: w.onEnterFullScreen, onExitFullScreen: w.onExitFullScreen }), p.createElement(b, null), c.subSlot.children)), c;
    }, EnterFullScreen: o, EnterFullScreenButton: function() {
      return p.createElement(o, null, function(g) {
        return p.createElement(Q, l({ enableShortcuts: w.enableShortcuts }, g));
      });
    }, EnterFullScreenMenuItem: function(g) {
      return p.createElement(o, null, function(c) {
        return p.createElement(B, { onClick: function() {
          c.onClick(), g.onClick();
        } });
      });
    } };
  }, fullScreen_min;
}
var fullScreen = {}, hasRequiredFullScreen;
function requireFullScreen() {
  if (hasRequiredFullScreen) return fullScreen;
  hasRequiredFullScreen = 1;
  var e = requireLib$h(), L = requireReact();
  function p(w) {
    var i = /* @__PURE__ */ Object.create(null);
    return w && Object.keys(w).forEach(function(o) {
      if (o !== "default") {
        var b = Object.getOwnPropertyDescriptor(w, o);
        Object.defineProperty(i, o, b.get ? b : {
          enumerable: !0,
          get: function() {
            return w[o];
          }
        });
      }
    }), i.default = w, Object.freeze(i);
  }
  var n = /* @__PURE__ */ p(L), t = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: "M11.5 23.499L11.5 14.499" }),
      n.createElement("path", { d: "M7.5 18.499L11.5 14.499 15.5 18.499" }),
      n.createElement("path", { d: "M11.5 1.499L11.5 10.499" }),
      n.createElement("path", { d: "M7.5 6.499L11.5 10.499 15.5 6.499" }),
      n.createElement("path", { d: "M20.5 12.499L1.5 12.499" })
    );
  }, l = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: "M0.5 12L23.5 12" }),
      n.createElement("path", { d: "M11.5 1L11.5 23" }),
      n.createElement("path", { d: "M8.5 4L11.5 1 14.5 4" }),
      n.createElement("path", { d: "M20.5 9L23.5 12 20.5 15" }),
      n.createElement("path", { d: "M3.5 15L0.5 12 3.5 9" }),
      n.createElement("path", { d: "M14.5 20L11.5 23 8.5 20" })
    );
  }, W = function() {
    return W = Object.assign || function(i) {
      for (var o, b = 1, g = arguments.length; b < g; b++) {
        o = arguments[b];
        for (var c in o) Object.prototype.hasOwnProperty.call(o, c) && (i[c] = o[c]);
      }
      return i;
    }, W.apply(this, arguments);
  }, Q = { left: 0, top: 8 }, G = function(w) {
    var i = w.enableShortcuts, o = w.onClick, b = n.useContext(e.LocalizationContext).l10n, g = b && b.fullScreen ? b.fullScreen.enterFullScreen : "Full screen", c = i ? e.isMac() ? "Meta+Ctrl+F" : "F11" : "";
    return n.createElement(e.Tooltip, { ariaControlsSuffix: "full-screen-enter", position: e.Position.BottomCenter, target: n.createElement(
      e.MinimalButton,
      { ariaKeyShortcuts: c, ariaLabel: g, isDisabled: !e.isFullScreenEnabled(), testId: "full-screen__enter-button", onClick: o },
      n.createElement(l, null)
    ), content: function() {
      return g;
    }, offset: Q });
  }, X = { left: 0, top: 8 }, N = function(w) {
    var i = w.onClick, o = n.useContext(e.LocalizationContext).l10n, b = o && o.fullScreen ? o.fullScreen.exitFullScreen : "Exit full screen";
    return n.createElement(e.Tooltip, { ariaControlsSuffix: "full-screen-exit", position: e.Position.BottomCenter, target: n.createElement(
      e.MinimalButton,
      { ariaKeyShortcuts: "Esc", ariaLabel: b, testId: "full-screen__exit-button-with-tooltip", onClick: i },
      n.createElement(t, null)
    ), content: function() {
      return b;
    }, offset: X });
  }, H = function(w, i) {
    var o = n.useState(i.get("fullScreenMode")), b = o[0], g = o[1], c = n.useCallback(function(a) {
      g(a);
    }, []), v = function() {
      var a = i.get("getPagesContainer");
      if (a) {
        var f = w(a());
        i.get("enterFullScreenMode")(f);
      }
    }, k = function() {
      i.get("exitFullScreenMode")();
    };
    return n.useEffect(function() {
      return i.subscribe("fullScreenMode", c), function() {
        i.unsubscribe("fullScreenMode", c);
      };
    }, []), {
      enterFullScreen: v,
      exitFullScreen: k,
      isFullScreen: b === e.FullScreenMode.Entering || b === e.FullScreenMode.EnteredCompletely
    };
  }, B = function(w) {
    var i = w.children, o = w.enableShortcuts, b = w.getFullScreenTarget, g = w.store, c = H(b, g), v = c.enterFullScreen, k = c.exitFullScreen, a = c.isFullScreen, f = function(R) {
      return a ? n.createElement(N, { onClick: R.onClick }) : n.createElement(G, { enableShortcuts: o, onClick: R.onClick });
    }, C = i || f;
    return C({
      onClick: a ? k : v
    });
  }, P = function(w) {
    var i = w.onClick, o = n.useContext(e.LocalizationContext).l10n, b = o && o.fullScreen ? o.fullScreen.enterFullScreen : "Full screen";
    return n.createElement(e.MenuItem, { icon: n.createElement(l, null), isDisabled: !e.isFullScreenEnabled(), testId: "full-screen__enter-menu", onClick: i }, b);
  }, S = function(w) {
    var i = w.onClick, o = n.useContext(e.LocalizationContext).l10n, b = n.useContext(e.ThemeContext).direction, g = b === e.TextDirection.RightToLeft, c = o && o.fullScreen ? o.fullScreen.exitFullScreen : "Exit full screen";
    return n.createElement(
      "div",
      { className: e.classNames({
        "rpv-full-screen__exit-button": !0,
        "rpv-full-screen__exit-button--ltr": !g,
        "rpv-full-screen__exit-button--rtl": g
      }) },
      n.createElement(
        e.MinimalButton,
        { ariaLabel: c, testId: "full-screen__exit-button", onClick: i },
        n.createElement(t, null)
      )
    );
  }, r = function(w) {
    var i = w.children, o = w.getFullScreenTarget, b = w.store, g = H(o, b), c = g.enterFullScreen, v = g.exitFullScreen, k = g.isFullScreen, a = function(C) {
      return n.createElement(S, { onClick: C.onClick });
    }, f = i || a;
    return k && f({
      onClick: k ? v : c
    });
  }, u = function(w) {
    var i = w.store, o = w.onEnterFullScreen, b = w.onExitFullScreen, g = n.useState(i.get("fullScreenMode")), c = g[0], v = g[1], k = n.useCallback(function(C) {
      v(C);
    }, []), a = function() {
      o(i.get("zoom"));
    }, f = function() {
      b(i.get("zoom"));
    };
    return n.useEffect(function() {
      switch (c) {
        case e.FullScreenMode.EnteredCompletely:
          a();
          break;
        case e.FullScreenMode.Exited:
          f();
          break;
      }
    }, [c]), n.useEffect(function() {
      return i.subscribe("fullScreenMode", k), function() {
        i.unsubscribe("fullScreenMode", k);
      };
    }, []), (c === e.FullScreenMode.Entering || c === e.FullScreenMode.Entered) && n.createElement(
      "div",
      { className: "rpv-full-screen__overlay" },
      n.createElement(e.Spinner, null)
    );
  }, m = function(w) {
    var i = w.containerRef, o = w.getFullScreenTarget, b = w.store, g = H(o, b).enterFullScreen, c = function(v) {
      if (!(v.shiftKey || v.altKey)) {
        var k = e.isMac() ? v.metaKey && v.ctrlKey && v.key === "f" : v.key === "F11";
        if (k) {
          var a = i.current;
          !a || !document.activeElement || !a.contains(document.activeElement) || (v.preventDefault(), g());
        }
      }
    };
    return n.useEffect(function() {
      var v = i.current;
      if (v)
        return document.addEventListener("keydown", c), function() {
          document.removeEventListener("keydown", c);
        };
    }, [i.current]), n.createElement(n.Fragment, null);
  }, s = function(w) {
    var i = function(C) {
      return C;
    }, o = (w == null ? void 0 : w.getFullScreenTarget) || i, b = n.useMemo(function() {
      return Object.assign({}, { enableShortcuts: !0, onEnterFullScreen: function() {
      }, onExitFullScreen: function() {
      } }, w);
    }, []), g = n.useMemo(function() {
      return e.createStore({
        enterFullScreenMode: function() {
        },
        exitFullScreenMode: function() {
        },
        fullScreenMode: e.FullScreenMode.Normal,
        zoom: function() {
        }
      });
    }, []), c = function(C) {
      return n.createElement(B, W({}, C, { enableShortcuts: b.enableShortcuts, getFullScreenTarget: o, store: g }));
    }, v = function() {
      return n.createElement(c, null, function(C) {
        return n.createElement(G, W({ enableShortcuts: b.enableShortcuts }, C));
      });
    }, k = function(C) {
      return n.createElement(c, null, function(R) {
        return n.createElement(P, { onClick: function() {
          R.onClick(), C.onClick();
        } });
      });
    }, a = function() {
      return n.createElement(r, { getFullScreenTarget: o, store: g }, w == null ? void 0 : w.renderExitFullScreenButton);
    }, f = function(C) {
      var R = C.slot;
      return R.subSlot && (R.subSlot.children = n.createElement(
        n.Fragment,
        null,
        b.enableShortcuts && n.createElement(m, { containerRef: C.containerRef, getFullScreenTarget: o, store: g }),
        n.createElement(u, { store: g, onEnterFullScreen: b.onEnterFullScreen, onExitFullScreen: b.onExitFullScreen }),
        n.createElement(a, null),
        R.subSlot.children
      )), R;
    };
    return {
      install: function(C) {
        g.update("enterFullScreenMode", C.enterFullScreenMode), g.update("exitFullScreenMode", C.exitFullScreenMode), g.update("getPagesContainer", C.getPagesContainer), g.update("zoom", C.zoom);
      },
      onViewerStateChange: function(C) {
        return g.update("fullScreenMode", C.fullScreenMode), C;
      },
      renderViewer: f,
      EnterFullScreen: c,
      EnterFullScreenButton: v,
      EnterFullScreenMenuItem: k
    };
  };
  return fullScreen.ExitFullScreenIcon = t, fullScreen.FullScreenIcon = l, fullScreen.fullScreenPlugin = s, fullScreen;
}
var hasRequiredLib$c;
function requireLib$c() {
  if (hasRequiredLib$c) return lib$a.exports;
  hasRequiredLib$c = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$a.exports = requireFullScreen_min() : lib$a.exports = requireFullScreen(), lib$a.exports;
}
var lib$9 = { exports: {} }, getFile_min = {}, hasRequiredGetFile_min;
function requireGetFile_min() {
  if (hasRequiredGetFile_min) return getFile_min;
  hasRequiredGetFile_min = 1;
  var e = requireLib$h();
  function L(B) {
    var P = /* @__PURE__ */ Object.create(null);
    return B && Object.keys(B).forEach(function(S) {
      if (S !== "default") {
        var r = Object.getOwnPropertyDescriptor(B, S);
        Object.defineProperty(P, S, r.get ? r : { enumerable: !0, get: function() {
          return B[S];
        } });
      }
    }), P.default = B, Object.freeze(P);
  }
  var p = L(requireReact()), n = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: "M5.5,11.5c-.275,0-.341.159-.146.354l6.292,6.293a.5.5,0,0,0,.709,0l6.311-6.275c.2-.193.13-.353-.145-.355L15.5,11.5V1.5a1,1,0,0,0-1-1h-5a1,1,0,0,0-1,1V11a.5.5,0,0,1-.5.5Z" }), p.createElement("path", { d: "M23.5,18.5v4a1,1,0,0,1-1,1H1.5a1,1,0,0,1-1-1v-4" }));
  }, t = function() {
    return t = Object.assign || function(B) {
      for (var P, S = 1, r = arguments.length; S < r; S++) for (var u in P = arguments[S]) Object.prototype.hasOwnProperty.call(P, u) && (B[u] = P[u]);
      return B;
    }, t.apply(this, arguments);
  }, l = { left: 0, top: 8 }, W = function(B) {
    var P = B.onClick, S = p.useContext(e.LocalizationContext).l10n, r = S && S.download ? S.download.download : "Download";
    return p.createElement(e.Tooltip, { ariaControlsSuffix: "get-file", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaLabel: r, testId: "get-file__download-button", onClick: P }, p.createElement(n, null)), content: function() {
      return r;
    }, offset: l });
  }, Q = function(B, P) {
    var S = document.createElement("a");
    S.style.display = "none", S.href = B, S.setAttribute("download", P), document.body.appendChild(S), S.click(), document.body.removeChild(S);
  }, G = function(B, P, S) {
    var r = URL.createObjectURL(new Blob([B], { type: S }));
    Q(r, P), r && URL.revokeObjectURL(r);
  }, X = function(B, P) {
    B.getData().then(function(S) {
      /iphone|ipod|ipad/i.test(navigator.userAgent) && !/CriOS/i.test(navigator.userAgent) ? G(S, P, "application/octet-stream") : /iphone|ipod|ipad/i.test(navigator.userAgent) && /CriOS/i.test(navigator.userAgent) ? Q("data:application/pdf;base64,".concat(function(r) {
        return btoa(Array(r.length).fill("").map(function(u, m) {
          return String.fromCharCode(r[m]);
        }).join(""));
      }(S)), P) : G(S, P, "application/pdf");
    });
  }, N = function(B) {
    var P = B.children, S = B.fileNameGenerator, r = B.store, u = p.useState(r.get("file")), m = u[0], s = u[1], w = p.useState(r.get("doc")), i = w[0], o = w[1], b = function(c) {
      o(c);
    }, g = function(c) {
      s(c);
    };
    return p.useEffect(function() {
      return r.subscribe("doc", b), r.subscribe("file", g), function() {
        r.subscribe("doc", b), r.unsubscribe("file", g);
      };
    }, []), (P || function(c) {
      return p.createElement(W, { onClick: c.onClick });
    })({ onClick: function() {
      i && m && X(i, S(m));
    } });
  }, H = function(B) {
    var P = B.onClick, S = p.useContext(e.LocalizationContext).l10n, r = S && S.download ? S.download.download : "Download";
    return p.createElement(e.MenuItem, { icon: p.createElement(n, null), testId: "get-file__download-menu", onClick: P }, r);
  };
  return getFile_min.DownloadIcon = n, getFile_min.getFilePlugin = function(B) {
    var P = p.useMemo(function() {
      return e.createStore({});
    }, []), S = function(u) {
      return u.name ? (m = u.name, (s = m.split("/").pop()) ? s.split("#")[0].split("?")[0] : m) : "document.pdf";
      var m, s;
    }, r = function(u) {
      return p.createElement(N, t({}, u, { fileNameGenerator: B && B.fileNameGenerator || S, store: P }));
    };
    return { onDocumentLoad: function(u) {
      P.update("doc", u.doc), P.update("file", u.file);
    }, Download: r, DownloadButton: function() {
      return p.createElement(r, null, function(u) {
        return p.createElement(W, t({}, u));
      });
    }, DownloadMenuItem: function(u) {
      return p.createElement(r, null, function(m) {
        return p.createElement(H, { onClick: function() {
          m.onClick(), u.onClick();
        } });
      });
    } };
  }, getFile_min;
}
var getFile = {}, hasRequiredGetFile;
function requireGetFile() {
  if (hasRequiredGetFile) return getFile;
  hasRequiredGetFile = 1;
  var e = requireLib$h(), L = requireReact();
  function p(s) {
    var w = /* @__PURE__ */ Object.create(null);
    return s && Object.keys(s).forEach(function(i) {
      if (i !== "default") {
        var o = Object.getOwnPropertyDescriptor(s, i);
        Object.defineProperty(w, i, o.get ? o : {
          enumerable: !0,
          get: function() {
            return s[i];
          }
        });
      }
    }), w.default = s, Object.freeze(w);
  }
  var n = /* @__PURE__ */ p(L), t = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: "M5.5,11.5c-.275,0-.341.159-.146.354l6.292,6.293a.5.5,0,0,0,.709,0l6.311-6.275c.2-.193.13-.353-.145-.355L15.5,11.5V1.5a1,1,0,0,0-1-1h-5a1,1,0,0,0-1,1V11a.5.5,0,0,1-.5.5Z" }),
      n.createElement("path", { d: "M23.5,18.5v4a1,1,0,0,1-1,1H1.5a1,1,0,0,1-1-1v-4" })
    );
  }, l = function() {
    return l = Object.assign || function(w) {
      for (var i, o = 1, b = arguments.length; o < b; o++) {
        i = arguments[o];
        for (var g in i) Object.prototype.hasOwnProperty.call(i, g) && (w[g] = i[g]);
      }
      return w;
    }, l.apply(this, arguments);
  }, W = { left: 0, top: 8 }, Q = function(s) {
    var w = s.onClick, i = n.useContext(e.LocalizationContext).l10n, o = i && i.download ? i.download.download : "Download";
    return n.createElement(e.Tooltip, { ariaControlsSuffix: "get-file", position: e.Position.BottomCenter, target: n.createElement(
      e.MinimalButton,
      { ariaLabel: o, testId: "get-file__download-button", onClick: w },
      n.createElement(t, null)
    ), content: function() {
      return o;
    }, offset: W });
  }, G = function() {
    return /iphone|ipod|ipad/i.test(navigator.userAgent) && /CriOS/i.test(navigator.userAgent);
  }, X = function() {
    return /iphone|ipod|ipad/i.test(navigator.userAgent) && !/CriOS/i.test(navigator.userAgent);
  }, N = function(s) {
    return btoa(Array(s.length).fill("").map(function(w, i) {
      return String.fromCharCode(s[i]);
    }).join(""));
  }, H = function(s, w) {
    var i = document.createElement("a");
    i.style.display = "none", i.href = s, i.setAttribute("download", w), document.body.appendChild(i), i.click(), document.body.removeChild(i);
  }, B = function(s, w, i) {
    var o = URL.createObjectURL(new Blob([s], { type: i }));
    H(o, w), o && URL.revokeObjectURL(o);
  }, P = function(s, w) {
    s.getData().then(function(i) {
      X() ? B(i, w, "application/octet-stream") : G() ? H("data:application/pdf;base64,".concat(N(i)), w) : B(i, w, "application/pdf");
    });
  }, S = function(s) {
    var w = s.children, i = s.fileNameGenerator, o = s.store, b = n.useState(o.get("file")), g = b[0], c = b[1], v = n.useState(o.get("doc")), k = v[0], a = v[1], f = function(E) {
      a(E);
    }, C = function(E) {
      c(E);
    };
    n.useEffect(function() {
      return o.subscribe("doc", f), o.subscribe("file", C), function() {
        o.subscribe("doc", f), o.unsubscribe("file", C);
      };
    }, []);
    var R = function() {
      k && g && P(k, i(g));
    }, M = function(E) {
      return n.createElement(Q, { onClick: E.onClick });
    }, I = w || M;
    return I({
      onClick: R
    });
  }, r = function(s) {
    var w = s.onClick, i = n.useContext(e.LocalizationContext).l10n, o = i && i.download ? i.download.download : "Download";
    return n.createElement(e.MenuItem, { icon: n.createElement(t, null), testId: "get-file__download-menu", onClick: w }, o);
  }, u = function(s) {
    var w = s.split("/").pop();
    return w ? w.split("#")[0].split("?")[0] : s;
  }, m = function(s) {
    var w = n.useMemo(function() {
      return e.createStore({});
    }, []), i = function(c) {
      return c.name ? u(c.name) : "document.pdf";
    }, o = function(c) {
      return n.createElement(S, l({}, c, { fileNameGenerator: s && s.fileNameGenerator || i, store: w }));
    }, b = function() {
      return n.createElement(o, null, function(c) {
        return n.createElement(Q, l({}, c));
      });
    }, g = function(c) {
      return n.createElement(o, null, function(v) {
        return n.createElement(r, { onClick: function() {
          v.onClick(), c.onClick();
        } });
      });
    };
    return {
      onDocumentLoad: function(c) {
        w.update("doc", c.doc), w.update("file", c.file);
      },
      Download: o,
      DownloadButton: b,
      DownloadMenuItem: g
    };
  };
  return getFile.DownloadIcon = t, getFile.getFilePlugin = m, getFile;
}
var hasRequiredLib$b;
function requireLib$b() {
  if (hasRequiredLib$b) return lib$9.exports;
  hasRequiredLib$b = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$9.exports = requireGetFile_min() : lib$9.exports = requireGetFile(), lib$9.exports;
}
var lib$8 = { exports: {} }, open_min = {}, hasRequiredOpen_min;
function requireOpen_min() {
  if (hasRequiredOpen_min) return open_min;
  hasRequiredOpen_min = 1;
  var e = requireLib$h();
  function L(H) {
    var B = /* @__PURE__ */ Object.create(null);
    return H && Object.keys(H).forEach(function(P) {
      if (P !== "default") {
        var S = Object.getOwnPropertyDescriptor(H, P);
        Object.defineProperty(B, P, S.get ? S : { enumerable: !0, get: function() {
          return H[P];
        } });
      }
    }), B.default = H, Object.freeze(B);
  }
  var p = L(requireReact()), n = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: "M18.5,7.5c.275,0,.341-.159.146-.354L12.354.854a.5.5,0,0,0-.708,0L5.354,7.147c-.2.195-.129.354.146.354h3v10a1,1,0,0,0,1,1h5a1,1,0,0,0,1-1V7.5Z" }), p.createElement("path", { d: "M23.5,18.5v4a1,1,0,0,1-1,1H1.5a1,1,0,0,1-1-1v-4" }));
  }, t = function() {
    return t = Object.assign || function(H) {
      for (var B, P = 1, S = arguments.length; P < S; P++) for (var r in B = arguments[P]) Object.prototype.hasOwnProperty.call(B, r) && (H[r] = B[r]);
      return H;
    }, t.apply(this, arguments);
  }, l = function(H) {
    var B = p.useRef(), P = function() {
      var r = B.current;
      r && (r.click(), H.get("triggerOpenFile") && H.update("triggerOpenFile", !1));
    }, S = function(r) {
      r && P();
    };
    return p.useEffect(function() {
      return H.subscribe("triggerOpenFile", S), function() {
        H.unsubscribe("triggerOpenFile", S);
      };
    }, []), { inputRef: B, openFile: P };
  }, W = { left: 0, top: 8 }, Q = function(H) {
    var B = H.enableShortcuts, P = H.store, S = H.onClick, r = p.useContext(e.LocalizationContext).l10n, u = r && r.open ? r.open.openFile : "Open file", m = l(P), s = m.inputRef, w = m.openFile, i = B ? e.isMac() ? "Meta+O" : "Ctrl+O" : "";
    return p.createElement(e.Tooltip, { ariaControlsSuffix: "open", position: e.Position.BottomCenter, target: p.createElement("div", { className: "rpv-open__input-wrapper" }, p.createElement("input", { accept: ".pdf", ref: s, className: "rpv-open__input", multiple: !1, tabIndex: -1, title: "", type: "file", onChange: S }), p.createElement(e.MinimalButton, { ariaKeyShortcuts: i, ariaLabel: u, testId: "open__button", onClick: w }, p.createElement(n, null))), content: function() {
      return u;
    }, offset: W });
  }, G = function(H) {
    var B = H.children, P = H.enableShortcuts, S = H.store;
    return (B || function(r) {
      return p.createElement(Q, { enableShortcuts: P, store: S, onClick: r.onClick });
    })({ onClick: function(r) {
      var u = r.target.files;
      if (u && u.length) {
        var m = S.get("openFile");
        m && m(u[0]);
      }
    } });
  }, X = function(H) {
    var B = H.store, P = H.onClick, S = p.useContext(e.LocalizationContext).l10n, r = S && S.open ? S.open.openFile : "Open file", u = l(B), m = u.inputRef, s = u.openFile;
    return p.createElement(e.MenuItem, { icon: p.createElement(n, null), testId: "open__menu", onClick: s }, p.createElement("div", { className: "rpv-open__input-wrapper" }, p.createElement("input", { accept: ".pdf", ref: m, className: "rpv-open__input", multiple: !1, tabIndex: -1, title: "", type: "file", onChange: P }), r));
  }, N = function(H) {
    var B = H.containerRef, P = H.store, S = function(r) {
      if (!r.shiftKey && !r.altKey && r.key === "o" && (e.isMac() ? r.metaKey : r.ctrlKey)) {
        var u = B.current;
        u && document.activeElement && u.contains(document.activeElement) && (r.preventDefault(), P.update("triggerOpenFile", !0));
      }
    };
    return p.useEffect(function() {
      if (B.current) return document.addEventListener("keydown", S), function() {
        document.removeEventListener("keydown", S);
      };
    }, [B.current]), p.createElement(p.Fragment, null);
  };
  return open_min.OpenFileIcon = n, open_min.openPlugin = function(H) {
    var B = p.useMemo(function() {
      return Object.assign({}, { enableShortcuts: !0 }, H);
    }, []), P = p.useMemo(function() {
      return e.createStore({});
    }, []), S = function(r) {
      return p.createElement(G, t({ enableShortcuts: B.enableShortcuts }, r, { store: P }));
    };
    return { install: function(r) {
      P.update("openFile", r.openFile);
    }, renderViewer: function(r) {
      var u = r.slot, m = { children: p.createElement(p.Fragment, null, B.enableShortcuts && p.createElement(N, { containerRef: r.containerRef, store: P }), u.children) };
      return t(t({}, u), m);
    }, Open: S, OpenButton: function() {
      return p.createElement(S, null);
    }, OpenMenuItem: function() {
      return p.createElement(S, null, function(r) {
        return p.createElement(X, { store: P, onClick: r.onClick });
      });
    } };
  }, open_min;
}
var open = {}, hasRequiredOpen;
function requireOpen() {
  if (hasRequiredOpen) return open;
  hasRequiredOpen = 1;
  var e = requireLib$h(), L = requireReact();
  function p(P) {
    var S = /* @__PURE__ */ Object.create(null);
    return P && Object.keys(P).forEach(function(r) {
      if (r !== "default") {
        var u = Object.getOwnPropertyDescriptor(P, r);
        Object.defineProperty(S, r, u.get ? u : {
          enumerable: !0,
          get: function() {
            return P[r];
          }
        });
      }
    }), S.default = P, Object.freeze(S);
  }
  var n = /* @__PURE__ */ p(L), t = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: "M18.5,7.5c.275,0,.341-.159.146-.354L12.354.854a.5.5,0,0,0-.708,0L5.354,7.147c-.2.195-.129.354.146.354h3v10a1,1,0,0,0,1,1h5a1,1,0,0,0,1-1V7.5Z" }),
      n.createElement("path", { d: "M23.5,18.5v4a1,1,0,0,1-1,1H1.5a1,1,0,0,1-1-1v-4" })
    );
  }, l = function() {
    return l = Object.assign || function(S) {
      for (var r, u = 1, m = arguments.length; u < m; u++) {
        r = arguments[u];
        for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (S[s] = r[s]);
      }
      return S;
    }, l.apply(this, arguments);
  }, W = function(P) {
    var S = n.useRef(), r = function() {
      var m = S.current;
      m && (m.click(), P.get("triggerOpenFile") && P.update("triggerOpenFile", !1));
    }, u = function(m) {
      m && r();
    };
    return n.useEffect(function() {
      return P.subscribe("triggerOpenFile", u), function() {
        P.unsubscribe("triggerOpenFile", u);
      };
    }, []), {
      inputRef: S,
      openFile: r
    };
  }, Q = { left: 0, top: 8 }, G = function(P) {
    var S = P.enableShortcuts, r = P.store, u = P.onClick, m = n.useContext(e.LocalizationContext).l10n, s = m && m.open ? m.open.openFile : "Open file", w = W(r), i = w.inputRef, o = w.openFile, b = S ? e.isMac() ? "Meta+O" : "Ctrl+O" : "";
    return n.createElement(e.Tooltip, { ariaControlsSuffix: "open", position: e.Position.BottomCenter, target: n.createElement(
      "div",
      { className: "rpv-open__input-wrapper" },
      n.createElement("input", { accept: ".pdf", ref: i, className: "rpv-open__input", multiple: !1, tabIndex: -1, title: "", type: "file", onChange: u }),
      n.createElement(
        e.MinimalButton,
        { ariaKeyShortcuts: b, ariaLabel: s, testId: "open__button", onClick: o },
        n.createElement(t, null)
      )
    ), content: function() {
      return s;
    }, offset: Q });
  }, X = function(P) {
    var S = P.children, r = P.enableShortcuts, u = P.store, m = function(i) {
      var o = i.target.files;
      if (!(!o || !o.length)) {
        var b = u.get("openFile");
        b && b(o[0]);
      }
    }, s = function(i) {
      return n.createElement(G, { enableShortcuts: r, store: u, onClick: i.onClick });
    }, w = S || s;
    return w({
      onClick: m
    });
  }, N = function(P) {
    var S = P.store, r = P.onClick, u = n.useContext(e.LocalizationContext).l10n, m = u && u.open ? u.open.openFile : "Open file", s = W(S), w = s.inputRef, i = s.openFile;
    return n.createElement(
      e.MenuItem,
      { icon: n.createElement(t, null), testId: "open__menu", onClick: i },
      n.createElement(
        "div",
        { className: "rpv-open__input-wrapper" },
        n.createElement("input", { accept: ".pdf", ref: w, className: "rpv-open__input", multiple: !1, tabIndex: -1, title: "", type: "file", onChange: r }),
        m
      )
    );
  }, H = function(P) {
    var S = P.containerRef, r = P.store, u = function(m) {
      if (!(m.shiftKey || m.altKey || m.key !== "o")) {
        var s = e.isMac() ? m.metaKey : m.ctrlKey;
        if (s) {
          var w = S.current;
          !w || !document.activeElement || !w.contains(document.activeElement) || (m.preventDefault(), r.update("triggerOpenFile", !0));
        }
      }
    };
    return n.useEffect(function() {
      var m = S.current;
      if (m)
        return document.addEventListener("keydown", u), function() {
          document.removeEventListener("keydown", u);
        };
    }, [S.current]), n.createElement(n.Fragment, null);
  }, B = function(P) {
    var S = n.useMemo(function() {
      return Object.assign({}, { enableShortcuts: !0 }, P);
    }, []), r = n.useMemo(function() {
      return e.createStore({});
    }, []), u = function(i) {
      return n.createElement(X, l({ enableShortcuts: S.enableShortcuts }, i, { store: r }));
    }, m = function() {
      return n.createElement(u, null);
    }, s = function() {
      return n.createElement(u, null, function(i) {
        return n.createElement(N, { store: r, onClick: i.onClick });
      });
    }, w = function(i) {
      var o = i.slot, b = {
        children: n.createElement(
          n.Fragment,
          null,
          S.enableShortcuts && n.createElement(H, { containerRef: i.containerRef, store: r }),
          o.children
        )
      };
      return l(l({}, o), b);
    };
    return {
      install: function(i) {
        r.update("openFile", i.openFile);
      },
      renderViewer: w,
      Open: u,
      OpenButton: m,
      OpenMenuItem: s
    };
  };
  return open.OpenFileIcon = t, open.openPlugin = B, open;
}
var hasRequiredLib$a;
function requireLib$a() {
  if (hasRequiredLib$a) return lib$8.exports;
  hasRequiredLib$a = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$8.exports = requireOpen_min() : lib$8.exports = requireOpen(), lib$8.exports;
}
var lib$7 = { exports: {} }, pageNavigation_min = {}, hasRequiredPageNavigation_min;
function requirePageNavigation_min() {
  if (hasRequiredPageNavigation_min) return pageNavigation_min;
  hasRequiredPageNavigation_min = 1;
  var e = requireLib$h();
  function L(M) {
    var I = /* @__PURE__ */ Object.create(null);
    return M && Object.keys(M).forEach(function(E) {
      if (E !== "default") {
        var T = Object.getOwnPropertyDescriptor(M, E);
        Object.defineProperty(I, E, T.get ? T : { enumerable: !0, get: function() {
          return M[E];
        } });
      }
    }), I.default = M, Object.freeze(I);
  }
  var p = L(requireReact()), n = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: `M2.32,2.966h19.452c0.552,0.001,1,0.449,0.999,1.001c0,0.182-0.05,0.36-0.144,0.516L12.9,20.552
            c-0.286,0.472-0.901,0.624-1.373,0.338c-0.138-0.084-0.254-0.2-0.338-0.338L1.465,4.483C1.179,4.01,1.331,3.396,1.804,3.11
            C1.96,3.016,2.138,2.966,2.32,2.966z` }));
  }, t = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: `M0.541,5.627L11.666,18.2c0.183,0.207,0.499,0.226,0.706,0.043c0.015-0.014,0.03-0.028,0.043-0.043
            L23.541,5.627` }));
  }, l = function() {
    return l = Object.assign || function(M) {
      for (var I, E = 1, T = arguments.length; E < T; E++) for (var y in I = arguments[E]) Object.prototype.hasOwnProperty.call(I, y) && (M[y] = I[y]);
      return M;
    }, l.apply(this, arguments);
  }, W = function(M) {
    var I = p.useState(M.get("currentPage") || 0), E = I[0], T = I[1], y = function(D) {
      T(D);
    };
    return e.useIsomorphicLayoutEffect(function() {
      return M.subscribe("currentPage", y), function() {
        M.unsubscribe("currentPage", y);
      };
    }, []), { currentPage: E };
  }, Q = function(M) {
    var I = p.useState(M.get("numberOfPages") || 0), E = I[0], T = I[1], y = function(D) {
      T(D);
    };
    return p.useEffect(function() {
      return M.subscribe("numberOfPages", y), function() {
        M.unsubscribe("numberOfPages", y);
      };
    }, []), { numberOfPages: E };
  }, G = function(M) {
    var I = M.store, E = p.useContext(e.LocalizationContext).l10n, T = p.useState("1"), y = T[0], D = T[1], j = W(I).currentPage, A = Q(I).numberOfPages;
    p.useEffect(function() {
      return D("".concat(j + 1));
    }, [j]);
    var d = function(F) {
      var U = I.get("jumpToPage");
      U && U(F);
    }, _ = E && E.pageNavigation ? E.pageNavigation.enterPageNumber : "Enter a page number";
    return p.createElement("span", { className: "rpv-page-navigation__current-page-input" }, p.createElement(e.TextBox, { ariaLabel: _, testId: "page-navigation__current-page-input", type: "text", value: y, onChange: D, onKeyDown: function(F) {
      switch (F.key) {
        case "ArrowUp":
          ($ = j - 1) >= 0 && (D("".concat($ + 1)), d($));
          break;
        case "ArrowDown":
          (V = j + 1) < A && (D("".concat(V + 1)), d(V));
          break;
        case "Enter":
          U = parseInt(y, 10), y === "" || U < 1 || U > A ? D("".concat(j + 1)) : d(U - 1);
      }
      var U, V, $;
    } }));
  }, X = function(M) {
    var I = M.children, E = M.doc, T = e.useIsMounted(), y = p.useState({ loading: !0, labels: [] }), D = y[0], j = y[1];
    return p.useEffect(function() {
      E.getPageLabels().then(function(A) {
        T.current && j({ loading: !1, labels: A || [] });
      });
    }, [E.loadingTask.docId]), D.loading ? p.createElement(p.Fragment, null) : I(D.labels);
  }, N = function(M) {
    var I = M.children, E = M.store, T = function(A) {
      var d = p.useState(A.get("doc")), _ = d[0], F = d[1], U = function(V) {
        F(V);
      };
      return p.useEffect(function() {
        return A.subscribe("doc", U), function() {
          A.unsubscribe("doc", U);
        };
      }, []), _;
    }(E), y = W(E).currentPage, D = Q(E).numberOfPages, j = I || function(A) {
      return p.createElement(p.Fragment, null, A.currentPage + 1);
    };
    return T ? p.createElement(X, { doc: T }, function(A) {
      var d = A.length === D && D > 0 ? A[y] : "";
      return j({ currentPage: y, numberOfPages: D, pageLabel: d });
    }) : p.createElement(p.Fragment, null);
  }, H = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: `M21.783,21.034H2.332c-0.552,0-1-0.448-1-1c0-0.182,0.05-0.361,0.144-0.517L11.2,3.448
            c0.286-0.472,0.901-0.624,1.373-0.338c0.138,0.084,0.254,0.2,0.338,0.338l9.726,16.069c0.286,0.473,0.134,1.087-0.339,1.373
            C22.143,20.984,21.965,21.034,21.783,21.034z` }));
  }, B = { left: 0, top: 8 }, P = function(M) {
    var I = M.isDisabled, E = M.onClick, T = p.useContext(e.LocalizationContext).l10n, y = T && T.pageNavigation ? T.pageNavigation.goToFirstPage : "First page";
    return p.createElement(e.Tooltip, { ariaControlsSuffix: "page-navigation-first", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaLabel: y, isDisabled: I, testId: "page-navigation__first-button", onClick: E }, p.createElement(H, null)), content: function() {
      return y;
    }, offset: B });
  }, S = function(M) {
    var I = M.children, E = M.store;
    return (I || function(T) {
      return p.createElement(P, { isDisabled: T.isDisabled, onClick: T.onClick });
    })({ isDisabled: W(E).currentPage === 0, onClick: function() {
      var T = E.get("jumpToPage");
      T && T(0);
    } });
  }, r = function(M) {
    var I = M.isDisabled, E = M.onClick, T = p.useContext(e.LocalizationContext).l10n, y = T && T.pageNavigation ? T.pageNavigation.goToFirstPage : "First page";
    return p.createElement(e.MenuItem, { icon: p.createElement(H, null), isDisabled: I, testId: "page-navigation__first-menu", onClick: E }, y);
  }, u = { left: 0, top: 8 }, m = function(M) {
    var I = M.isDisabled, E = M.onClick, T = p.useContext(e.LocalizationContext).l10n, y = T && T.pageNavigation ? T.pageNavigation.goToLastPage : "Last page";
    return p.createElement(e.Tooltip, { ariaControlsSuffix: "page-navigation-last", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaLabel: y, isDisabled: I, testId: "page-navigation__last-button", onClick: E }, p.createElement(n, null)), content: function() {
      return y;
    }, offset: u });
  }, s = function(M) {
    var I = M.children, E = M.store, T = W(E).currentPage, y = Q(E).numberOfPages;
    return (I || function(D) {
      return p.createElement(m, { isDisabled: D.isDisabled, onClick: D.onClick });
    })({ isDisabled: T + 1 >= y, onClick: function() {
      var D = E.get("jumpToPage");
      D && D(y - 1);
    } });
  }, w = function(M) {
    var I = M.isDisabled, E = M.onClick, T = p.useContext(e.LocalizationContext).l10n, y = T && T.pageNavigation ? T.pageNavigation.goToLastPage : "Last page";
    return p.createElement(e.MenuItem, { icon: p.createElement(n, null), isDisabled: I, testId: "page-navigation__last-menu", onClick: E }, y);
  }, i = { left: 0, top: 8 }, o = function(M) {
    var I = M.isDisabled, E = M.onClick, T = p.useContext(e.LocalizationContext).l10n, y = T && T.pageNavigation ? T.pageNavigation.goToNextPage : "Next page";
    return p.createElement(e.Tooltip, { ariaControlsSuffix: "page-navigation-next", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaLabel: y, isDisabled: I, testId: "page-navigation__next-button", onClick: E }, p.createElement(t, null)), content: function() {
      return y;
    }, offset: i });
  }, b = function(M) {
    var I = M.children, E = M.store;
    return (I || function(T) {
      return p.createElement(o, { onClick: T.onClick, isDisabled: T.isDisabled });
    })({ isDisabled: W(E).currentPage + 1 >= Q(E).numberOfPages, onClick: function() {
      var T = E.get("jumpToNextPage");
      T && T();
    } });
  }, g = function(M) {
    var I = M.isDisabled, E = M.onClick, T = p.useContext(e.LocalizationContext).l10n, y = T && T.pageNavigation ? T.pageNavigation.goToNextPage : "Next page";
    return p.createElement(e.MenuItem, { icon: p.createElement(t, null), isDisabled: I, testId: "page-navigation__next-menu", onClick: E }, y);
  }, c = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: `M23.535,18.373L12.409,5.8c-0.183-0.207-0.499-0.226-0.706-0.043C11.688,5.77,11.674,5.785,11.66,5.8
            L0.535,18.373` }));
  }, v = { left: 0, top: 8 }, k = function(M) {
    var I = M.isDisabled, E = M.onClick, T = p.useContext(e.LocalizationContext).l10n, y = T && T.pageNavigation ? T.pageNavigation.goToPreviousPage : "Previous page";
    return p.createElement(e.Tooltip, { ariaControlsSuffix: "page-navigation-previous", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaLabel: y, isDisabled: I, testId: "page-navigation__previous-button", onClick: E }, p.createElement(c, null)), content: function() {
      return y;
    }, offset: v });
  }, a = function(M) {
    var I = M.store;
    return (M.children || function(E) {
      return p.createElement(k, { isDisabled: E.isDisabled, onClick: E.onClick });
    })({ isDisabled: W(I).currentPage <= 0, onClick: function() {
      var E = I.get("jumpToPreviousPage");
      E && E();
    } });
  }, f = function(M) {
    var I = M.isDisabled, E = M.onClick, T = p.useContext(e.LocalizationContext).l10n, y = T && T.pageNavigation ? T.pageNavigation.goToPreviousPage : "Previous page";
    return p.createElement(e.MenuItem, { icon: p.createElement(c, null), isDisabled: I, testId: "page-navigation__previous-menu", onClick: E }, y);
  }, C = function(M) {
    var I = M.children, E = M.store, T = Q(E).numberOfPages;
    return I ? I({ numberOfPages: T }) : p.createElement(p.Fragment, null, T);
  }, R = function(M) {
    var I = M.containerRef, E = M.numPages, T = M.store, y = W(T).currentPage, D = p.useRef(y);
    D.current = y;
    var j = p.useRef(!1), A = function() {
      j.current = !0;
    }, d = function() {
      j.current = !1;
    }, _ = function(F) {
      var U = I.current, V = j.current || document.activeElement && U.contains(document.activeElement);
      if (U && V) {
        var $, re, ge = F.altKey && F.key === "ArrowDown" || !F.shiftKey && !F.altKey && F.key === "PageDown", be = F.altKey && F.key === "ArrowUp" || !F.shiftKey && !F.altKey && F.key === "PageUp";
        if (ge) return F.preventDefault(), $ = T.get("jumpToPage"), re = D.current + 1, void ($ && re < E && $(re));
        if (be) return F.preventDefault(), void function() {
          var le = T.get("jumpToPage"), fe = D.current - 1;
          le && fe >= 0 && le(fe);
        }();
        if (e.isMac() ? F.metaKey && !F.ctrlKey : F.altKey) switch (F.key) {
          case "ArrowLeft":
            F.preventDefault(), function() {
              var le = T.get("jumpToPreviousDestination");
              le && le();
            }();
            break;
          case "ArrowRight":
            F.preventDefault(), function() {
              var le = T.get("jumpToNextDestination");
              le && le();
            }();
        }
      }
    };
    return p.useEffect(function() {
      var F = I.current;
      if (F) return document.addEventListener("keydown", _), F.addEventListener("mouseenter", A), F.addEventListener("mouseleave", d), function() {
        document.removeEventListener("keydown", _), F.removeEventListener("mouseenter", A), F.removeEventListener("mouseleave", d);
      };
    }, [I.current]), p.createElement(p.Fragment, null);
  };
  return pageNavigation_min.DownArrowIcon = n, pageNavigation_min.NextIcon = t, pageNavigation_min.PreviousIcon = c, pageNavigation_min.UpArrowIcon = H, pageNavigation_min.pageNavigationPlugin = function(M) {
    var I = p.useMemo(function() {
      return Object.assign({}, { enableShortcuts: !0 }, M);
    }, []), E = p.useMemo(function() {
      return e.createStore();
    }, []), T = function(A) {
      return p.createElement(S, l({}, A, { store: E }));
    }, y = function(A) {
      return p.createElement(s, l({}, A, { store: E }));
    }, D = function(A) {
      return p.createElement(b, l({}, A, { store: E }));
    }, j = function(A) {
      return p.createElement(a, l({}, A, { store: E }));
    };
    return { install: function(A) {
      E.update("jumpToDestination", A.jumpToDestination), E.update("jumpToNextDestination", A.jumpToNextDestination), E.update("jumpToNextPage", A.jumpToNextPage), E.update("jumpToPage", A.jumpToPage), E.update("jumpToPreviousDestination", A.jumpToPreviousDestination), E.update("jumpToPreviousPage", A.jumpToPreviousPage);
    }, renderViewer: function(A) {
      var d = A.slot;
      if (!I.enableShortcuts) return d;
      var _ = { children: p.createElement(p.Fragment, null, p.createElement(R, { containerRef: A.containerRef, numPages: A.doc.numPages, store: E }), d.children) };
      return l(l({}, d), _);
    }, onDocumentLoad: function(A) {
      E.update("doc", A.doc), E.update("numberOfPages", A.doc.numPages);
    }, onViewerStateChange: function(A) {
      return E.update("currentPage", A.pageIndex), A;
    }, jumpToNextPage: function() {
      var A = E.get("jumpToNextPage");
      A && A();
    }, jumpToPage: function(A) {
      var d = E.get("jumpToPage");
      d && d(A);
    }, jumpToPreviousPage: function() {
      var A = E.get("jumpToPreviousPage");
      A && A();
    }, CurrentPageInput: function() {
      return p.createElement(G, { store: E });
    }, CurrentPageLabel: function(A) {
      return p.createElement(N, l({}, A, { store: E }));
    }, GoToFirstPage: T, GoToFirstPageButton: function() {
      return p.createElement(T, null, function(A) {
        return p.createElement(P, l({}, A));
      });
    }, GoToFirstPageMenuItem: function(A) {
      return p.createElement(T, null, function(d) {
        return p.createElement(r, { isDisabled: d.isDisabled, onClick: function() {
          d.onClick(), A.onClick();
        } });
      });
    }, GoToLastPage: y, GoToLastPageButton: function() {
      return p.createElement(y, null, function(A) {
        return p.createElement(m, l({}, A));
      });
    }, GoToLastPageMenuItem: function(A) {
      return p.createElement(y, null, function(d) {
        return p.createElement(w, { isDisabled: d.isDisabled, onClick: function() {
          d.onClick(), A.onClick();
        } });
      });
    }, GoToNextPage: D, GoToNextPageButton: function() {
      return p.createElement(D, null, function(A) {
        return p.createElement(o, l({}, A));
      });
    }, GoToNextPageMenuItem: function(A) {
      return p.createElement(D, null, function(d) {
        return p.createElement(g, { isDisabled: d.isDisabled, onClick: function() {
          d.onClick(), A.onClick();
        } });
      });
    }, GoToPreviousPage: j, GoToPreviousPageButton: function() {
      return p.createElement(j, null, function(A) {
        return p.createElement(k, l({}, A));
      });
    }, GoToPreviousPageMenuItem: function(A) {
      return p.createElement(j, null, function(d) {
        return p.createElement(f, { isDisabled: d.isDisabled, onClick: function() {
          d.onClick(), A.onClick();
        } });
      });
    }, NumberOfPages: function(A) {
      return p.createElement(C, l({}, A, { store: E }));
    } };
  }, pageNavigation_min;
}
var pageNavigation = {}, hasRequiredPageNavigation;
function requirePageNavigation() {
  if (hasRequiredPageNavigation) return pageNavigation;
  hasRequiredPageNavigation = 1;
  var e = requireLib$h(), L = requireReact();
  function p(T) {
    var y = /* @__PURE__ */ Object.create(null);
    return T && Object.keys(T).forEach(function(D) {
      if (D !== "default") {
        var j = Object.getOwnPropertyDescriptor(T, D);
        Object.defineProperty(y, D, j.get ? j : {
          enumerable: !0,
          get: function() {
            return T[D];
          }
        });
      }
    }), y.default = T, Object.freeze(y);
  }
  var n = /* @__PURE__ */ p(L), t = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: `M2.32,2.966h19.452c0.552,0.001,1,0.449,0.999,1.001c0,0.182-0.05,0.36-0.144,0.516L12.9,20.552
            c-0.286,0.472-0.901,0.624-1.373,0.338c-0.138-0.084-0.254-0.2-0.338-0.338L1.465,4.483C1.179,4.01,1.331,3.396,1.804,3.11
            C1.96,3.016,2.138,2.966,2.32,2.966z` })
    );
  }, l = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: `M0.541,5.627L11.666,18.2c0.183,0.207,0.499,0.226,0.706,0.043c0.015-0.014,0.03-0.028,0.043-0.043
            L23.541,5.627` })
    );
  }, W = function() {
    return W = Object.assign || function(y) {
      for (var D, j = 1, A = arguments.length; j < A; j++) {
        D = arguments[j];
        for (var d in D) Object.prototype.hasOwnProperty.call(D, d) && (y[d] = D[d]);
      }
      return y;
    }, W.apply(this, arguments);
  }, Q = function(T) {
    var y = n.useState(T.get("currentPage") || 0), D = y[0], j = y[1], A = function(d) {
      j(d);
    };
    return e.useIsomorphicLayoutEffect(function() {
      return T.subscribe("currentPage", A), function() {
        T.unsubscribe("currentPage", A);
      };
    }, []), { currentPage: D };
  }, G = function(T) {
    var y = n.useState(T.get("numberOfPages") || 0), D = y[0], j = y[1], A = function(d) {
      j(d);
    };
    return n.useEffect(function() {
      return T.subscribe("numberOfPages", A), function() {
        T.unsubscribe("numberOfPages", A);
      };
    }, []), { numberOfPages: D };
  }, X = function(T) {
    var y = T.store, D = n.useContext(e.LocalizationContext).l10n, j = n.useState("1"), A = j[0], d = j[1], _ = Q(y).currentPage, F = G(y).numberOfPages;
    n.useEffect(function() {
      return d("".concat(_ + 1));
    }, [_]);
    var U = function() {
      var le = _ + 1;
      le < F && (d("".concat(le + 1)), $(le));
    }, V = function() {
      var le = _ - 1;
      le >= 0 && (d("".concat(le + 1)), $(le));
    }, $ = function(le) {
      var fe = y.get("jumpToPage");
      fe && fe(le);
    }, re = function() {
      var le = parseInt(A, 10);
      A === "" || le < 1 || le > F ? d("".concat(_ + 1)) : $(le - 1);
    }, ge = function(le) {
      switch (le.key) {
        case "ArrowUp":
          V();
          break;
        case "ArrowDown":
          U();
          break;
        case "Enter":
          re();
          break;
      }
    }, be = D && D.pageNavigation ? D.pageNavigation.enterPageNumber : "Enter a page number";
    return n.createElement(
      "span",
      { className: "rpv-page-navigation__current-page-input" },
      n.createElement(e.TextBox, { ariaLabel: be, testId: "page-navigation__current-page-input", type: "text", value: A, onChange: d, onKeyDown: ge })
    );
  }, N = function(T) {
    var y = T.children, D = T.doc, j = e.useIsMounted(), A = n.useState({
      loading: !0,
      labels: []
    }), d = A[0], _ = A[1];
    return n.useEffect(function() {
      D.getPageLabels().then(function(F) {
        j.current && _({ loading: !1, labels: F || [] });
      });
    }, [D.loadingTask.docId]), d.loading ? n.createElement(n.Fragment, null) : y(d.labels);
  }, H = function(T) {
    var y = n.useState(T.get("doc")), D = y[0], j = y[1], A = function(d) {
      j(d);
    };
    return n.useEffect(function() {
      return T.subscribe("doc", A), function() {
        T.unsubscribe("doc", A);
      };
    }, []), D;
  }, B = function(T) {
    var y = T.children, D = T.store, j = H(D), A = Q(D).currentPage, d = G(D).numberOfPages, _ = function(U) {
      return n.createElement(n.Fragment, null, U.currentPage + 1);
    }, F = y || _;
    return j ? n.createElement(N, { doc: j }, function(U) {
      var V = U.length === d && d > 0 ? U[A] : "";
      return F({
        currentPage: A,
        numberOfPages: d,
        pageLabel: V
      });
    }) : n.createElement(n.Fragment, null);
  }, P = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: `M21.783,21.034H2.332c-0.552,0-1-0.448-1-1c0-0.182,0.05-0.361,0.144-0.517L11.2,3.448
            c0.286-0.472,0.901-0.624,1.373-0.338c0.138,0.084,0.254,0.2,0.338,0.338l9.726,16.069c0.286,0.473,0.134,1.087-0.339,1.373
            C22.143,20.984,21.965,21.034,21.783,21.034z` })
    );
  }, S = { left: 0, top: 8 }, r = function(T) {
    var y = T.isDisabled, D = T.onClick, j = n.useContext(e.LocalizationContext).l10n, A = j && j.pageNavigation ? j.pageNavigation.goToFirstPage : "First page";
    return n.createElement(e.Tooltip, { ariaControlsSuffix: "page-navigation-first", position: e.Position.BottomCenter, target: n.createElement(
      e.MinimalButton,
      { ariaLabel: A, isDisabled: y, testId: "page-navigation__first-button", onClick: D },
      n.createElement(P, null)
    ), content: function() {
      return A;
    }, offset: S });
  }, u = function(T) {
    var y = T.children, D = T.store, j = Q(D).currentPage, A = function() {
      var F = D.get("jumpToPage");
      F && F(0);
    }, d = function(F) {
      return n.createElement(r, { isDisabled: F.isDisabled, onClick: F.onClick });
    }, _ = y || d;
    return _({
      isDisabled: j === 0,
      onClick: A
    });
  }, m = function(T) {
    var y = T.isDisabled, D = T.onClick, j = n.useContext(e.LocalizationContext).l10n, A = j && j.pageNavigation ? j.pageNavigation.goToFirstPage : "First page";
    return n.createElement(e.MenuItem, { icon: n.createElement(P, null), isDisabled: y, testId: "page-navigation__first-menu", onClick: D }, A);
  }, s = { left: 0, top: 8 }, w = function(T) {
    var y = T.isDisabled, D = T.onClick, j = n.useContext(e.LocalizationContext).l10n, A = j && j.pageNavigation ? j.pageNavigation.goToLastPage : "Last page";
    return n.createElement(e.Tooltip, { ariaControlsSuffix: "page-navigation-last", position: e.Position.BottomCenter, target: n.createElement(
      e.MinimalButton,
      { ariaLabel: A, isDisabled: y, testId: "page-navigation__last-button", onClick: D },
      n.createElement(t, null)
    ), content: function() {
      return A;
    }, offset: s });
  }, i = function(T) {
    var y = T.children, D = T.store, j = Q(D).currentPage, A = G(D).numberOfPages, d = function() {
      var U = D.get("jumpToPage");
      U && U(A - 1);
    }, _ = function(U) {
      return n.createElement(w, { isDisabled: U.isDisabled, onClick: U.onClick });
    }, F = y || _;
    return F({
      isDisabled: j + 1 >= A,
      onClick: d
    });
  }, o = function(T) {
    var y = T.isDisabled, D = T.onClick, j = n.useContext(e.LocalizationContext).l10n, A = j && j.pageNavigation ? j.pageNavigation.goToLastPage : "Last page";
    return n.createElement(e.MenuItem, { icon: n.createElement(t, null), isDisabled: y, testId: "page-navigation__last-menu", onClick: D }, A);
  }, b = { left: 0, top: 8 }, g = function(T) {
    var y = T.isDisabled, D = T.onClick, j = n.useContext(e.LocalizationContext).l10n, A = j && j.pageNavigation ? j.pageNavigation.goToNextPage : "Next page";
    return n.createElement(e.Tooltip, { ariaControlsSuffix: "page-navigation-next", position: e.Position.BottomCenter, target: n.createElement(
      e.MinimalButton,
      { ariaLabel: A, isDisabled: y, testId: "page-navigation__next-button", onClick: D },
      n.createElement(l, null)
    ), content: function() {
      return A;
    }, offset: b });
  }, c = function(T) {
    var y = T.children, D = T.store, j = Q(D).currentPage, A = G(D).numberOfPages, d = function() {
      var U = D.get("jumpToNextPage");
      U && U();
    }, _ = function(U) {
      return n.createElement(g, { onClick: U.onClick, isDisabled: U.isDisabled });
    }, F = y || _;
    return F({
      isDisabled: j + 1 >= A,
      onClick: d
    });
  }, v = function(T) {
    var y = T.isDisabled, D = T.onClick, j = n.useContext(e.LocalizationContext).l10n, A = j && j.pageNavigation ? j.pageNavigation.goToNextPage : "Next page";
    return n.createElement(e.MenuItem, { icon: n.createElement(l, null), isDisabled: y, testId: "page-navigation__next-menu", onClick: D }, A);
  }, k = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: `M23.535,18.373L12.409,5.8c-0.183-0.207-0.499-0.226-0.706-0.043C11.688,5.77,11.674,5.785,11.66,5.8
            L0.535,18.373` })
    );
  }, a = { left: 0, top: 8 }, f = function(T) {
    var y = T.isDisabled, D = T.onClick, j = n.useContext(e.LocalizationContext).l10n, A = j && j.pageNavigation ? j.pageNavigation.goToPreviousPage : "Previous page";
    return n.createElement(e.Tooltip, { ariaControlsSuffix: "page-navigation-previous", position: e.Position.BottomCenter, target: n.createElement(
      e.MinimalButton,
      { ariaLabel: A, isDisabled: y, testId: "page-navigation__previous-button", onClick: D },
      n.createElement(k, null)
    ), content: function() {
      return A;
    }, offset: a });
  }, C = function(T) {
    var y = T.store, D = T.children, j = Q(y).currentPage, A = function() {
      var F = y.get("jumpToPreviousPage");
      F && F();
    }, d = function(F) {
      return n.createElement(f, { isDisabled: F.isDisabled, onClick: F.onClick });
    }, _ = D || d;
    return _({
      isDisabled: j <= 0,
      onClick: A
    });
  }, R = function(T) {
    var y = T.isDisabled, D = T.onClick, j = n.useContext(e.LocalizationContext).l10n, A = j && j.pageNavigation ? j.pageNavigation.goToPreviousPage : "Previous page";
    return n.createElement(e.MenuItem, { icon: n.createElement(k, null), isDisabled: y, testId: "page-navigation__previous-menu", onClick: D }, A);
  }, M = function(T) {
    var y = T.children, D = T.store, j = G(D).numberOfPages;
    return y ? y({ numberOfPages: j }) : n.createElement(n.Fragment, null, j);
  }, I = function(T) {
    var y = T.containerRef, D = T.numPages, j = T.store, A = Q(j).currentPage, d = n.useRef(A);
    d.current = A;
    var _ = n.useRef(!1), F = function() {
      _.current = !0;
    }, U = function() {
      _.current = !1;
    }, V = function() {
      var le = j.get("jumpToPage"), fe = d.current + 1;
      le && fe < D && le(fe);
    }, $ = function() {
      var le = j.get("jumpToPage"), fe = d.current - 1;
      le && fe >= 0 && le(fe);
    }, re = function() {
      var le = j.get("jumpToNextDestination");
      le && le();
    }, ge = function() {
      var le = j.get("jumpToPreviousDestination");
      le && le();
    }, be = function(le) {
      var fe = y.current, Ae = _.current || document.activeElement && fe.contains(document.activeElement);
      if (!(!fe || !Ae)) {
        var qe = le.altKey && le.key === "ArrowDown" || !le.shiftKey && !le.altKey && le.key === "PageDown", ye = le.altKey && le.key === "ArrowUp" || !le.shiftKey && !le.altKey && le.key === "PageUp";
        if (qe) {
          le.preventDefault(), V();
          return;
        }
        if (ye) {
          le.preventDefault(), $();
          return;
        }
        var ce = e.isMac() ? le.metaKey && !le.ctrlKey : le.altKey;
        if (ce)
          switch (le.key) {
            case "ArrowLeft":
              le.preventDefault(), ge();
              break;
            case "ArrowRight":
              le.preventDefault(), re();
              break;
          }
      }
    };
    return n.useEffect(function() {
      var le = y.current;
      if (le)
        return document.addEventListener("keydown", be), le.addEventListener("mouseenter", F), le.addEventListener("mouseleave", U), function() {
          document.removeEventListener("keydown", be), le.removeEventListener("mouseenter", F), le.removeEventListener("mouseleave", U);
        };
    }, [y.current]), n.createElement(n.Fragment, null);
  }, E = function(T) {
    var y = n.useMemo(function() {
      return Object.assign({}, { enableShortcuts: !0 }, T);
    }, []), D = n.useMemo(function() {
      return e.createStore();
    }, []), j = function() {
      return n.createElement(X, { store: D });
    }, A = function(ce) {
      return n.createElement(B, W({}, ce, { store: D }));
    }, d = function(ce) {
      return n.createElement(u, W({}, ce, { store: D }));
    }, _ = function() {
      return n.createElement(d, null, function(ce) {
        return n.createElement(r, W({}, ce));
      });
    }, F = function(ce) {
      return n.createElement(d, null, function(q) {
        return n.createElement(m, { isDisabled: q.isDisabled, onClick: function() {
          q.onClick(), ce.onClick();
        } });
      });
    }, U = function(ce) {
      return n.createElement(i, W({}, ce, { store: D }));
    }, V = function() {
      return n.createElement(U, null, function(ce) {
        return n.createElement(w, W({}, ce));
      });
    }, $ = function(ce) {
      return n.createElement(U, null, function(q) {
        return n.createElement(o, { isDisabled: q.isDisabled, onClick: function() {
          q.onClick(), ce.onClick();
        } });
      });
    }, re = function(ce) {
      return n.createElement(c, W({}, ce, { store: D }));
    }, ge = function() {
      return n.createElement(re, null, function(ce) {
        return n.createElement(g, W({}, ce));
      });
    }, be = function(ce) {
      return n.createElement(re, null, function(q) {
        return n.createElement(v, { isDisabled: q.isDisabled, onClick: function() {
          q.onClick(), ce.onClick();
        } });
      });
    }, le = function(ce) {
      return n.createElement(C, W({}, ce, { store: D }));
    }, fe = function() {
      return n.createElement(le, null, function(ce) {
        return n.createElement(f, W({}, ce));
      });
    }, Ae = function(ce) {
      return n.createElement(le, null, function(q) {
        return n.createElement(R, { isDisabled: q.isDisabled, onClick: function() {
          q.onClick(), ce.onClick();
        } });
      });
    }, qe = function(ce) {
      return n.createElement(M, W({}, ce, { store: D }));
    }, ye = function(ce) {
      var q = ce.slot;
      if (!y.enableShortcuts)
        return q;
      var Z = {
        children: n.createElement(
          n.Fragment,
          null,
          n.createElement(I, { containerRef: ce.containerRef, numPages: ce.doc.numPages, store: D }),
          q.children
        )
      };
      return W(W({}, q), Z);
    };
    return {
      install: function(ce) {
        D.update("jumpToDestination", ce.jumpToDestination), D.update("jumpToNextDestination", ce.jumpToNextDestination), D.update("jumpToNextPage", ce.jumpToNextPage), D.update("jumpToPage", ce.jumpToPage), D.update("jumpToPreviousDestination", ce.jumpToPreviousDestination), D.update("jumpToPreviousPage", ce.jumpToPreviousPage);
      },
      renderViewer: ye,
      onDocumentLoad: function(ce) {
        D.update("doc", ce.doc), D.update("numberOfPages", ce.doc.numPages);
      },
      onViewerStateChange: function(ce) {
        return D.update("currentPage", ce.pageIndex), ce;
      },
      jumpToNextPage: function() {
        var ce = D.get("jumpToNextPage");
        ce && ce();
      },
      jumpToPage: function(ce) {
        var q = D.get("jumpToPage");
        q && q(ce);
      },
      jumpToPreviousPage: function() {
        var ce = D.get("jumpToPreviousPage");
        ce && ce();
      },
      CurrentPageInput: j,
      CurrentPageLabel: A,
      GoToFirstPage: d,
      GoToFirstPageButton: _,
      GoToFirstPageMenuItem: F,
      GoToLastPage: U,
      GoToLastPageButton: V,
      GoToLastPageMenuItem: $,
      GoToNextPage: re,
      GoToNextPageButton: ge,
      GoToNextPageMenuItem: be,
      GoToPreviousPage: le,
      GoToPreviousPageButton: fe,
      GoToPreviousPageMenuItem: Ae,
      NumberOfPages: qe
    };
  };
  return pageNavigation.DownArrowIcon = t, pageNavigation.NextIcon = l, pageNavigation.PreviousIcon = k, pageNavigation.UpArrowIcon = P, pageNavigation.pageNavigationPlugin = E, pageNavigation;
}
var hasRequiredLib$9;
function requireLib$9() {
  if (hasRequiredLib$9) return lib$7.exports;
  hasRequiredLib$9 = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$7.exports = requirePageNavigation_min() : lib$7.exports = requirePageNavigation(), lib$7.exports;
}
var lib$6 = { exports: {} }, print_min = {}, hasRequiredPrint_min;
function requirePrint_min() {
  if (hasRequiredPrint_min) return print_min;
  hasRequiredPrint_min = 1;
  var e = {}, L = requireLib$h(), p = requireReact(), n = requireReactDom();
  function t(i) {
    var o = /* @__PURE__ */ Object.create(null);
    return i && Object.keys(i).forEach(function(b) {
      if (b !== "default") {
        var g = Object.getOwnPropertyDescriptor(i, b);
        Object.defineProperty(o, b, g.get ? g : { enumerable: !0, get: function() {
          return i[b];
        } });
      }
    }), o.default = i, Object.freeze(o);
  }
  var l, W = t(p), Q = function() {
    return W.createElement(L.Icon, { size: 16 }, W.createElement("path", { d: `M7.5,19.499h9 M7.5,16.499h9 M5.5,16.5h-3c-1.103-0.003-1.997-0.897-2-2v-6c0.003-1.103,0.897-1.997,2-2h19
            c1.103,0.003,1.997,0.897,2,2v6c-0.003,1.103-0.897,1.997-2,2h-3
            M5.5,4.5v-4h9.586c0.265,0,0.52,0.105,0.707,0.293l2.414,2.414
            C18.395,3.394,18.5,3.649,18.5,3.914V4.5
            M18.5,22.5c0,0.552-0.448,1-1,1h-11c-0.552,0-1-0.448-1-1v-9h13V22.5z
            M3.5,8.499
            c0.552,0,1,0.448,1,1s-0.448,1-1,1s-1-0.448-1-1S2.948,8.499,3.5,8.499z
            M14.5,0.499v4h4` }));
  }, G = function() {
    return G = Object.assign || function(i) {
      for (var o, b = 1, g = arguments.length; b < g; b++) for (var c in o = arguments[b]) Object.prototype.hasOwnProperty.call(o, c) && (i[c] = o[c]);
      return i;
    }, G.apply(this, arguments);
  }, X = { left: 0, top: 8 }, N = function(i) {
    var o = i.enableShortcuts, b = i.onClick, g = W.useContext(L.LocalizationContext).l10n, c = g && g.print ? g.print.print : "Print", v = o ? L.isMac() ? "Meta+P" : "Ctrl+P" : "";
    return W.createElement(L.Tooltip, { ariaControlsSuffix: "print", position: L.Position.BottomCenter, target: W.createElement(L.MinimalButton, { ariaKeyShortcuts: v, ariaLabel: c, testId: "print__button", onClick: b }, W.createElement(Q, null)), content: function() {
      return c;
    }, offset: X });
  };
  (function(i) {
    i.CheckingPermission = "CheckingPermission", i.Inactive = "Inactive", i.Preparing = "Preparing", i.Cancelled = "Cancelled", i.Ready = "Ready";
  })(l || (l = {}));
  var H = function(i) {
    var o = i.children, b = i.enableShortcuts, g = i.store;
    return (o || N)({ enableShortcuts: b, onClick: function() {
      g.update("printStatus", l.CheckingPermission);
    } });
  }, B = function(i) {
    var o = i.doc, b = i.store, g = W.useContext(L.LocalizationContext).l10n, c = W.useState(!0), v = c[0], k = c[1];
    return W.useEffect(function() {
      o.getPermissions().then(function(a) {
        a === null || a.includes(4) || a.includes(2048) ? b.update("printStatus", l.Preparing) : k(!1);
      });
    }, []), v ? W.createElement(W.Fragment, null) : W.createElement(L.Modal, { ariaControlsSuffix: "print-permission", closeOnClickOutside: !1, closeOnEscape: !1, content: function(a) {
      return W.createElement(W.Fragment, null, W.createElement("div", { className: "rpv-print__permission-body" }, g && g.print ? g.print.disallowPrint : "The document does not allow to print"), W.createElement("div", { className: "rpv-print__permission-footer" }, W.createElement(L.Button, { onClick: function() {
        a(), b.update("printStatus", l.Cancelled);
      } }, g && g.print ? g.print.close : "Close")));
    }, isOpened: !0 });
  }, P = function(i) {
    var o = i.numLoadedPages, b = i.numPages, g = i.onCancel, c = W.useContext(L.LocalizationContext).l10n, v = W.useContext(L.ThemeContext).direction === L.TextDirection.RightToLeft, k = Math.floor(100 * o / b);
    return W.createElement("div", { className: "rpv-print__progress" }, W.createElement("div", { className: L.classNames({ "rpv-print__progress-body": !0, "rpv-print__progress-body--rtl": v }) }, W.createElement("div", { className: "rpv-print__progress-message" }, c && c.print ? c.print.preparingDocument : "Preparing document ..."), W.createElement("div", { className: "rpv-print__progress-bar" }, W.createElement(L.ProgressBar, { progress: k })), W.createElement(L.Button, { onClick: g }, c && c.print ? c.print.cancel : "Cancel")));
  }, S = function(i) {
    var o = i.canvas, b = i.page, g = i.pageHeight, c = i.pageIndex, v = i.pageWidth, k = i.rotation, a = i.onLoad, f = L.useIsMounted(), C = W.useRef(), R = W.useState(""), M = R[0], I = R[1], E = W.useMemo(function() {
      return typeof process < "u" && e.JEST_WORKER_ID !== void 0;
    }, []);
    return W.useEffect(function() {
      var T = C.current;
      T && T.cancel();
      var y = 150 / 72;
      o.height = Math.floor(g * y), o.width = Math.floor(v * y);
      var D = o.getContext("2d");
      D.save(), D.fillStyle = "rgb(255, 255, 255)", D.fillRect(0, 0, o.width, o.height), D.restore();
      var j = b.getViewport({ rotation: k, scale: 1 });
      C.current = b.render({ canvasContext: D, intent: "print", transform: [y, 0, 0, y, 0, 0], viewport: j }), C.current.promise.then(function() {
        "toBlob" in o && "createObjectURL" in URL ? o.toBlob(function(A) {
          f.current && I(URL.createObjectURL(A)), E && a();
        }) : (f.current && I(o.toDataURL()), E && a());
      }, function() {
      });
    }, []), M && W.createElement("div", { className: "rpv-print__page" }, W.createElement("img", { "data-testid": "print__thumbnail-".concat(c), src: M, onLoad: function() {
      E || a();
    } }));
  }, r = function(i) {
    var o = i.canvas, b = i.doc, g = i.pageIndex, c = i.pageRotation, v = i.pageSize, k = i.rotation, a = i.shouldRender, f = i.onLoad, C = L.useIsMounted(), R = W.useState(null), M = R[0], I = R[1], E = Math.abs(k + c) % 180 == 0;
    W.useEffect(function() {
      a && L.getPage(b, g).then(function(y) {
        C.current && I(y);
      });
    }, [a]);
    var T = (v.rotation + k + c) % 360;
    return M && W.createElement(S, { canvas: o, page: M, pageHeight: E ? v.pageHeight : v.pageWidth, pageIndex: g, pageWidth: E ? v.pageWidth : v.pageHeight, rotation: T, onLoad: f });
  }, u = function(i) {
    var o = i.doc, b = i.numLoadedPages, g = i.pagesRotation, c = i.pageSizes, v = i.printPages, k = i.printStatus, a = i.rotation, f = i.onCancel, C = i.onLoad, R = W.useMemo(function() {
      return document.createElement("canvas");
    }, []), M = W.useMemo(function() {
      var T = document.querySelector(".rpv-print__zone");
      if (T) return T;
      var y = document.createElement("div");
      return y.classList.add("rpv-print__zone"), y.setAttribute("data-testid", "print__zone"), document.body.appendChild(y), y;
    }, []);
    W.useEffect(function() {
      k === l.Ready && (document.documentElement.classList.add("rpv-print__html-printing"), document.body.classList.add("rpv-print__body-printing"), window.print());
      var T = function() {
        if (k === l.Ready) {
          document.documentElement.classList.remove("rpv-print__html-printing"), document.body.classList.remove("rpv-print__body-printing");
          var y = document.querySelectorAll(".rpv-print__zone");
          y && y.forEach(function(D) {
            D.parentElement.removeChild(D);
          }), R.height = 0, R.width = 0, document.removeEventListener("mousemove", T), f();
        }
      };
      return document.addEventListener("mousemove", T), function() {
        return document.removeEventListener("mousemove", T);
      };
    }, [k]);
    var I = c[0].pageHeight, E = c[0].pageWidth;
    return n.createPortal(W.createElement(W.Fragment, null, v.map(function(T, y) {
      return W.createElement(r, { key: T, canvas: R, doc: o, pageIndex: T, pageRotation: g.has(T) ? g.get(T) : 0, pageSize: c[T], rotation: a, shouldRender: y === b, onLoad: C });
    }), W.createElement("style", { dangerouslySetInnerHTML: { __html: "@page { size: ".concat(E, "pt ").concat(I, "pt }") } })), M);
  }, m = function(i) {
    var o = i.doc, b = i.pagesRotation, g = i.pageSizes, c = i.renderProgressBar, v = i.rotation, k = i.setPages, a = i.store, f = W.useState(l.Inactive), C = f[0], R = f[1], M = W.useState(0), I = M[0], E = M[1], T = W.useMemo(function() {
      var A = o.numPages;
      return k(o).filter(function(d) {
        return d >= 0 && d < A;
      });
    }, [o, k]), y = T.length, D = function() {
      E(0), R(l.Inactive);
    }, j = function(A) {
      return R(A);
    };
    return W.useEffect(function() {
      return a.subscribe("printStatus", j), function() {
        a.unsubscribe("printStatus", j);
      };
    }, []), W.createElement(W.Fragment, null, C === l.CheckingPermission && W.createElement(B, { doc: o, store: a }), C === l.Preparing && (c ? c(I, y, D) : W.createElement(P, { numLoadedPages: I, numPages: y, onCancel: D })), (C === l.Preparing || C === l.Ready) && I <= y && W.createElement(u, { doc: o, numLoadedPages: I, pagesRotation: b, pageSizes: g, printPages: T, printStatus: C, rotation: v, onCancel: D, onLoad: function() {
      var A = I + 1;
      A <= y && (E(A), A === y && R(l.Ready));
    } }));
  }, s = function(i) {
    var o = i.onClick, b = W.useContext(L.LocalizationContext).l10n, g = b && b.print ? b.print.print : "Print";
    return W.createElement(L.MenuItem, { icon: W.createElement(Q, null), testId: "print__menu", onClick: o }, g);
  }, w = function(i) {
    var o = i.containerRef, b = i.store, g = function(c) {
      if (!c.shiftKey && !c.altKey && c.key === "p" && (L.isMac() ? c.metaKey : c.ctrlKey)) {
        var v = o.current;
        v && document.activeElement && v.contains(document.activeElement) && (c.preventDefault(), b.update("printStatus", l.Preparing));
      }
    };
    return W.useEffect(function() {
      if (o.current) return document.addEventListener("keydown", g), function() {
        document.removeEventListener("keydown", g);
      };
    }, [o.current]), W.createElement(W.Fragment, null);
  };
  return print_min.PrintIcon = Q, print_min.getAllPagesNumbers = function(i) {
    return Array(i.numPages).fill(0).map(function(o, b) {
      return b;
    });
  }, print_min.getCustomPagesNumbers = function(i) {
    return function(o) {
      var b, g = [];
      return i.replace(/\s+/g, "").split(",").forEach(function(c) {
        var v, k, a = c.split("-").map(function(f) {
          return parseInt(f, 10);
        }).filter(function(f) {
          return Number.isInteger(f);
        });
        a.length === 1 ? g.push(a[0] - 1) : a.length === 2 && g.push.apply(g, (v = a[0] - 1, k = a[1] - 1, Array(k - v + 1).fill(0).map(function(f, C) {
          return v + C;
        })));
      }), (b = g, b.filter(function(c) {
        return b.indexOf(c) === b.lastIndexOf(c);
      })).filter(function(c) {
        return c >= 0 && c < o.numPages;
      });
    };
  }, print_min.getEvenPagesNumbers = function(i) {
    return Array(i.numPages).fill(0).map(function(o, b) {
      return b;
    }).filter(function(o) {
      return (o + 1) % 2 == 0;
    });
  }, print_min.getOddPagesNumbers = function(i) {
    return Array(i.numPages).fill(0).map(function(o, b) {
      return b;
    }).filter(function(o) {
      return (o + 1) % 2 == 1;
    });
  }, print_min.printPlugin = function(i) {
    var o = W.useMemo(function() {
      return Object.assign({}, { enableShortcuts: !0, setPages: function(c) {
        return Array(c.numPages).fill(0).map(function(v, k) {
          return k;
        });
      } }, i);
    }, []), b = W.useMemo(function() {
      return L.createStore({ printStatus: l.Inactive });
    }, []), g = function(c) {
      return W.createElement(H, G({ enableShortcuts: o.enableShortcuts }, c, { store: b }));
    };
    return { print: function() {
      b.update("printStatus", l.CheckingPermission);
    }, renderViewer: function(c) {
      var v = c.slot, k = { children: W.createElement(W.Fragment, null, o.enableShortcuts && W.createElement(w, { containerRef: c.containerRef, store: b }), W.createElement(m, { doc: c.doc, pagesRotation: c.pagesRotation, pageSizes: c.pageSizes, renderProgressBar: i == null ? void 0 : i.renderProgressBar, rotation: c.rotation, setPages: o.setPages, store: b }), v.children) };
      return G(G({}, v), k);
    }, Print: g, PrintButton: function() {
      return W.createElement(g, null, function(c) {
        return W.createElement(N, G({}, c));
      });
    }, PrintMenuItem: function(c) {
      return W.createElement(g, null, function(v) {
        return W.createElement(s, { onClick: function() {
          v.onClick(), c.onClick();
        } });
      });
    }, setPages: function(c) {
      o.setPages = c;
    } };
  }, print_min;
}
var print = {}, hasRequiredPrint;
function requirePrint() {
  if (hasRequiredPrint) return print;
  hasRequiredPrint = 1;
  var e = {}, L = requireLib$h(), p = requireReact(), n = requireReactDom();
  function t(R) {
    var M = /* @__PURE__ */ Object.create(null);
    return R && Object.keys(R).forEach(function(I) {
      if (I !== "default") {
        var E = Object.getOwnPropertyDescriptor(R, I);
        Object.defineProperty(M, I, E.get ? E : {
          enumerable: !0,
          get: function() {
            return R[I];
          }
        });
      }
    }), M.default = R, Object.freeze(M);
  }
  var l = /* @__PURE__ */ t(p), W = function(R) {
    return Array(R.numPages).fill(0).map(function(M, I) {
      return I;
    });
  }, Q = function(R, M) {
    return Array(M - R + 1).fill(0).map(function(I, E) {
      return R + E;
    });
  }, G = function(R) {
    return R.filter(function(M) {
      return R.indexOf(M) === R.lastIndexOf(M);
    });
  }, X = function(R) {
    return function(M) {
      var I = [];
      return R.replace(/\s+/g, "").split(",").forEach(function(E) {
        var T = E.split("-").map(function(y) {
          return parseInt(y, 10);
        }).filter(function(y) {
          return Number.isInteger(y);
        });
        T.length === 1 ? I.push(T[0] - 1) : T.length === 2 && I.push.apply(I, Q(T[0] - 1, T[1] - 1));
      }), G(I).filter(function(E) {
        return E >= 0 && E < M.numPages;
      });
    };
  }, N = function(R) {
    return Array(R.numPages).fill(0).map(function(M, I) {
      return I;
    }).filter(function(M) {
      return (M + 1) % 2 === 0;
    });
  }, H = function(R) {
    return Array(R.numPages).fill(0).map(function(M, I) {
      return I;
    }).filter(function(M) {
      return (M + 1) % 2 === 1;
    });
  }, B = function() {
    return l.createElement(
      L.Icon,
      { size: 16 },
      l.createElement("path", { d: `M7.5,19.499h9 M7.5,16.499h9 M5.5,16.5h-3c-1.103-0.003-1.997-0.897-2-2v-6c0.003-1.103,0.897-1.997,2-2h19
            c1.103,0.003,1.997,0.897,2,2v6c-0.003,1.103-0.897,1.997-2,2h-3
            M5.5,4.5v-4h9.586c0.265,0,0.52,0.105,0.707,0.293l2.414,2.414
            C18.395,3.394,18.5,3.649,18.5,3.914V4.5
            M18.5,22.5c0,0.552-0.448,1-1,1h-11c-0.552,0-1-0.448-1-1v-9h13V22.5z
            M3.5,8.499
            c0.552,0,1,0.448,1,1s-0.448,1-1,1s-1-0.448-1-1S2.948,8.499,3.5,8.499z
            M14.5,0.499v4h4` })
    );
  }, P = function() {
    return P = Object.assign || function(M) {
      for (var I, E = 1, T = arguments.length; E < T; E++) {
        I = arguments[E];
        for (var y in I) Object.prototype.hasOwnProperty.call(I, y) && (M[y] = I[y]);
      }
      return M;
    }, P.apply(this, arguments);
  }, S = { left: 0, top: 8 }, r = function(R) {
    var M = R.enableShortcuts, I = R.onClick, E = l.useContext(L.LocalizationContext).l10n, T = E && E.print ? E.print.print : "Print", y = M ? L.isMac() ? "Meta+P" : "Ctrl+P" : "";
    return l.createElement(L.Tooltip, { ariaControlsSuffix: "print", position: L.Position.BottomCenter, target: l.createElement(
      L.MinimalButton,
      { ariaKeyShortcuts: y, ariaLabel: T, testId: "print__button", onClick: I },
      l.createElement(B, null)
    ), content: function() {
      return T;
    }, offset: S });
  }, u;
  (function(R) {
    R.CheckingPermission = "CheckingPermission", R.Inactive = "Inactive", R.Preparing = "Preparing", R.Cancelled = "Cancelled", R.Ready = "Ready";
  })(u || (u = {}));
  var m = function(R) {
    var M = R.children, I = R.enableShortcuts, E = R.store, T = function() {
      E.update("printStatus", u.CheckingPermission);
    }, y = M || r;
    return y({
      enableShortcuts: I,
      onClick: T
    });
  }, s = 4, w = 2048, i = function(R) {
    var M = R.doc, I = R.store, E = l.useContext(L.LocalizationContext).l10n, T = l.useState(!0), y = T[0], D = T[1];
    return l.useEffect(function() {
      M.getPermissions().then(function(j) {
        var A = j === null || j.includes(s) || j.includes(w);
        A ? I.update("printStatus", u.Preparing) : D(!1);
      });
    }, []), y ? l.createElement(l.Fragment, null) : l.createElement(L.Modal, { ariaControlsSuffix: "print-permission", closeOnClickOutside: !1, closeOnEscape: !1, content: function(j) {
      var A = function() {
        j(), I.update("printStatus", u.Cancelled);
      };
      return l.createElement(
        l.Fragment,
        null,
        l.createElement("div", { className: "rpv-print__permission-body" }, E && E.print ? E.print.disallowPrint : "The document does not allow to print"),
        l.createElement(
          "div",
          { className: "rpv-print__permission-footer" },
          l.createElement(L.Button, { onClick: A }, E && E.print ? E.print.close : "Close")
        )
      );
    }, isOpened: !0 });
  }, o = function(R) {
    var M = R.numLoadedPages, I = R.numPages, E = R.onCancel, T = l.useContext(L.LocalizationContext).l10n, y = l.useContext(L.ThemeContext).direction, D = y === L.TextDirection.RightToLeft, j = Math.floor(M * 100 / I);
    return l.createElement(
      "div",
      { className: "rpv-print__progress" },
      l.createElement(
        "div",
        { className: L.classNames({
          "rpv-print__progress-body": !0,
          "rpv-print__progress-body--rtl": D
        }) },
        l.createElement("div", { className: "rpv-print__progress-message" }, T && T.print ? T.print.preparingDocument : "Preparing document ..."),
        l.createElement(
          "div",
          { className: "rpv-print__progress-bar" },
          l.createElement(L.ProgressBar, { progress: j })
        ),
        l.createElement(L.Button, { onClick: E }, T && T.print ? T.print.cancel : "Cancel")
      )
    );
  }, b = function() {
    return typeof process < "u" && e.JEST_WORKER_ID !== void 0;
  }, g = function(R) {
    var M = R.canvas, I = R.page, E = R.pageHeight, T = R.pageIndex, y = R.pageWidth, D = R.rotation, j = R.onLoad, A = L.useIsMounted(), d = l.useRef(), _ = l.useState(""), F = _[0], U = _[1], V = l.useMemo(function() {
      return b();
    }, []), $ = function() {
      V || j();
    };
    return l.useEffect(function() {
      var re = d.current;
      re && re.cancel();
      var ge = 150 / 72;
      M.height = Math.floor(E * ge), M.width = Math.floor(y * ge);
      var be = M.getContext("2d");
      be.save(), be.fillStyle = "rgb(255, 255, 255)", be.fillRect(0, 0, M.width, M.height), be.restore();
      var le = I.getViewport({ rotation: D, scale: 1 });
      d.current = I.render({
        canvasContext: be,
        intent: "print",
        transform: [ge, 0, 0, ge, 0, 0],
        viewport: le
      }), d.current.promise.then(function() {
        "toBlob" in M && "createObjectURL" in URL ? M.toBlob(function(fe) {
          A.current && U(URL.createObjectURL(fe)), V && j();
        }) : (A.current && U(M.toDataURL()), V && j());
      }, function() {
      });
    }, []), F && l.createElement(
      "div",
      { className: "rpv-print__page" },
      l.createElement("img", { "data-testid": "print__thumbnail-".concat(T), src: F, onLoad: $ })
    );
  }, c = function(R) {
    var M = R.canvas, I = R.doc, E = R.pageIndex, T = R.pageRotation, y = R.pageSize, D = R.rotation, j = R.shouldRender, A = R.onLoad, d = L.useIsMounted(), _ = l.useState(null), F = _[0], U = _[1], V = Math.abs(D + T) % 180 === 0;
    l.useEffect(function() {
      j && L.getPage(I, E).then(function(re) {
        d.current && U(re);
      });
    }, [j]);
    var $ = (y.rotation + D + T) % 360;
    return F && l.createElement(g, { canvas: M, page: F, pageHeight: V ? y.pageHeight : y.pageWidth, pageIndex: E, pageWidth: V ? y.pageWidth : y.pageHeight, rotation: $, onLoad: A });
  }, v = function(R) {
    var M = R.doc, I = R.numLoadedPages, E = R.pagesRotation, T = R.pageSizes, y = R.printPages, D = R.printStatus, j = R.rotation, A = R.onCancel, d = R.onLoad, _ = l.useMemo(function() {
      return document.createElement("canvas");
    }, []), F = l.useMemo(function() {
      var $ = document.querySelector(".rpv-print__zone");
      if ($)
        return $;
      var re = document.createElement("div");
      return re.classList.add("rpv-print__zone"), re.setAttribute("data-testid", "print__zone"), document.body.appendChild(re), re;
    }, []);
    l.useEffect(function() {
      D === u.Ready && (document.documentElement.classList.add("rpv-print__html-printing"), document.body.classList.add("rpv-print__body-printing"), window.print());
      var $ = function() {
        if (D === u.Ready) {
          document.documentElement.classList.remove("rpv-print__html-printing"), document.body.classList.remove("rpv-print__body-printing");
          var re = document.querySelectorAll(".rpv-print__zone");
          re && re.forEach(function(ge) {
            ge.parentElement.removeChild(ge);
          }), _.height = 0, _.width = 0, document.removeEventListener("mousemove", $), A();
        }
      };
      return document.addEventListener("mousemove", $), function() {
        return document.removeEventListener("mousemove", $);
      };
    }, [D]);
    var U = T[0].pageHeight, V = T[0].pageWidth;
    return n.createPortal(l.createElement(
      l.Fragment,
      null,
      y.map(function($, re) {
        return l.createElement(c, { key: $, canvas: _, doc: M, pageIndex: $, pageRotation: E.has($) ? E.get($) : 0, pageSize: T[$], rotation: j, shouldRender: re === I, onLoad: d });
      }),
      l.createElement("style", { dangerouslySetInnerHTML: {
        __html: "@page { size: ".concat(V, "pt ").concat(U, "pt }")
      } })
    ), F);
  }, k = function(R) {
    var M = R.doc, I = R.pagesRotation, E = R.pageSizes, T = R.renderProgressBar, y = R.rotation, D = R.setPages, j = R.store, A = l.useState(u.Inactive), d = A[0], _ = A[1], F = l.useState(0), U = F[0], V = F[1], $ = l.useMemo(function() {
      var fe = M.numPages;
      return D(M).filter(function(Ae) {
        return Ae >= 0 && Ae < fe;
      });
    }, [M, D]), re = $.length, ge = function() {
      V(0), _(u.Inactive);
    }, be = function(fe) {
      return _(fe);
    }, le = function() {
      var fe = U + 1;
      fe <= re && (V(fe), fe === re && _(u.Ready));
    };
    return l.useEffect(function() {
      return j.subscribe("printStatus", be), function() {
        j.unsubscribe("printStatus", be);
      };
    }, []), l.createElement(
      l.Fragment,
      null,
      d === u.CheckingPermission && l.createElement(i, { doc: M, store: j }),
      d === u.Preparing && (T ? T(U, re, ge) : l.createElement(o, { numLoadedPages: U, numPages: re, onCancel: ge })),
      (d === u.Preparing || d === u.Ready) && U <= re && l.createElement(v, { doc: M, numLoadedPages: U, pagesRotation: I, pageSizes: E, printPages: $, printStatus: d, rotation: y, onCancel: ge, onLoad: le })
    );
  }, a = function(R) {
    var M = R.onClick, I = l.useContext(L.LocalizationContext).l10n, E = I && I.print ? I.print.print : "Print";
    return l.createElement(L.MenuItem, { icon: l.createElement(B, null), testId: "print__menu", onClick: M }, E);
  }, f = function(R) {
    var M = R.containerRef, I = R.store, E = function(T) {
      if (!(T.shiftKey || T.altKey || T.key !== "p")) {
        var y = L.isMac() ? T.metaKey : T.ctrlKey;
        if (y) {
          var D = M.current;
          !D || !document.activeElement || !D.contains(document.activeElement) || (T.preventDefault(), I.update("printStatus", u.Preparing));
        }
      }
    };
    return l.useEffect(function() {
      var T = M.current;
      if (T)
        return document.addEventListener("keydown", E), function() {
          document.removeEventListener("keydown", E);
        };
    }, [M.current]), l.createElement(l.Fragment, null);
  }, C = function(R) {
    var M = l.useMemo(function() {
      return Object.assign({}, {
        enableShortcuts: !0,
        setPages: function(d) {
          return Array(d.numPages).fill(0).map(function(_, F) {
            return F;
          });
        }
      }, R);
    }, []), I = l.useMemo(function() {
      return L.createStore({
        printStatus: u.Inactive
      });
    }, []), E = function() {
      I.update("printStatus", u.CheckingPermission);
    }, T = function(d) {
      return l.createElement(m, P({ enableShortcuts: M.enableShortcuts }, d, { store: I }));
    }, y = function() {
      return l.createElement(T, null, function(d) {
        return l.createElement(r, P({}, d));
      });
    }, D = function(d) {
      return l.createElement(T, null, function(_) {
        return l.createElement(a, { onClick: function() {
          _.onClick(), d.onClick();
        } });
      });
    }, j = function(d) {
      var _ = d.slot, F = {
        children: l.createElement(
          l.Fragment,
          null,
          M.enableShortcuts && l.createElement(f, { containerRef: d.containerRef, store: I }),
          l.createElement(k, { doc: d.doc, pagesRotation: d.pagesRotation, pageSizes: d.pageSizes, renderProgressBar: R == null ? void 0 : R.renderProgressBar, rotation: d.rotation, setPages: M.setPages, store: I }),
          _.children
        )
      };
      return P(P({}, _), F);
    }, A = function(d) {
      M.setPages = d;
    };
    return {
      print: E,
      renderViewer: j,
      Print: T,
      PrintButton: y,
      PrintMenuItem: D,
      setPages: A
    };
  };
  return print.PrintIcon = B, print.getAllPagesNumbers = W, print.getCustomPagesNumbers = X, print.getEvenPagesNumbers = N, print.getOddPagesNumbers = H, print.printPlugin = C, print;
}
var hasRequiredLib$8;
function requireLib$8() {
  if (hasRequiredLib$8) return lib$6.exports;
  hasRequiredLib$8 = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$6.exports = requirePrint_min() : lib$6.exports = requirePrint(), lib$6.exports;
}
var lib$5 = { exports: {} }, properties_min = {}, hasRequiredProperties_min;
function requireProperties_min() {
  if (hasRequiredProperties_min) return properties_min;
  hasRequiredProperties_min = 1;
  var e = requireLib$h();
  function L(S) {
    var r = /* @__PURE__ */ Object.create(null);
    return S && Object.keys(S).forEach(function(u) {
      if (u !== "default") {
        var m = Object.getOwnPropertyDescriptor(S, u);
        Object.defineProperty(r, u, m.get ? m : { enumerable: !0, get: function() {
          return S[u];
        } });
      }
    }), r.default = S, Object.freeze(r);
  }
  var p = L(requireReact()), n = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: `M12,1.001c6.075,0,11,4.925,11,11s-4.925,11-11,11s-11-4.925-11-11S5.925,1.001,12,1.001z
            M14.5,17.005H13
            c-0.552,0-1-0.448-1-1v-6.5c0-0.276-0.224-0.5-0.5-0.5H10
            M11.745,6.504L11.745,6.504
            M11.745,6.5c-0.138,0-0.25,0.112-0.25,0.25
            S11.607,7,11.745,7s0.25-0.112,0.25-0.25S11.883,6.5,11.745,6.5` }));
  }, t = function() {
    return t = Object.assign || function(S) {
      for (var r, u = 1, m = arguments.length; u < m; u++) for (var s in r = arguments[u]) Object.prototype.hasOwnProperty.call(r, s) && (S[s] = r[s]);
      return S;
    }, t.apply(this, arguments);
  }, l = function(S) {
    var r = S.doc, u = S.render, m = p.useState(), s = m[0], w = m[1];
    return p.useEffect(function() {
      r.getMetadata().then(function(i) {
        return Promise.resolve(i);
      }).then(function(i) {
        return r.getDownloadInfo().then(function(o) {
          return Promise.resolve({ fileName: i.contentDispositionFilename || "", info: i.info, length: o.length });
        });
      }).then(function(i) {
        w(i);
      });
    }, []), s ? u(s) : p.createElement("div", { className: "rpv-properties__loader" }, p.createElement(e.Spinner, null));
  }, W = function(S) {
    var r = S.label, u = S.value, m = p.useContext(e.ThemeContext).direction === e.TextDirection.RightToLeft;
    return p.createElement("dl", { className: e.classNames({ "rpv-properties__item": !0, "rpv-properties__item--rtl": m }) }, p.createElement("dt", { className: "rpv-properties__item-label" }, r, ":"), p.createElement("dd", { className: "rpv-properties__item-value" }, u || "-"));
  }, Q = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"), G = function(S, r, u, m) {
    var s = parseInt(S, 10);
    return s >= r && s <= u ? s : m;
  }, X = function(S) {
    var r = S.doc, u = S.fileName, m = S.onToggle, s = p.useContext(e.LocalizationContext).l10n, w = function(i) {
      var o = function(b) {
        var g = Q.exec(b);
        if (!g) return null;
        var c = parseInt(g[1], 10), v = G(g[2], 1, 12, 1) - 1, k = G(g[3], 1, 31, 1), a = G(g[4], 0, 23, 0), f = G(g[5], 0, 59, 0), C = G(g[6], 0, 59, 0), R = g[7] || "Z", M = G(g[8], 0, 23, 0), I = G(g[9], 0, 59, 0);
        switch (R) {
          case "-":
            a += M, f += I;
            break;
          case "+":
            a -= M, f -= I;
        }
        return new Date(Date.UTC(c, v, k, a, f, C));
      }(i);
      return o ? "".concat(o.toLocaleDateString(), ", ").concat(o.toLocaleTimeString()) : "";
    };
    return p.createElement("div", { className: "rpv-properties__modal" }, p.createElement(l, { doc: r, render: function(i) {
      return p.createElement(p.Fragment, null, p.createElement("div", { className: "rpv-properties__modal-section" }, p.createElement(W, { label: s && s.properties ? s.properties.fileName : "File name", value: i.fileName || (g = u, c = g.split("/").pop(), c ? c.split("#")[0].split("?")[0] : g) }), p.createElement(W, { label: s && s.properties ? s.properties.fileSize : "File size", value: (o = i.length, b = Math.floor(Math.log(o) / Math.log(1024)), "".concat((o / Math.pow(1024, b)).toFixed(2), " ").concat(["B", "kB", "MB", "GB", "TB"][b])) })), p.createElement(e.Separator, null), p.createElement("div", { className: "rpv-properties__modal-section" }, p.createElement(W, { label: s && s.properties ? s.properties.title : "Title", value: i.info.Title }), p.createElement(W, { label: s && s.properties ? s.properties.author : "Author", value: i.info.Author }), p.createElement(W, { label: s && s.properties ? s.properties.subject : "Subject", value: i.info.Subject }), p.createElement(W, { label: s && s.properties ? s.properties.keywords : "Keywords", value: i.info.Keywords }), p.createElement(W, { label: s && s.properties ? s.properties.creator : "Creator", value: i.info.Creator }), p.createElement(W, { label: s && s.properties ? s.properties.creationDate : "Creation date", value: w(i.info.CreationDate) }), p.createElement(W, { label: s && s.properties ? s.properties.modificationDate : "Modification date", value: w(i.info.ModDate) })), p.createElement(e.Separator, null), p.createElement("div", { className: "rpv-properties__modal-section" }, p.createElement(W, { label: s && s.properties ? s.properties.pdfProducer : "PDF producer", value: i.info.Producer }), p.createElement(W, { label: s && s.properties ? s.properties.pdfVersion : "PDF version", value: i.info.PDFFormatVersion }), p.createElement(W, { label: s && s.properties ? s.properties.pageCount : "Page count", value: "".concat(r.numPages) })));
      var o, b, g, c;
    } }), p.createElement("div", { className: "rpv-properties__modal-footer" }, p.createElement(e.Button, { onClick: m }, s && s.properties ? s.properties.close : "Close")));
  }, N = { left: 0, top: 8 }, H = function(S) {
    var r = S.onClick, u = p.useContext(e.LocalizationContext).l10n, m = u && u.properties ? u.properties.showProperties : "Show properties";
    return p.createElement(e.Tooltip, { ariaControlsSuffix: "properties", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaLabel: m, testId: "properties__button", onClick: r }, p.createElement(n, null)), content: function() {
      return m;
    }, offset: N });
  }, B = function(S) {
    var r = S.children, u = S.store, m = function(i) {
      var o = p.useState(i.get("doc")), b = o[0], g = o[1], c = function(v) {
        g(v);
      };
      return p.useEffect(function() {
        return i.subscribe("doc", c), function() {
          i.unsubscribe("doc", c);
        };
      }, []), { currentDoc: b };
    }(u).currentDoc, s = u.get("fileName") || "", w = r || function(i) {
      return p.createElement(H, t({}, i));
    };
    return m ? p.createElement(e.Modal, { ariaControlsSuffix: "properties", target: function(i) {
      return w({ onClick: i });
    }, content: function(i) {
      return p.createElement(X, { doc: m, fileName: s, onToggle: i });
    }, closeOnClickOutside: !0, closeOnEscape: !0 }) : p.createElement(p.Fragment, null);
  }, P = function(S) {
    var r = S.onClick, u = p.useContext(e.LocalizationContext).l10n, m = u && u.properties ? u.properties.showProperties : "Show properties";
    return p.createElement(e.MenuItem, { icon: p.createElement(n, null), testId: "properties__menu", onClick: r }, m);
  };
  return properties_min.InfoIcon = n, properties_min.propertiesPlugin = function() {
    var S = p.useMemo(function() {
      return e.createStore({ fileName: "" });
    }, []), r = function(u) {
      return p.createElement(B, t({}, u, { store: S }));
    };
    return { onDocumentLoad: function(u) {
      S.update("doc", u.doc);
    }, onViewerStateChange: function(u) {
      return S.update("fileName", u.file.name), u;
    }, ShowProperties: r, ShowPropertiesButton: function() {
      return p.createElement(B, { store: S });
    }, ShowPropertiesMenuItem: function(u) {
      return p.createElement(r, null, function(m) {
        return p.createElement(P, t({}, m));
      });
    } };
  }, properties_min;
}
var properties = {}, hasRequiredProperties;
function requireProperties() {
  if (hasRequiredProperties) return properties;
  hasRequiredProperties = 1;
  var e = requireLib$h(), L = requireReact();
  function p(i) {
    var o = /* @__PURE__ */ Object.create(null);
    return i && Object.keys(i).forEach(function(b) {
      if (b !== "default") {
        var g = Object.getOwnPropertyDescriptor(i, b);
        Object.defineProperty(o, b, g.get ? g : {
          enumerable: !0,
          get: function() {
            return i[b];
          }
        });
      }
    }), o.default = i, Object.freeze(o);
  }
  var n = /* @__PURE__ */ p(L), t = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: `M12,1.001c6.075,0,11,4.925,11,11s-4.925,11-11,11s-11-4.925-11-11S5.925,1.001,12,1.001z
            M14.5,17.005H13
            c-0.552,0-1-0.448-1-1v-6.5c0-0.276-0.224-0.5-0.5-0.5H10
            M11.745,6.504L11.745,6.504
            M11.745,6.5c-0.138,0-0.25,0.112-0.25,0.25
            S11.607,7,11.745,7s0.25-0.112,0.25-0.25S11.883,6.5,11.745,6.5` })
    );
  }, l = function() {
    return l = Object.assign || function(o) {
      for (var b, g = 1, c = arguments.length; g < c; g++) {
        b = arguments[g];
        for (var v in b) Object.prototype.hasOwnProperty.call(b, v) && (o[v] = b[v]);
      }
      return o;
    }, l.apply(this, arguments);
  }, W = function(i) {
    var o = i.doc, b = i.render, g = n.useState(), c = g[0], v = g[1];
    return n.useEffect(function() {
      o.getMetadata().then(function(k) {
        return Promise.resolve(k);
      }).then(function(k) {
        return o.getDownloadInfo().then(function(a) {
          return Promise.resolve({
            fileName: k.contentDispositionFilename || "",
            info: k.info,
            length: a.length
          });
        });
      }).then(function(k) {
        v(k);
      });
    }, []), c ? b(c) : n.createElement(
      "div",
      { className: "rpv-properties__loader" },
      n.createElement(e.Spinner, null)
    );
  }, Q = function(i) {
    var o = i.label, b = i.value, g = n.useContext(e.ThemeContext).direction, c = g === e.TextDirection.RightToLeft;
    return n.createElement(
      "dl",
      { className: e.classNames({
        "rpv-properties__item": !0,
        "rpv-properties__item--rtl": c
      }) },
      n.createElement(
        "dt",
        { className: "rpv-properties__item-label" },
        o,
        ":"
      ),
      n.createElement("dd", { className: "rpv-properties__item-value" }, b || "-")
    );
  }, G = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"), X = function(i, o, b, g) {
    var c = parseInt(i, 10);
    return c >= o && c <= b ? c : g;
  }, N = function(i) {
    var o = G.exec(i);
    if (!o)
      return null;
    var b = parseInt(o[1], 10), g = X(o[2], 1, 12, 1) - 1, c = X(o[3], 1, 31, 1), v = X(o[4], 0, 23, 0), k = X(o[5], 0, 59, 0), a = X(o[6], 0, 59, 0), f = o[7] || "Z", C = X(o[8], 0, 23, 0), R = X(o[9], 0, 59, 0);
    switch (f) {
      case "-":
        v += C, k += R;
        break;
      case "+":
        v -= C, k -= R;
        break;
    }
    return new Date(Date.UTC(b, g, c, v, k, a));
  }, H = function(i) {
    var o = i.split("/").pop();
    return o ? o.split("#")[0].split("?")[0] : i;
  }, B = function(i) {
    var o = ["B", "kB", "MB", "GB", "TB"], b = Math.floor(Math.log(i) / Math.log(1024));
    return "".concat((i / Math.pow(1024, b)).toFixed(2), " ").concat(o[b]);
  }, P = function(i) {
    var o = i.doc, b = i.fileName, g = i.onToggle, c = n.useContext(e.LocalizationContext).l10n, v = function(a) {
      var f = N(a);
      return f ? "".concat(f.toLocaleDateString(), ", ").concat(f.toLocaleTimeString()) : "";
    }, k = function(a) {
      return n.createElement(
        n.Fragment,
        null,
        n.createElement(
          "div",
          { className: "rpv-properties__modal-section" },
          n.createElement(Q, { label: c && c.properties ? c.properties.fileName : "File name", value: a.fileName || H(b) }),
          n.createElement(Q, { label: c && c.properties ? c.properties.fileSize : "File size", value: B(a.length) })
        ),
        n.createElement(e.Separator, null),
        n.createElement(
          "div",
          { className: "rpv-properties__modal-section" },
          n.createElement(Q, { label: c && c.properties ? c.properties.title : "Title", value: a.info.Title }),
          n.createElement(Q, { label: c && c.properties ? c.properties.author : "Author", value: a.info.Author }),
          n.createElement(Q, { label: c && c.properties ? c.properties.subject : "Subject", value: a.info.Subject }),
          n.createElement(Q, { label: c && c.properties ? c.properties.keywords : "Keywords", value: a.info.Keywords }),
          n.createElement(Q, { label: c && c.properties ? c.properties.creator : "Creator", value: a.info.Creator }),
          n.createElement(Q, { label: c && c.properties ? c.properties.creationDate : "Creation date", value: v(a.info.CreationDate) }),
          n.createElement(Q, { label: c && c.properties ? c.properties.modificationDate : "Modification date", value: v(a.info.ModDate) })
        ),
        n.createElement(e.Separator, null),
        n.createElement(
          "div",
          { className: "rpv-properties__modal-section" },
          n.createElement(Q, { label: c && c.properties ? c.properties.pdfProducer : "PDF producer", value: a.info.Producer }),
          n.createElement(Q, { label: c && c.properties ? c.properties.pdfVersion : "PDF version", value: a.info.PDFFormatVersion }),
          n.createElement(Q, { label: c && c.properties ? c.properties.pageCount : "Page count", value: "".concat(o.numPages) })
        )
      );
    };
    return n.createElement(
      "div",
      { className: "rpv-properties__modal" },
      n.createElement(W, { doc: o, render: k }),
      n.createElement(
        "div",
        { className: "rpv-properties__modal-footer" },
        n.createElement(e.Button, { onClick: g }, c && c.properties ? c.properties.close : "Close")
      )
    );
  }, S = { left: 0, top: 8 }, r = function(i) {
    var o = i.onClick, b = n.useContext(e.LocalizationContext).l10n, g = b && b.properties ? b.properties.showProperties : "Show properties";
    return n.createElement(e.Tooltip, { ariaControlsSuffix: "properties", position: e.Position.BottomCenter, target: n.createElement(
      e.MinimalButton,
      { ariaLabel: g, testId: "properties__button", onClick: o },
      n.createElement(t, null)
    ), content: function() {
      return g;
    }, offset: S });
  }, u = function(i) {
    var o = n.useState(i.get("doc")), b = o[0], g = o[1], c = function(v) {
      g(v);
    };
    return n.useEffect(function() {
      return i.subscribe("doc", c), function() {
        i.unsubscribe("doc", c);
      };
    }, []), { currentDoc: b };
  }, m = function(i) {
    var o = i.children, b = i.store, g = u(b).currentDoc, c = b.get("fileName") || "", v = function(a) {
      return n.createElement(r, l({}, a));
    }, k = o || v;
    return g ? n.createElement(e.Modal, { ariaControlsSuffix: "properties", target: function(a) {
      return k({
        onClick: a
      });
    }, content: function(a) {
      return n.createElement(P, { doc: g, fileName: c, onToggle: a });
    }, closeOnClickOutside: !0, closeOnEscape: !0 }) : n.createElement(n.Fragment, null);
  }, s = function(i) {
    var o = i.onClick, b = n.useContext(e.LocalizationContext).l10n, g = b && b.properties ? b.properties.showProperties : "Show properties";
    return n.createElement(e.MenuItem, { icon: n.createElement(t, null), testId: "properties__menu", onClick: o }, g);
  }, w = function() {
    var i = n.useMemo(function() {
      return e.createStore({
        fileName: ""
      });
    }, []), o = function(c) {
      return n.createElement(m, l({}, c, { store: i }));
    }, b = function() {
      return n.createElement(m, { store: i });
    }, g = function(c) {
      return n.createElement(o, null, function(v) {
        return n.createElement(s, l({}, v));
      });
    };
    return {
      onDocumentLoad: function(c) {
        i.update("doc", c.doc);
      },
      onViewerStateChange: function(c) {
        return i.update("fileName", c.file.name), c;
      },
      ShowProperties: o,
      ShowPropertiesButton: b,
      ShowPropertiesMenuItem: g
    };
  };
  return properties.InfoIcon = t, properties.propertiesPlugin = w, properties;
}
var hasRequiredLib$7;
function requireLib$7() {
  if (hasRequiredLib$7) return lib$5.exports;
  hasRequiredLib$7 = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$5.exports = requireProperties_min() : lib$5.exports = requireProperties(), lib$5.exports;
}
var lib$4 = { exports: {} }, rotate_min = {}, hasRequiredRotate_min;
function requireRotate_min() {
  if (hasRequiredRotate_min) return rotate_min;
  hasRequiredRotate_min = 1;
  var e = requireLib$h();
  function L(H) {
    var B = /* @__PURE__ */ Object.create(null);
    return H && Object.keys(H).forEach(function(P) {
      if (P !== "default") {
        var S = Object.getOwnPropertyDescriptor(H, P);
        Object.defineProperty(B, P, S.get ? S : { enumerable: !0, get: function() {
          return H[P];
        } });
      }
    }), B.default = H, Object.freeze(B);
  }
  var p = L(requireReact()), n = function() {
    return p.createElement(e.Icon, { ignoreDirection: !0, size: 16 }, p.createElement("path", { d: `M3.434,10.537c0.141-0.438,0.316-0.864,0.523-1.274
            M3.069,14.425C3.023,14.053,3,13.679,3,13.305 c0-0.291,0.014-0.579,0.041-0.863
            M4.389,18.111c-0.341-0.539-0.623-1.112-0.843-1.711
            M7.163,20.9 c-0.543-0.345-1.048-0.747-1.506-1.2
            M10.98,22.248c-0.65-0.074-1.29-0.218-1.909-0.431
            M10,4.25h2 c4.987,0.015,9.017,4.069,9.003,9.055c-0.013,4.581-3.456,8.426-8.008,8.945
            M13.5,1.75L10,4.25l3.5,2.5` }));
  }, t = function() {
    return p.createElement(e.Icon, { ignoreDirection: !0, size: 16 }, p.createElement("path", { d: `M20.566,10.537c-0.141-0.438-0.316-0.864-0.523-1.274
            M20.931,14.425C20.977,14.053,21,13.679,21,13.305 c0-0.291-0.014-0.579-0.041-0.863
            M19.611,18.111c0.341-0.539,0.624-1.114,0.843-1.713
            M16.837,20.9 c0.543-0.345,1.048-0.747,1.506-1.2
            M13.02,22.248c0.65-0.074,1.29-0.218,1.909-0.431
            M14,4.25h-2 c-4.987,0.015-9.017,4.069-9.003,9.055c0.013,4.581,3.456,8.426,8.008,8.945
            M10.5,1.75l3.5,2.5l-3.5,2.5` }));
  }, l = function() {
    return l = Object.assign || function(H) {
      for (var B, P = 1, S = arguments.length; P < S; P++) for (var r in B = arguments[P]) Object.prototype.hasOwnProperty.call(B, r) && (H[r] = B[r]);
      return H;
    }, l.apply(this, arguments);
  }, W = { left: 0, top: 8 }, Q = function(H) {
    var B = H.direction, P = H.onClick, S = p.useContext(e.LocalizationContext).l10n, r = S && S.rotate ? S.rotate.rotateBackward : "Rotate counterclockwise", u = S && S.rotate ? S.rotate.rotateForward : "Rotate clockwise", m = B === e.RotateDirection.Backward ? r : u, s = B === e.RotateDirection.Backward ? p.createElement(n, null) : p.createElement(t, null);
    return p.createElement(e.Tooltip, { ariaControlsSuffix: "rotate", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaLabel: m, testId: B === e.RotateDirection.Backward ? "rotate__backward-button" : "rotate__forward-button", onClick: P }, s), content: function() {
      return m;
    }, offset: W });
  }, G = function(H) {
    var B = H.children, P = H.direction, S = H.store;
    return (B || function(r) {
      return p.createElement(Q, { direction: r.direction, onClick: r.onClick });
    })({ direction: P, onClick: function() {
      var r = S.get("rotate");
      r && r(P);
    } });
  }, X = function(H) {
    var B = H.direction, P = H.onClick, S = p.useContext(e.LocalizationContext).l10n, r = S && S.rotate ? S.rotate.rotateBackward : "Rotate counterclockwise", u = S && S.rotate ? S.rotate.rotateForward : "Rotate clockwise", m = B === e.RotateDirection.Backward ? r : u, s = B === e.RotateDirection.Backward ? p.createElement(n, null) : p.createElement(t, null);
    return p.createElement(e.MenuItem, { icon: s, testId: B === e.RotateDirection.Backward ? "rotate__backward-menu" : "rotate__forward-menu", onClick: P }, m);
  }, N = function(H) {
    var B = H.children, P = H.store;
    return B({ onRotatePage: function(S, r) {
      var u = P.get("rotatePage");
      u && u(S, r);
    } });
  };
  return rotate_min.RotateBackwardIcon = n, rotate_min.RotateForwardIcon = t, rotate_min.rotatePlugin = function() {
    var H = p.useMemo(function() {
      return e.createStore();
    }, []), B = function(P) {
      return p.createElement(G, l({}, P, { store: H }));
    };
    return { install: function(P) {
      H.update("rotate", P.rotate), H.update("rotatePage", P.rotatePage);
    }, Rotate: B, RotateBackwardButton: function() {
      return p.createElement(B, { direction: e.RotateDirection.Backward }, function(P) {
        return p.createElement(Q, l({}, P));
      });
    }, RotateBackwardMenuItem: function(P) {
      return p.createElement(B, { direction: e.RotateDirection.Backward }, function(S) {
        return p.createElement(X, { direction: S.direction, onClick: function() {
          S.onClick(), P.onClick();
        } });
      });
    }, RotateForwardButton: function() {
      return p.createElement(B, { direction: e.RotateDirection.Forward }, function(P) {
        return p.createElement(Q, l({}, P));
      });
    }, RotateForwardMenuItem: function(P) {
      return p.createElement(B, { direction: e.RotateDirection.Forward }, function(S) {
        return p.createElement(X, { direction: S.direction, onClick: function() {
          S.onClick(), P.onClick();
        } });
      });
    }, RotatePage: function(P) {
      return p.createElement(N, l({}, P, { store: H }));
    } };
  }, rotate_min;
}
var rotate = {}, hasRequiredRotate;
function requireRotate() {
  if (hasRequiredRotate) return rotate;
  hasRequiredRotate = 1;
  var e = requireLib$h(), L = requireReact();
  function p(P) {
    var S = /* @__PURE__ */ Object.create(null);
    return P && Object.keys(P).forEach(function(r) {
      if (r !== "default") {
        var u = Object.getOwnPropertyDescriptor(P, r);
        Object.defineProperty(S, r, u.get ? u : {
          enumerable: !0,
          get: function() {
            return P[r];
          }
        });
      }
    }), S.default = P, Object.freeze(S);
  }
  var n = /* @__PURE__ */ p(L), t = function() {
    return n.createElement(
      e.Icon,
      { ignoreDirection: !0, size: 16 },
      n.createElement("path", { d: `M3.434,10.537c0.141-0.438,0.316-0.864,0.523-1.274
            M3.069,14.425C3.023,14.053,3,13.679,3,13.305 c0-0.291,0.014-0.579,0.041-0.863
            M4.389,18.111c-0.341-0.539-0.623-1.112-0.843-1.711
            M7.163,20.9 c-0.543-0.345-1.048-0.747-1.506-1.2
            M10.98,22.248c-0.65-0.074-1.29-0.218-1.909-0.431
            M10,4.25h2 c4.987,0.015,9.017,4.069,9.003,9.055c-0.013,4.581-3.456,8.426-8.008,8.945
            M13.5,1.75L10,4.25l3.5,2.5` })
    );
  }, l = function() {
    return n.createElement(
      e.Icon,
      { ignoreDirection: !0, size: 16 },
      n.createElement("path", { d: `M20.566,10.537c-0.141-0.438-0.316-0.864-0.523-1.274
            M20.931,14.425C20.977,14.053,21,13.679,21,13.305 c0-0.291-0.014-0.579-0.041-0.863
            M19.611,18.111c0.341-0.539,0.624-1.114,0.843-1.713
            M16.837,20.9 c0.543-0.345,1.048-0.747,1.506-1.2
            M13.02,22.248c0.65-0.074,1.29-0.218,1.909-0.431
            M14,4.25h-2 c-4.987,0.015-9.017,4.069-9.003,9.055c0.013,4.581,3.456,8.426,8.008,8.945
            M10.5,1.75l3.5,2.5l-3.5,2.5` })
    );
  }, W = function() {
    return W = Object.assign || function(S) {
      for (var r, u = 1, m = arguments.length; u < m; u++) {
        r = arguments[u];
        for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (S[s] = r[s]);
      }
      return S;
    }, W.apply(this, arguments);
  }, Q = { left: 0, top: 8 }, G = function(P) {
    var S = P.direction, r = P.onClick, u = n.useContext(e.LocalizationContext).l10n, m = u && u.rotate ? u.rotate.rotateBackward : "Rotate counterclockwise", s = u && u.rotate ? u.rotate.rotateForward : "Rotate clockwise", w = S === e.RotateDirection.Backward ? m : s, i = S === e.RotateDirection.Backward ? n.createElement(t, null) : n.createElement(l, null);
    return n.createElement(e.Tooltip, { ariaControlsSuffix: "rotate", position: e.Position.BottomCenter, target: n.createElement(e.MinimalButton, { ariaLabel: w, testId: S === e.RotateDirection.Backward ? "rotate__backward-button" : "rotate__forward-button", onClick: r }, i), content: function() {
      return w;
    }, offset: Q });
  }, X = function(P) {
    var S = P.children, r = P.direction, u = P.store, m = function() {
      var i = u.get("rotate");
      i && i(r);
    }, s = function(i) {
      return n.createElement(G, { direction: i.direction, onClick: i.onClick });
    }, w = S || s;
    return w({
      direction: r,
      onClick: m
    });
  }, N = function(P) {
    var S = P.direction, r = P.onClick, u = n.useContext(e.LocalizationContext).l10n, m = u && u.rotate ? u.rotate.rotateBackward : "Rotate counterclockwise", s = u && u.rotate ? u.rotate.rotateForward : "Rotate clockwise", w = S === e.RotateDirection.Backward ? m : s, i = S === e.RotateDirection.Backward ? n.createElement(t, null) : n.createElement(l, null);
    return n.createElement(e.MenuItem, { icon: i, testId: S === e.RotateDirection.Backward ? "rotate__backward-menu" : "rotate__forward-menu", onClick: r }, w);
  }, H = function(P) {
    var S = P.children, r = P.store, u = function(m, s) {
      var w = r.get("rotatePage");
      w && w(m, s);
    };
    return S({
      onRotatePage: u
    });
  }, B = function() {
    var P = n.useMemo(function() {
      return e.createStore();
    }, []), S = function(i) {
      return n.createElement(X, W({}, i, { store: P }));
    }, r = function() {
      return n.createElement(S, { direction: e.RotateDirection.Backward }, function(i) {
        return n.createElement(G, W({}, i));
      });
    }, u = function(i) {
      return n.createElement(S, { direction: e.RotateDirection.Backward }, function(o) {
        return n.createElement(N, { direction: o.direction, onClick: function() {
          o.onClick(), i.onClick();
        } });
      });
    }, m = function() {
      return n.createElement(S, { direction: e.RotateDirection.Forward }, function(i) {
        return n.createElement(G, W({}, i));
      });
    }, s = function(i) {
      return n.createElement(S, { direction: e.RotateDirection.Forward }, function(o) {
        return n.createElement(N, { direction: o.direction, onClick: function() {
          o.onClick(), i.onClick();
        } });
      });
    }, w = function(i) {
      return n.createElement(H, W({}, i, { store: P }));
    };
    return {
      install: function(i) {
        P.update("rotate", i.rotate), P.update("rotatePage", i.rotatePage);
      },
      Rotate: S,
      RotateBackwardButton: r,
      RotateBackwardMenuItem: u,
      RotateForwardButton: m,
      RotateForwardMenuItem: s,
      RotatePage: w
    };
  };
  return rotate.RotateBackwardIcon = t, rotate.RotateForwardIcon = l, rotate.rotatePlugin = B, rotate;
}
var hasRequiredLib$6;
function requireLib$6() {
  if (hasRequiredLib$6) return lib$4.exports;
  hasRequiredLib$6 = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$4.exports = requireRotate_min() : lib$4.exports = requireRotate(), lib$4.exports;
}
var lib$3 = { exports: {} }, scrollMode_min = {}, hasRequiredScrollMode_min;
function requireScrollMode_min() {
  if (hasRequiredScrollMode_min) return scrollMode_min;
  hasRequiredScrollMode_min = 1;
  var e = requireLib$h();
  function L(c) {
    var v = /* @__PURE__ */ Object.create(null);
    return c && Object.keys(c).forEach(function(k) {
      if (k !== "default") {
        var a = Object.getOwnPropertyDescriptor(c, k);
        Object.defineProperty(v, k, a.get ? a : { enumerable: !0, get: function() {
          return c[k];
        } });
      }
    }), v.default = c, Object.freeze(v);
  }
  var p = L(requireReact()), n = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("rect", { x: "0.5", y: "0.497", width: "22", height: "22", rx: "1", ry: "1" }), p.createElement("line", { x1: "0.5", y1: "6.497", x2: "22.5", y2: "6.497" }), p.createElement("line", { x1: "11.5", y1: "6.497", x2: "11.5", y2: "22.497" }));
  }, t = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("rect", { x: "0.5", y: "0.497", width: "22", height: "22", rx: "1", ry: "1" }), p.createElement("line", { x1: "11.5", y1: "0.497", x2: "11.5", y2: "22.497" }));
  }, l = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: `M6.5,21.5c0,0.552-0.448,1-1,1h-4c-0.552,0-1-0.448-1-1v-20c0-0.552,0.448-1,1-1h4c0.552,0,1,0.448,1,1V21.5z
            M14.5,21.5c0,0.552-0.448,1-1,1h-4c-0.552,0-1-0.448-1-1v-20c0-0.552,0.448-1,1-1h4c0.552,0,1,0.448,1,1V21.5z
            M22.5,21.5 c0,0.552-0.448,1-1,1h-4c-0.552,0-1-0.448-1-1v-20c0-0.552,0.448-1,1-1h4c0.552,0,1,0.448,1,1V21.5z` }));
  }, W = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("rect", { x: "0.5", y: "0.497", width: "22", height: "22", rx: "1", ry: "1" }));
  }, Q = function() {
    return Q = Object.assign || function(c) {
      for (var v, k = 1, a = arguments.length; k < a; k++) for (var f in v = arguments[k]) Object.prototype.hasOwnProperty.call(v, f) && (c[f] = v[f]);
      return c;
    }, Q.apply(this, arguments);
  }, G = function(c, v) {
    c.get("switchScrollMode")(v);
    var k = c.get("viewMode");
    v !== e.ScrollMode.Horizontal && v !== e.ScrollMode.Wrapped || k === e.ViewMode.SinglePage || c.get("switchViewMode")(e.ViewMode.SinglePage);
  }, X = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: `M23.5,5.5c0,0.552-0.448,1-1,1h-21c-0.552,0-1-0.448-1-1v-3c0-0.552,0.448-1,1-1h21c0.552,0,1,0.448,1,1V5.5z
            M23.5,13.5c0,0.552-0.448,1-1,1h-21c-0.552,0-1-0.448-1-1v-3c0-0.552,0.448-1,1-1h21c0.552,0,1,0.448,1,1V13.5z
            M23.5,21.5 c0,0.552-0.448,1-1,1h-21c-0.552,0-1-0.448-1-1v-3c0-0.552,0.448-1,1-1h21c0.552,0,1,0.448,1,1V21.5z` }));
  }, N = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: `M10.5,9.5c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V9.5z
            M23.5,9.5c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V9.5z
            M10.5,22.5 c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V22.5z
            M23.5,22.5c0,0.552-0.448,1-1,1 h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V22.5z` }));
  }, H = function(c) {
    var v = c.children, k = c.mode, a = c.onClick, f = p.useContext(e.LocalizationContext).l10n, C = "", R = p.createElement(X, null);
    switch (k) {
      case e.ScrollMode.Horizontal:
        C = f && f.scrollMode ? f.scrollMode.horizontalScrolling : "Horizontal scrolling", R = p.createElement(l, null);
        break;
      case e.ScrollMode.Page:
        C = f && f.scrollMode ? f.scrollMode.pageScrolling : "Page scrolling", R = p.createElement(W, null);
        break;
      case e.ScrollMode.Wrapped:
        C = f && f.scrollMode ? f.scrollMode.wrappedScrolling : "Wrapped scrolling", R = p.createElement(N, null);
        break;
      case e.ScrollMode.Vertical:
      default:
        C = f && f.scrollMode ? f.scrollMode.verticalScrolling : "Vertical scrolling", R = p.createElement(X, null);
    }
    return v({ icon: R, label: C, onClick: a });
  }, B = { left: 0, top: 8 }, P = function(c) {
    var v = c.isDisabled, k = c.isSelected, a = c.mode, f = c.onClick, C = "";
    switch (a) {
      case e.ScrollMode.Horizontal:
        C = "scroll-mode__horizontal-button";
        break;
      case e.ScrollMode.Page:
        C = "scroll-mode__page-button";
        break;
      case e.ScrollMode.Wrapped:
        C = "scroll-mode__wrapped-button";
        break;
      case e.ScrollMode.Vertical:
      default:
        C = "scroll-mode__vertical-button";
    }
    return p.createElement(H, { mode: a, onClick: f }, function(R) {
      return p.createElement(e.Tooltip, { ariaControlsSuffix: "scroll-mode-switch", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaLabel: R.label, isDisabled: v, isSelected: k, testId: C, onClick: R.onClick }, R.icon), content: function() {
        return R.label;
      }, offset: B });
    });
  }, S = function(c) {
    var v = p.useState(c.get("scrollMode") || e.ScrollMode.Vertical), k = v[0], a = v[1], f = function(C) {
      a(C);
    };
    return p.useEffect(function() {
      return c.subscribe("scrollMode", f), function() {
        c.unsubscribe("scrollMode", f);
      };
    }, []), { scrollMode: k };
  }, r = function(c) {
    var v = p.useState(c.get("viewMode") || e.ViewMode.SinglePage), k = v[0], a = v[1], f = function(C) {
      a(C);
    };
    return p.useEffect(function() {
      return c.subscribe("viewMode", f), function() {
        c.unsubscribe("viewMode", f);
      };
    }, []), { viewMode: k };
  }, u = function(c) {
    var v = c.children, k = c.mode, a = c.store, f = r(a).viewMode, C = S(a).scrollMode === k, R = (k === e.ScrollMode.Horizontal || k === e.ScrollMode.Wrapped) && f !== e.ViewMode.SinglePage;
    return (v || function(M) {
      return p.createElement(P, { isDisabled: R, isSelected: C, mode: M.mode, onClick: M.onClick });
    })({ isDisabled: R, isSelected: C, mode: k, onClick: function() {
      G(a, k);
    } });
  }, m = function(c) {
    var v = c.isDisabled, k = c.isSelected, a = c.mode, f = c.onClick, C = "";
    switch (a) {
      case e.ScrollMode.Horizontal:
        C = "scroll-mode__horizontal-menu";
        break;
      case e.ScrollMode.Page:
        C = "scroll-mode__page-menu";
        break;
      case e.ScrollMode.Wrapped:
        C = "scroll-mode__wrapped-menu";
        break;
      case e.ScrollMode.Vertical:
      default:
        C = "scroll-mode__vertical-menu";
    }
    return p.createElement(H, { mode: a, onClick: f }, function(R) {
      return p.createElement(e.MenuItem, { checked: k, icon: R.icon, isDisabled: v, testId: C, onClick: R.onClick }, R.label);
    });
  }, s = function(c, v) {
    c.get("switchViewMode")(v);
    var k = c.get("scrollMode");
    k !== e.ScrollMode.Horizontal && k !== e.ScrollMode.Wrapped || v === e.ViewMode.SinglePage || c.get("switchScrollMode")(e.ScrollMode.Vertical);
  }, w = function(c) {
    var v = c.children, k = c.mode, a = c.onClick, f = p.useContext(e.LocalizationContext).l10n, C = "", R = p.createElement(W, null);
    switch (k) {
      case e.ViewMode.DualPage:
        C = f && f.scrollMode ? f.scrollMode.dualPage : "Dual page", R = p.createElement(t, null);
        break;
      case e.ViewMode.DualPageWithCover:
        C = f && f.scrollMode ? f.scrollMode.dualPageCover : "Dual page with cover", R = p.createElement(n, null);
        break;
      case e.ViewMode.SinglePage:
      default:
        C = f && f.scrollMode ? f.scrollMode.singlePage : "Single page", R = p.createElement(W, null);
    }
    return v({ icon: R, label: C, onClick: a });
  }, i = { left: 0, top: 8 }, o = function(c) {
    var v = c.isDisabled, k = c.isSelected, a = c.mode, f = c.onClick, C = "";
    switch (a) {
      case e.ViewMode.DualPage:
        C = "view-mode__dual-button";
        break;
      case e.ViewMode.DualPageWithCover:
        C = "view-mode__dual-cover-button";
        break;
      case e.ViewMode.SinglePage:
      default:
        C = "view-mode__single-button";
    }
    return p.createElement(w, { mode: a, onClick: f }, function(R) {
      return p.createElement(e.Tooltip, { ariaControlsSuffix: "view-mode-switch", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaLabel: R.label, isDisabled: v, isSelected: k, testId: C, onClick: R.onClick }, R.icon), content: function() {
        return R.label;
      }, offset: i });
    });
  }, b = function(c) {
    var v = c.children, k = c.mode, a = c.store, f = r(a).viewMode, C = S(a).scrollMode, R = f === k, M = (C === e.ScrollMode.Horizontal || C === e.ScrollMode.Wrapped) && k !== e.ViewMode.SinglePage;
    return (v || function(I) {
      return p.createElement(o, { isDisabled: M, isSelected: R, mode: I.mode, onClick: I.onClick });
    })({ isDisabled: M, isSelected: R, mode: k, onClick: function() {
      s(a, k);
    } });
  }, g = function(c) {
    var v = c.isDisabled, k = c.isSelected, a = c.mode, f = c.onClick, C = "";
    switch (a) {
      case e.ViewMode.DualPage:
        C = "view-mode__dual-menu";
        break;
      case e.ViewMode.DualPageWithCover:
        C = "view-mode__dual-cover-menu";
        break;
      case e.ViewMode.SinglePage:
      default:
        C = "view-mode__single-menu";
    }
    return p.createElement(w, { mode: a, onClick: f }, function(R) {
      return p.createElement(e.MenuItem, { checked: k, icon: R.icon, isDisabled: v, testId: C, onClick: R.onClick }, R.label);
    });
  };
  return scrollMode_min.DualPageCoverViewModeIcon = n, scrollMode_min.DualPageViewModeIcon = t, scrollMode_min.HorizontalScrollingIcon = l, scrollMode_min.PageScrollingIcon = W, scrollMode_min.VerticalScrollingIcon = X, scrollMode_min.WrappedScrollingIcon = N, scrollMode_min.scrollModePlugin = function() {
    var c = p.useMemo(function() {
      return e.createStore({ scrollMode: e.ScrollMode.Vertical, viewMode: e.ViewMode.SinglePage, switchScrollMode: function() {
      }, switchViewMode: function() {
      } });
    }, []), v = function(a) {
      return p.createElement(u, Q({}, a, { store: c }));
    }, k = function(a) {
      return p.createElement(b, Q({}, a, { store: c }));
    };
    return { install: function(a) {
      c.update("switchScrollMode", a.switchScrollMode), c.update("switchViewMode", a.switchViewMode);
    }, onViewerStateChange: function(a) {
      return c.update("scrollMode", a.scrollMode), c.update("viewMode", a.viewMode), a;
    }, switchScrollMode: function(a) {
      G(c, a);
    }, switchViewMode: function(a) {
      s(c, a);
    }, SwitchScrollMode: v, SwitchScrollModeButton: function(a) {
      return p.createElement(v, { mode: a.mode }, function(f) {
        return p.createElement(P, { isDisabled: f.isDisabled, isSelected: f.isSelected, mode: f.mode, onClick: function() {
          f.onClick();
        } });
      });
    }, SwitchScrollModeMenuItem: function(a) {
      return p.createElement(v, { mode: a.mode }, function(f) {
        return p.createElement(m, { isDisabled: f.isDisabled, isSelected: f.isSelected, mode: f.mode, onClick: function() {
          f.onClick(), a.onClick();
        } });
      });
    }, SwitchViewMode: k, SwitchViewModeButton: function(a) {
      return p.createElement(k, { mode: a.mode }, function(f) {
        return p.createElement(o, { isDisabled: f.isDisabled, isSelected: f.isSelected, mode: f.mode, onClick: function() {
          f.onClick();
        } });
      });
    }, SwitchViewModeMenuItem: function(a) {
      return p.createElement(k, { mode: a.mode }, function(f) {
        return p.createElement(g, { isDisabled: f.isDisabled, isSelected: f.isSelected, mode: f.mode, onClick: function() {
          f.onClick(), a.onClick();
        } });
      });
    } };
  }, scrollMode_min;
}
var scrollMode = {}, hasRequiredScrollMode;
function requireScrollMode() {
  if (hasRequiredScrollMode) return scrollMode;
  hasRequiredScrollMode = 1;
  var e = requireLib$h(), L = requireReact();
  function p(k) {
    var a = /* @__PURE__ */ Object.create(null);
    return k && Object.keys(k).forEach(function(f) {
      if (f !== "default") {
        var C = Object.getOwnPropertyDescriptor(k, f);
        Object.defineProperty(a, f, C.get ? C : {
          enumerable: !0,
          get: function() {
            return k[f];
          }
        });
      }
    }), a.default = k, Object.freeze(a);
  }
  var n = /* @__PURE__ */ p(L), t = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("rect", { x: "0.5", y: "0.497", width: "22", height: "22", rx: "1", ry: "1" }),
      n.createElement("line", { x1: "0.5", y1: "6.497", x2: "22.5", y2: "6.497" }),
      n.createElement("line", { x1: "11.5", y1: "6.497", x2: "11.5", y2: "22.497" })
    );
  }, l = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("rect", { x: "0.5", y: "0.497", width: "22", height: "22", rx: "1", ry: "1" }),
      n.createElement("line", { x1: "11.5", y1: "0.497", x2: "11.5", y2: "22.497" })
    );
  }, W = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: `M6.5,21.5c0,0.552-0.448,1-1,1h-4c-0.552,0-1-0.448-1-1v-20c0-0.552,0.448-1,1-1h4c0.552,0,1,0.448,1,1V21.5z
            M14.5,21.5c0,0.552-0.448,1-1,1h-4c-0.552,0-1-0.448-1-1v-20c0-0.552,0.448-1,1-1h4c0.552,0,1,0.448,1,1V21.5z
            M22.5,21.5 c0,0.552-0.448,1-1,1h-4c-0.552,0-1-0.448-1-1v-20c0-0.552,0.448-1,1-1h4c0.552,0,1,0.448,1,1V21.5z` })
    );
  }, Q = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("rect", { x: "0.5", y: "0.497", width: "22", height: "22", rx: "1", ry: "1" })
    );
  }, G = function() {
    return G = Object.assign || function(a) {
      for (var f, C = 1, R = arguments.length; C < R; C++) {
        f = arguments[C];
        for (var M in f) Object.prototype.hasOwnProperty.call(f, M) && (a[M] = f[M]);
      }
      return a;
    }, G.apply(this, arguments);
  }, X = function(k, a) {
    k.get("switchScrollMode")(a);
    var f = k.get("viewMode");
    (a === e.ScrollMode.Horizontal || a === e.ScrollMode.Wrapped) && f !== e.ViewMode.SinglePage && k.get("switchViewMode")(e.ViewMode.SinglePage);
  }, N = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: `M23.5,5.5c0,0.552-0.448,1-1,1h-21c-0.552,0-1-0.448-1-1v-3c0-0.552,0.448-1,1-1h21c0.552,0,1,0.448,1,1V5.5z
            M23.5,13.5c0,0.552-0.448,1-1,1h-21c-0.552,0-1-0.448-1-1v-3c0-0.552,0.448-1,1-1h21c0.552,0,1,0.448,1,1V13.5z
            M23.5,21.5 c0,0.552-0.448,1-1,1h-21c-0.552,0-1-0.448-1-1v-3c0-0.552,0.448-1,1-1h21c0.552,0,1,0.448,1,1V21.5z` })
    );
  }, H = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: `M10.5,9.5c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V9.5z
            M23.5,9.5c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V9.5z
            M10.5,22.5 c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V22.5z
            M23.5,22.5c0,0.552-0.448,1-1,1 h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V22.5z` })
    );
  }, B = function(k) {
    var a = k.children, f = k.mode, C = k.onClick, R = n.useContext(e.LocalizationContext).l10n, M = "", I = n.createElement(N, null);
    switch (f) {
      case e.ScrollMode.Horizontal:
        M = R && R.scrollMode ? R.scrollMode.horizontalScrolling : "Horizontal scrolling", I = n.createElement(W, null);
        break;
      case e.ScrollMode.Page:
        M = R && R.scrollMode ? R.scrollMode.pageScrolling : "Page scrolling", I = n.createElement(Q, null);
        break;
      case e.ScrollMode.Wrapped:
        M = R && R.scrollMode ? R.scrollMode.wrappedScrolling : "Wrapped scrolling", I = n.createElement(H, null);
        break;
      case e.ScrollMode.Vertical:
      default:
        M = R && R.scrollMode ? R.scrollMode.verticalScrolling : "Vertical scrolling", I = n.createElement(N, null);
        break;
    }
    return a({ icon: I, label: M, onClick: C });
  }, P = { left: 0, top: 8 }, S = function(k) {
    var a = k.isDisabled, f = k.isSelected, C = k.mode, R = k.onClick, M = "";
    switch (C) {
      case e.ScrollMode.Horizontal:
        M = "scroll-mode__horizontal-button";
        break;
      case e.ScrollMode.Page:
        M = "scroll-mode__page-button";
        break;
      case e.ScrollMode.Wrapped:
        M = "scroll-mode__wrapped-button";
        break;
      case e.ScrollMode.Vertical:
      default:
        M = "scroll-mode__vertical-button";
        break;
    }
    return n.createElement(B, { mode: C, onClick: R }, function(I) {
      return n.createElement(e.Tooltip, { ariaControlsSuffix: "scroll-mode-switch", position: e.Position.BottomCenter, target: n.createElement(e.MinimalButton, { ariaLabel: I.label, isDisabled: a, isSelected: f, testId: M, onClick: I.onClick }, I.icon), content: function() {
        return I.label;
      }, offset: P });
    });
  }, r = function(k) {
    var a = n.useState(k.get("scrollMode") || e.ScrollMode.Vertical), f = a[0], C = a[1], R = function(M) {
      C(M);
    };
    return n.useEffect(function() {
      return k.subscribe("scrollMode", R), function() {
        k.unsubscribe("scrollMode", R);
      };
    }, []), { scrollMode: f };
  }, u = function(k) {
    var a = n.useState(k.get("viewMode") || e.ViewMode.SinglePage), f = a[0], C = a[1], R = function(M) {
      C(M);
    };
    return n.useEffect(function() {
      return k.subscribe("viewMode", R), function() {
        k.unsubscribe("viewMode", R);
      };
    }, []), { viewMode: f };
  }, m = function(k) {
    var a = k.children, f = k.mode, C = k.store, R = u(C).viewMode, M = r(C).scrollMode, I = function() {
      X(C, f);
    }, E = M === f, T = (f === e.ScrollMode.Horizontal || f === e.ScrollMode.Wrapped) && R !== e.ViewMode.SinglePage, y = function(j) {
      return n.createElement(S, { isDisabled: T, isSelected: E, mode: j.mode, onClick: j.onClick });
    }, D = a || y;
    return D({
      isDisabled: T,
      isSelected: E,
      mode: f,
      onClick: I
    });
  }, s = function(k) {
    var a = k.isDisabled, f = k.isSelected, C = k.mode, R = k.onClick, M = "";
    switch (C) {
      case e.ScrollMode.Horizontal:
        M = "scroll-mode__horizontal-menu";
        break;
      case e.ScrollMode.Page:
        M = "scroll-mode__page-menu";
        break;
      case e.ScrollMode.Wrapped:
        M = "scroll-mode__wrapped-menu";
        break;
      case e.ScrollMode.Vertical:
      default:
        M = "scroll-mode__vertical-menu";
        break;
    }
    return n.createElement(B, { mode: C, onClick: R }, function(I) {
      return n.createElement(e.MenuItem, { checked: f, icon: I.icon, isDisabled: a, testId: M, onClick: I.onClick }, I.label);
    });
  }, w = function(k, a) {
    k.get("switchViewMode")(a);
    var f = k.get("scrollMode");
    (f === e.ScrollMode.Horizontal || f === e.ScrollMode.Wrapped) && a !== e.ViewMode.SinglePage && k.get("switchScrollMode")(e.ScrollMode.Vertical);
  }, i = function(k) {
    var a = k.children, f = k.mode, C = k.onClick, R = n.useContext(e.LocalizationContext).l10n, M = "", I = n.createElement(Q, null);
    switch (f) {
      case e.ViewMode.DualPage:
        M = R && R.scrollMode ? R.scrollMode.dualPage : "Dual page", I = n.createElement(l, null);
        break;
      case e.ViewMode.DualPageWithCover:
        M = R && R.scrollMode ? R.scrollMode.dualPageCover : "Dual page with cover", I = n.createElement(t, null);
        break;
      case e.ViewMode.SinglePage:
      default:
        M = R && R.scrollMode ? R.scrollMode.singlePage : "Single page", I = n.createElement(Q, null);
        break;
    }
    return a({ icon: I, label: M, onClick: C });
  }, o = { left: 0, top: 8 }, b = function(k) {
    var a = k.isDisabled, f = k.isSelected, C = k.mode, R = k.onClick, M = "";
    switch (C) {
      case e.ViewMode.DualPage:
        M = "view-mode__dual-button";
        break;
      case e.ViewMode.DualPageWithCover:
        M = "view-mode__dual-cover-button";
        break;
      case e.ViewMode.SinglePage:
      default:
        M = "view-mode__single-button";
        break;
    }
    return n.createElement(i, { mode: C, onClick: R }, function(I) {
      return n.createElement(e.Tooltip, { ariaControlsSuffix: "view-mode-switch", position: e.Position.BottomCenter, target: n.createElement(e.MinimalButton, { ariaLabel: I.label, isDisabled: a, isSelected: f, testId: M, onClick: I.onClick }, I.icon), content: function() {
        return I.label;
      }, offset: o });
    });
  }, g = function(k) {
    var a = k.children, f = k.mode, C = k.store, R = u(C).viewMode, M = r(C).scrollMode, I = function() {
      w(C, f);
    }, E = R === f, T = (M === e.ScrollMode.Horizontal || M === e.ScrollMode.Wrapped) && f !== e.ViewMode.SinglePage, y = function(j) {
      return n.createElement(b, { isDisabled: T, isSelected: E, mode: j.mode, onClick: j.onClick });
    }, D = a || y;
    return D({
      isDisabled: T,
      isSelected: E,
      mode: f,
      onClick: I
    });
  }, c = function(k) {
    var a = k.isDisabled, f = k.isSelected, C = k.mode, R = k.onClick, M = "";
    switch (C) {
      case e.ViewMode.DualPage:
        M = "view-mode__dual-menu";
        break;
      case e.ViewMode.DualPageWithCover:
        M = "view-mode__dual-cover-menu";
        break;
      case e.ViewMode.SinglePage:
      default:
        M = "view-mode__single-menu";
        break;
    }
    return n.createElement(i, { mode: C, onClick: R }, function(I) {
      return n.createElement(e.MenuItem, { checked: f, icon: I.icon, isDisabled: a, testId: M, onClick: I.onClick }, I.label);
    });
  }, v = function() {
    var k = n.useMemo(function() {
      return e.createStore({
        scrollMode: e.ScrollMode.Vertical,
        viewMode: e.ViewMode.SinglePage,
        switchScrollMode: function() {
        },
        switchViewMode: function() {
        }
      });
    }, []), a = function(E) {
      return n.createElement(m, G({}, E, { store: k }));
    }, f = function(E) {
      return n.createElement(a, { mode: E.mode }, function(T) {
        return n.createElement(S, { isDisabled: T.isDisabled, isSelected: T.isSelected, mode: T.mode, onClick: function() {
          T.onClick();
        } });
      });
    }, C = function(E) {
      return n.createElement(a, { mode: E.mode }, function(T) {
        return n.createElement(s, { isDisabled: T.isDisabled, isSelected: T.isSelected, mode: T.mode, onClick: function() {
          T.onClick(), E.onClick();
        } });
      });
    }, R = function(E) {
      return n.createElement(g, G({}, E, { store: k }));
    }, M = function(E) {
      return n.createElement(R, { mode: E.mode }, function(T) {
        return n.createElement(b, { isDisabled: T.isDisabled, isSelected: T.isSelected, mode: T.mode, onClick: function() {
          T.onClick();
        } });
      });
    }, I = function(E) {
      return n.createElement(R, { mode: E.mode }, function(T) {
        return n.createElement(c, { isDisabled: T.isDisabled, isSelected: T.isSelected, mode: T.mode, onClick: function() {
          T.onClick(), E.onClick();
        } });
      });
    };
    return {
      install: function(E) {
        k.update("switchScrollMode", E.switchScrollMode), k.update("switchViewMode", E.switchViewMode);
      },
      onViewerStateChange: function(E) {
        return k.update("scrollMode", E.scrollMode), k.update("viewMode", E.viewMode), E;
      },
      switchScrollMode: function(E) {
        X(k, E);
      },
      switchViewMode: function(E) {
        w(k, E);
      },
      SwitchScrollMode: a,
      SwitchScrollModeButton: f,
      SwitchScrollModeMenuItem: C,
      SwitchViewMode: R,
      SwitchViewModeButton: M,
      SwitchViewModeMenuItem: I
    };
  };
  return scrollMode.DualPageCoverViewModeIcon = t, scrollMode.DualPageViewModeIcon = l, scrollMode.HorizontalScrollingIcon = W, scrollMode.PageScrollingIcon = Q, scrollMode.VerticalScrollingIcon = N, scrollMode.WrappedScrollingIcon = H, scrollMode.scrollModePlugin = v, scrollMode;
}
var hasRequiredLib$5;
function requireLib$5() {
  if (hasRequiredLib$5) return lib$3.exports;
  hasRequiredLib$5 = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$3.exports = requireScrollMode_min() : lib$3.exports = requireScrollMode(), lib$3.exports;
}
var lib$2 = { exports: {} }, search_min = {}, hasRequiredSearch_min;
function requireSearch_min() {
  if (hasRequiredSearch_min) return search_min;
  hasRequiredSearch_min = 1;
  var e = requireLib$h();
  function L(a) {
    var f = /* @__PURE__ */ Object.create(null);
    return a && Object.keys(a).forEach(function(C) {
      if (C !== "default") {
        var R = Object.getOwnPropertyDescriptor(a, C);
        Object.defineProperty(f, C, R.get ? R : { enumerable: !0, get: function() {
          return a[C];
        } });
      }
    }), f.default = a, Object.freeze(f);
  }
  var p = L(requireReact()), n = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: `M0.541,5.627L11.666,18.2c0.183,0.207,0.499,0.226,0.706,0.043c0.015-0.014,0.03-0.028,0.043-0.043
            L23.541,5.627` }));
  }, t = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: `M23.535,18.373L12.409,5.8c-0.183-0.207-0.499-0.226-0.706-0.043C11.688,5.77,11.674,5.785,11.66,5.8
            L0.535,18.373` }));
  }, l = function() {
    return p.createElement(e.Icon, { ignoreDirection: !0, size: 16 }, p.createElement("path", { d: `M10.5,0.5c5.523,0,10,4.477,10,10s-4.477,10-10,10s-10-4.477-10-10S4.977,0.5,10.5,0.5z
            M23.5,23.5
            l-5.929-5.929` }));
  }, W = function() {
    return W = Object.assign || function(a) {
      for (var f, C = 1, R = arguments.length; C < R; C++) for (var M in f = arguments[C]) Object.prototype.hasOwnProperty.call(f, M) && (a[M] = f[M]);
      return a;
    }, W.apply(this, arguments);
  }, Q = { keyword: "", regExp: new RegExp(" "), wholeWords: !1 }, G = function(a) {
    return { left: "".concat(a.left, "%"), top: "".concat(a.top, "%"), height: "".concat(a.height, "%"), width: "".concat(a.width, "%") };
  }, X = function(a) {
    var f = a.index, C = a.area, R = a.onHighlightKeyword, M = p.useRef();
    return e.useIsomorphicLayoutEffect(function() {
      var I = M.current;
      R && I && R({ highlightEle: I, keyword: C.keyword });
    }, []), p.createElement("div", { className: "rpv-search__highlight", "data-index": f, ref: M, style: G(C), title: C.keywordStr.trim() });
  }, N = function(a) {
    var f = a.parentNode;
    f && f.removeChild(a);
  }, H = function(a) {
    var f = a.parentNode;
    if (f) {
      var C = document.createRange();
      C.selectNodeContents(a), function(R, M) {
        N(R);
        var I = M.parentNode;
        I && I.insertBefore(R, M), N(M);
      }(C.extractContents(), a), f.normalize();
    }
  }, B = function(a, f) {
    return a.top < f.top ? -1 : a.top > f.top ? 1 : a.left < f.left ? -1 : a.left > f.left ? 1 : 0;
  }, P = function(a) {
    var f = a.numPages, C = a.pageIndex, R = a.renderHighlights, M = a.store, I = a.onHighlightKeyword, E = p.useRef(), T = p.useCallback(function(me) {
      return p.createElement(p.Fragment, null, me.highlightAreas.map(function(_e, Be) {
        return p.createElement(X, { index: Be, key: Be, area: _e, onHighlightKeyword: I });
      }));
    }, []), y = R || T, D = p.useState(M.get("matchPosition")), j = D[0], A = D[1], d = p.useState(M.get("keyword") || [Q]), _ = d[0], F = d[1], U = p.useState({ pageIndex: C, scale: 1, status: e.LayerRenderStatus.PreRender }), V = U[0], $ = U[1], re = p.useRef(null), ge = p.useRef([]), be = p.useState([]), le = be[0], fe = be[1], Ae = function() {
      return !0;
    }, qe = p.useCallback(function() {
      return M.get("targetPageFilter") || Ae;
    }, [M.get("targetPageFilter")]), ye = function(me) {
      var _e = ge.current;
      if (_e.length === 0) return [];
      var Be = [], ke = [].slice.call(me.querySelectorAll(".rpv-core__text-layer-text")), de = _e.map(function($e) {
        return $e.char;
      }).join("");
      return _.forEach(function($e) {
        var Ge = $e.keyword;
        if (Ge.trim()) {
          for (var st, it = $e.regExp.flags.indexOf("g") === -1 ? new RegExp($e.regExp, "".concat($e.regExp.flags, "g")) : $e.regExp, _t = []; (st = it.exec(de)) !== null; ) _t.push({ keyword: it, startIndex: st.index, endIndex: it.lastIndex });
          _t.map(function(tt) {
            return { keyword: tt.keyword, indexes: _e.slice(tt.startIndex, tt.endIndex) };
          }).forEach(function(tt) {
            var Xe = tt.indexes.reduce(function(ct, xt) {
              return ct[xt.spanIndex] = (ct[xt.spanIndex] || []).concat([xt]), ct;
            }, {});
            Object.values(Xe).forEach(function(ct) {
              if (ct.length !== 1 || ct[0].char.trim() !== "") {
                var xt = $e.wholeWords ? ct.slice(1, -1) : ct, We = function(Ce, Re, lt, bt, Et) {
                  var oe = document.createRange(), He = bt.firstChild;
                  if (!He || He.nodeType !== Node.TEXT_NODE) return null;
                  var at = He.textContent.length, St = Et[0].charIndexInSpan, yt = Et.length === 1 ? St : Et[Et.length - 1].charIndexInSpan;
                  if (St > at || yt + 1 > at) return null;
                  oe.setStart(He, St), oe.setEnd(He, yt + 1);
                  var dt = document.createElement("span");
                  oe.surroundContents(dt);
                  var ie = dt.getBoundingClientRect(), te = lt.getBoundingClientRect(), we = te.height, De = te.width, Ve = 100 * (ie.left - te.left) / De, Ye = 100 * (ie.top - te.top) / we, Je = 100 * ie.height / we, Pt = 100 * ie.width / De;
                  return H(dt), { keyword: Re, keywordStr: Ce, numPages: f, pageIndex: C, left: Ve, top: Ye, height: Je, width: Pt, pageHeight: we, pageWidth: De };
                }(Ge, tt.keyword, me, ke[xt[0].spanIndex], xt);
                We && Be.push(We);
              }
            });
          });
        }
      }), Be.sort(B);
    }, ce = function(me) {
      me && me.length > 0 && F(me);
    }, q = function(me) {
      return A(me);
    }, Z = function(me) {
      if (me.has(C)) {
        var _e = me.get(C);
        _e && $({ ele: _e.ele, pageIndex: C, scale: _e.scale, status: _e.status });
      }
    }, pe = function() {
      return _.length === 0 || _.length === 1 && _[0].keyword.trim() === "";
    };
    return p.useEffect(function() {
      if (!pe() && V.status === e.LayerRenderStatus.DidRender && !ge.current.length) {
        var me = V.ele, _e = [].slice.call(me.querySelectorAll(".rpv-core__text-layer-text")).map(function(Be) {
          return Be.textContent;
        }).reduce(function(Be, ke, de) {
          return Be.concat(ke.split("").map(function($e, Ge) {
            return { char: $e, charIndexInSpan: Ge, spanIndex: de };
          }));
        }, [{ char: "", charIndexInSpan: 0, spanIndex: 0 }]).slice(1);
        ge.current = _e;
      }
    }, [_, V.status]), p.useEffect(function() {
      if (!pe() && V.ele && V.status === e.LayerRenderStatus.DidRender && qe()({ pageIndex: C, numPages: f })) {
        var me = V.ele, _e = ye(me);
        fe(_e);
      }
    }, [_, j, V.status, ge.current]), p.useEffect(function() {
      pe() && V.ele && V.status === e.LayerRenderStatus.DidRender && fe([]);
    }, [_, V.status]), p.useEffect(function() {
      if (le.length !== 0) {
        var me = E.current;
        if (j.pageIndex === C && me && V.status === e.LayerRenderStatus.DidRender) {
          var _e = me.querySelector('.rpv-search__highlight[data-index="'.concat(j.matchIndex, '"]'));
          if (_e) {
            var Be = function(Ge, st) {
              for (var it = Ge.offsetTop, _t = Ge.offsetLeft, tt = Ge.parentElement; tt && tt !== st; ) it += tt.offsetTop, _t += tt.offsetLeft, tt = tt.parentElement;
              return { left: _t, top: it };
            }(_e, me), ke = Be.left, de = Be.top, $e = M.get("jumpToDestination");
            $e && ($e({ pageIndex: C, bottomOffset: (me.getBoundingClientRect().height - de) / V.scale, leftOffset: ke / V.scale, scaleTo: V.scale }), re.current && re.current.classList.remove("rpv-search__highlight--current"), re.current = _e, _e.classList.add("rpv-search__highlight--current"));
          }
        }
      }
    }, [le, j]), p.useEffect(function() {
      return M.subscribe("keyword", ce), M.subscribe("matchPosition", q), M.subscribe("renderStatus", Z), function() {
        M.unsubscribe("keyword", ce), M.unsubscribe("matchPosition", q), M.unsubscribe("renderStatus", Z);
      };
    }, []), p.createElement("div", { className: "rpv-search__highlights", "data-testid": "search__highlights-".concat(C), ref: E }, y({ getCssProperties: G, highlightAreas: le }));
  }, S = function(a) {
    var f, C = a.wholeWords ? " ".concat(a.keyword, " ") : a.keyword, R = a.matchCase ? "g" : "gi";
    return { keyword: a.keyword, regExp: new RegExp((f = C, f.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")), R), wholeWords: a.wholeWords || !1 };
  }, r = function(a, f, C) {
    return a instanceof RegExp ? { keyword: a.source, regExp: a, wholeWords: C || !1 } : typeof a == "string" ? a === "" ? Q : S({ keyword: a, matchCase: f || !1, wholeWords: C || !1 }) : (f !== void 0 && (a.matchCase = f), C !== void 0 && (a.wholeWords = C), S(a));
  }, u = function(a) {
    var f, C = a.get("initialKeyword"), R = p.useMemo(function() {
      if (C && C.length === 1) {
        var q = r(C[0]);
        return { matchCase: q.regExp.flags.indexOf("i") === -1, wholeWords: q.wholeWords };
      }
      return { matchCase: !1, wholeWords: !1 };
    }, []), M = function(q) {
      var Z = p.useRef(q.get("doc")), pe = function(me) {
        Z.current = me;
      };
      return p.useEffect(function() {
        return q.subscribe("doc", pe), function() {
          q.unsubscribe("doc", pe);
        };
      }, []), Z;
    }(a), I = p.useState(C), E = I[0], T = I[1], y = p.useState([]), D = y[0], j = y[1], A = p.useState(0), d = A[0], _ = A[1], F = p.useState(R.matchCase), U = F[0], V = F[1], $ = p.useRef([]), re = p.useState(R.wholeWords), ge = re[0], be = re[1], le = function() {
      return !0;
    }, fe = p.useCallback(function() {
      return a.get("targetPageFilter") || le;
    }, [a.get("targetPageFilter")]), Ae = function(q) {
      var Z = D.length;
      if (E.length === 0 || Z === 0) return null;
      var pe = q === Z + 1 ? 1 : Math.max(1, Math.min(Z, q));
      return _(pe), ye(D[pe - 1]);
    }, qe = function(q) {
      return T(q === "" ? [] : [q]);
    }, ye = function(q) {
      var Z = a.get("jumpToPage");
      return Z && Z(q.pageIndex), a.update("matchPosition", { matchIndex: q.matchIndex, pageIndex: q.pageIndex }), q;
    }, ce = function(q, Z, pe) {
      var me = M.current;
      if (!me) return Promise.resolve([]);
      var _e = me.numPages, Be = q.map(function(ke) {
        return r(ke, Z, pe);
      });
      return a.update("keyword", Be), _(0), j([]), new Promise(function(ke, de) {
        var $e = $.current.length === 0 ? function() {
          var Ge = M.current;
          if (!Ge) return Promise.resolve([]);
          var st = Array(Ge.numPages).fill(0).map(function(it, _t) {
            return e.getPage(Ge, _t).then(function(tt) {
              return tt.getTextContent();
            }).then(function(tt) {
              var Xe = tt.items.map(function(ct) {
                return ct.str || "";
              }).join("");
              return Promise.resolve({ pageContent: Xe, pageIndex: _t });
            });
          });
          return Promise.all(st).then(function(it) {
            return it.sort(function(_t, tt) {
              return _t.pageIndex - tt.pageIndex;
            }), Promise.resolve(it.map(function(_t) {
              return _t.pageContent;
            }));
          });
        }().then(function(Ge) {
          return $.current = Ge, Promise.resolve(Ge);
        }) : Promise.resolve($.current);
        $e.then(function(Ge) {
          var st = [];
          Ge.forEach(function(it, _t) {
            fe()({ pageIndex: _t, numPages: _e }) && Be.forEach(function(tt) {
              for (var Xe, ct = 0; (Xe = tt.regExp.exec(it)) !== null; ) st.push({ keyword: tt.regExp, matchIndex: ct, pageIndex: _t, pageText: it, startIndex: Xe.index, endIndex: tt.regExp.lastIndex }), ct++;
            });
          }), j(st), st.length > 0 && (_(1), ye(st[0])), ke(st);
        });
      });
    };
    return p.useEffect(function() {
      $.current = [];
    }, [M.current]), { clearKeyword: function() {
      a.update("keyword", [Q]), qe(""), _(0), j([]), V(!1), be(!1);
    }, changeMatchCase: function(q) {
      V(q), E.length > 0 && ce(E, q, ge);
    }, changeWholeWords: function(q) {
      be(q), E.length > 0 && ce(E, U, q);
    }, currentMatch: d, jumpToMatch: Ae, jumpToNextMatch: function() {
      return Ae(d + 1);
    }, jumpToPreviousMatch: function() {
      return Ae(d - 1);
    }, keywords: E, matchCase: U, numberOfMatches: D.length, wholeWords: ge, search: function() {
      return ce(E, U, ge);
    }, searchFor: ce, setKeywords: T, keyword: E.length === 0 ? "" : (f = E[0], f instanceof RegExp ? f.source : typeof f == "string" ? f : f.keyword), setKeyword: qe, setTargetPages: function(q) {
      a.update("targetPageFilter", q);
    } };
  }, m = function(a) {
    var f = a.children, C = a.store, R = u(C), M = p.useState(!1), I = M[0], E = M[1], T = function(y) {
      return E(!0);
    };
    return p.useEffect(function() {
      return C.subscribe("doc", T), function() {
        C.unsubscribe("doc", T);
      };
    }, []), f(W(W({}, R), { isDocumentLoaded: I }));
  }, s = function(a) {
    var f = a.containerRef, C = a.store, R = p.useRef(!1), M = function() {
      R.current = !0;
    }, I = function() {
      R.current = !1;
    }, E = function(T) {
      var y = f.current;
      y && (T.shiftKey || T.altKey || T.key !== "f" || (e.isMac() ? T.metaKey && !T.ctrlKey : T.ctrlKey) && (R.current || document.activeElement && y.contains(document.activeElement)) && (T.preventDefault(), C.update("areShortcutsPressed", !0)));
    };
    return p.useEffect(function() {
      var T = f.current;
      if (T) return document.addEventListener("keydown", E), T.addEventListener("mouseenter", M), T.addEventListener("mouseleave", I), function() {
        document.removeEventListener("keydown", E), T.removeEventListener("mouseenter", M), T.removeEventListener("mouseleave", I);
      };
    }, [f.current]), p.createElement(p.Fragment, null);
  }, w = { left: 0, top: 8 }, i = function(a) {
    var f = a.store, C = a.onToggle, R = p.useContext(e.LocalizationContext).l10n, M = p.useContext(e.ThemeContext).direction, I = p.useState(!1), E = I[0], T = I[1], y = p.useState(!1), D = y[0], j = y[1], A = M === e.TextDirection.RightToLeft, d = u(f), _ = d.clearKeyword, F = d.changeMatchCase, U = d.changeWholeWords, V = d.currentMatch, $ = d.jumpToNextMatch, re = d.jumpToPreviousMatch, ge = d.keyword, be = d.matchCase, le = d.numberOfMatches, fe = d.wholeWords, Ae = d.search, qe = d.setKeyword, ye = function(me) {
      T(!0), Ae().then(function(_e) {
        T(!1), j(!0), me && me();
      });
    };
    p.useEffect(function() {
      var me = f.get("initialKeyword");
      me && me.length === 1 && ge && ye(function() {
        f.update("initialKeyword", []);
      });
    }, []);
    var ce = R && R.search ? R.search.enterToSearch : "Enter to search", q = R && R.search ? R.search.previousMatch : "Previous match", Z = R && R.search ? R.search.nextMatch : "Next match", pe = R && R.search ? R.search.close : "Close";
    return p.createElement("div", { className: "rpv-search__popover" }, p.createElement("div", { className: "rpv-search__popover-input-counter" }, p.createElement(e.TextBox, { ariaLabel: ce, autoFocus: !0, placeholder: ce, type: "text", value: ge, onChange: function(me) {
      j(!1), qe(me);
    }, onKeyDown: function(me) {
      me.key === "Enter" && ge && (D ? $() : ye());
    } }), p.createElement("div", { className: e.classNames({ "rpv-search__popover-counter": !0, "rpv-search__popover-counter--ltr": !A, "rpv-search__popover-counter--rtl": A }) }, E && p.createElement(e.Spinner, { testId: "search__popover-searching", size: "1rem" }), !E && p.createElement("span", { "data-testid": "search__popover-num-matches" }, V, "/", le))), p.createElement("label", { className: "rpv-search__popover-label" }, p.createElement("input", { className: "rpv-search__popover-label-checkbox", "data-testid": "search__popover-match-case", checked: be, type: "checkbox", onChange: function(me) {
      j(!1), F(me.target.checked);
    } }), " ", R && R.search ? R.search.matchCase : "Match case"), p.createElement("label", { className: "rpv-search__popover-label" }, p.createElement("input", { className: "rpv-search__popover-label-checkbox", checked: fe, "data-testid": "search__popover-whole-words", type: "checkbox", onChange: function(me) {
      j(!1), U(me.target.checked);
    } }), " ", R && R.search ? R.search.wholeWords : "Whole words"), p.createElement("div", { className: "rpv-search__popover-footer" }, p.createElement("div", { className: "rpv-search__popover-footer-item" }, p.createElement(e.Tooltip, { ariaControlsSuffix: "search-previous-match", position: A ? e.Position.BottomRight : e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaLabel: q, isDisabled: V <= 1, onClick: re }, p.createElement(t, null)), content: function() {
      return q;
    }, offset: w })), p.createElement("div", { className: "rpv-search__popover-footer-item" }, p.createElement(e.Tooltip, { ariaControlsSuffix: "search-next-match", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaLabel: Z, isDisabled: V > le - 1, onClick: $ }, p.createElement(n, null)), content: function() {
      return Z;
    }, offset: w })), p.createElement("div", { className: e.classNames({ "rpv-search__popover-footer-button": !0, "rpv-search__popover-footer-button--ltr": !A, "rpv-search__popover-footer-button--rtl": A }) }, p.createElement(e.Button, { onClick: function() {
      C(), _();
    } }, pe))));
  }, o = function(a) {
    var f = a.children, C = a.onClick, R = p.useContext(e.LocalizationContext).l10n, M = R && R.search ? R.search.search : "Search";
    return f({ icon: p.createElement(l, null), label: M, onClick: C });
  }, b = { left: 0, top: 8 }, g = function(a) {
    var f = a.enableShortcuts, C = a.store, R = a.onClick, M = f ? e.isMac() ? "Meta+F" : "Ctrl+F" : "", I = function(E) {
      E && R();
    };
    return p.useEffect(function() {
      return C.subscribe("areShortcutsPressed", I), function() {
        C.unsubscribe("areShortcutsPressed", I);
      };
    }, []), p.createElement(o, { onClick: R }, function(E) {
      return p.createElement(e.Tooltip, { ariaControlsSuffix: "search-popover", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaKeyShortcuts: M, ariaLabel: E.label, testId: "search__popover-button", onClick: R }, E.icon), content: function() {
        return E.label;
      }, offset: b });
    });
  }, c = { left: 0, top: 8 }, v = function(a) {
    var f = a.children, C = a.enableShortcuts, R = a.store, M = p.useContext(e.ThemeContext).direction === e.TextDirection.RightToLeft ? e.Position.BottomRight : e.Position.BottomLeft, I = f || function(E) {
      return p.createElement(g, W({ enableShortcuts: C, store: R }, E));
    };
    return p.createElement(e.Popover, { ariaControlsSuffix: "search", lockScroll: !1, position: M, target: function(E) {
      return I({ onClick: E });
    }, content: function(E) {
      return p.createElement(i, { store: R, onToggle: E });
    }, offset: c, closeOnClickOutside: !1, closeOnEscape: !0 });
  }, k = function(a) {
    return Array.isArray(a) ? a.map(function(f) {
      return r(f);
    }) : [r(a)];
  };
  return search_min.NextIcon = n, search_min.PreviousIcon = t, search_min.SearchIcon = l, search_min.searchPlugin = function(a) {
    var f = p.useMemo(function() {
      return Object.assign({}, { enableShortcuts: !0, onHighlightKeyword: function() {
      } }, a);
    }, []), C = p.useMemo(function() {
      return e.createStore({ initialKeyword: a && a.keyword ? Array.isArray(a.keyword) ? a.keyword : [a.keyword] : [], keyword: a && a.keyword ? k(a.keyword) : [Q], matchPosition: { matchIndex: -1, pageIndex: -1 }, renderStatus: /* @__PURE__ */ new Map() });
    }, []), R = u(C), M = R.clearKeyword, I = R.jumpToMatch, E = R.jumpToNextMatch, T = R.jumpToPreviousMatch, y = R.searchFor, D = R.setKeywords, j = R.setTargetPages, A = function(d) {
      return p.createElement(v, W({ enableShortcuts: f.enableShortcuts }, d, { store: C }));
    };
    return { install: function(d) {
      var _ = a && a.keyword ? Array.isArray(a.keyword) ? a.keyword : [a.keyword] : [], F = a && a.keyword ? k(a.keyword) : [Q];
      C.update("initialKeyword", _), C.update("jumpToDestination", d.jumpToDestination), C.update("jumpToPage", d.jumpToPage), C.update("keyword", F);
    }, renderPageLayer: function(d) {
      return p.createElement(P, { key: d.pageIndex, numPages: d.doc.numPages, pageIndex: d.pageIndex, renderHighlights: a == null ? void 0 : a.renderHighlights, store: C, onHighlightKeyword: f.onHighlightKeyword });
    }, renderViewer: function(d) {
      var _ = d.slot;
      return _.subSlot && (_.subSlot.children = p.createElement(p.Fragment, null, f.enableShortcuts && p.createElement(s, { containerRef: d.containerRef, store: C }), _.subSlot.children)), _;
    }, uninstall: function(d) {
      var _ = C.get("renderStatus");
      _ && _.clear();
    }, onDocumentLoad: function(d) {
      C.update("doc", d.doc);
    }, onTextLayerRender: function(d) {
      var _ = C.get("renderStatus");
      _ && (_ = _.set(d.pageIndex, d), C.update("renderStatus", _));
    }, Search: function(d) {
      return p.createElement(m, W({}, d, { store: C }));
    }, ShowSearchPopover: A, ShowSearchPopoverButton: function() {
      return p.createElement(A, null, function(d) {
        return p.createElement(g, W({ enableShortcuts: f.enableShortcuts, store: C }, d));
      });
    }, clearHighlights: function() {
      M();
    }, highlight: function(d) {
      var _ = Array.isArray(d) ? d : [d];
      return D(_), y(_);
    }, jumpToMatch: I, jumpToNextMatch: E, jumpToPreviousMatch: T, setTargetPages: j };
  }, search_min;
}
var search = {}, hasRequiredSearch;
function requireSearch() {
  if (hasRequiredSearch) return search;
  hasRequiredSearch = 1;
  var e = requireLib$h(), L = requireReact();
  function p(E) {
    var T = /* @__PURE__ */ Object.create(null);
    return E && Object.keys(E).forEach(function(y) {
      if (y !== "default") {
        var D = Object.getOwnPropertyDescriptor(E, y);
        Object.defineProperty(T, y, D.get ? D : {
          enumerable: !0,
          get: function() {
            return E[y];
          }
        });
      }
    }), T.default = E, Object.freeze(T);
  }
  var n = /* @__PURE__ */ p(L), t = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: `M0.541,5.627L11.666,18.2c0.183,0.207,0.499,0.226,0.706,0.043c0.015-0.014,0.03-0.028,0.043-0.043
            L23.541,5.627` })
    );
  }, l = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: `M23.535,18.373L12.409,5.8c-0.183-0.207-0.499-0.226-0.706-0.043C11.688,5.77,11.674,5.785,11.66,5.8
            L0.535,18.373` })
    );
  }, W = function() {
    return n.createElement(
      e.Icon,
      { ignoreDirection: !0, size: 16 },
      n.createElement("path", { d: `M10.5,0.5c5.523,0,10,4.477,10,10s-4.477,10-10,10s-10-4.477-10-10S4.977,0.5,10.5,0.5z
            M23.5,23.5
            l-5.929-5.929` })
    );
  }, Q = function() {
    return Q = Object.assign || function(T) {
      for (var y, D = 1, j = arguments.length; D < j; D++) {
        y = arguments[D];
        for (var A in y) Object.prototype.hasOwnProperty.call(y, A) && (T[A] = y[A]);
      }
      return T;
    }, Q.apply(this, arguments);
  }, G = {
    keyword: "",
    regExp: new RegExp(" "),
    wholeWords: !1
  }, X = function(E, T) {
    for (var y = E.offsetTop, D = E.offsetLeft, j = E.parentElement; j && j !== T; )
      y += j.offsetTop, D += j.offsetLeft, j = j.parentElement;
    return {
      left: D,
      top: y
    };
  }, N = function(E) {
    return {
      left: "".concat(E.left, "%"),
      top: "".concat(E.top, "%"),
      height: "".concat(E.height, "%"),
      width: "".concat(E.width, "%")
    };
  }, H = function(E) {
    var T = E.index, y = E.area, D = E.onHighlightKeyword, j = n.useRef();
    return e.useIsomorphicLayoutEffect(function() {
      var A = j.current;
      D && A && D({
        highlightEle: A,
        keyword: y.keyword
      });
    }, []), n.createElement("div", { className: "rpv-search__highlight", "data-index": T, ref: j, style: N(y), title: y.keywordStr.trim() });
  }, B = function(E) {
    var T = E.parentNode;
    T && T.removeChild(E);
  }, P = function(E, T) {
    B(E);
    var y = T.parentNode;
    y && y.insertBefore(E, T), B(T);
  }, S = function(E) {
    var T = E.parentNode;
    if (T) {
      var y = document.createRange();
      y.selectNodeContents(E), P(y.extractContents(), E), T.normalize();
    }
  }, r = function(E, T) {
    return E.top < T.top ? -1 : E.top > T.top ? 1 : E.left < T.left ? -1 : E.left > T.left ? 1 : 0;
  }, u = function(E) {
    var T = E.numPages, y = E.pageIndex, D = E.renderHighlights, j = E.store, A = E.onHighlightKeyword, d = n.useRef(), _ = n.useCallback(function(st) {
      return n.createElement(n.Fragment, null, st.highlightAreas.map(function(it, _t) {
        return n.createElement(H, { index: _t, key: _t, area: it, onHighlightKeyword: A });
      }));
    }, []), F = D || _, U = n.useState(j.get("matchPosition")), V = U[0], $ = U[1], re = n.useState(j.get("keyword") || [G]), ge = re[0], be = re[1], le = n.useState({
      pageIndex: y,
      scale: 1,
      status: e.LayerRenderStatus.PreRender
    }), fe = le[0], Ae = le[1], qe = n.useRef(null), ye = n.useRef([]), ce = n.useState([]), q = ce[0], Z = ce[1], pe = function() {
      return !0;
    }, me = n.useCallback(function() {
      return j.get("targetPageFilter") || pe;
    }, [j.get("targetPageFilter")]), _e = function(st, it, _t, tt, Xe) {
      var ct = document.createRange(), xt = tt.firstChild;
      if (!xt || xt.nodeType !== Node.TEXT_NODE)
        return null;
      var We = xt.textContent.length, Ce = Xe[0].charIndexInSpan, Re = Xe.length === 1 ? Ce : Xe[Xe.length - 1].charIndexInSpan;
      if (Ce > We || Re + 1 > We)
        return null;
      ct.setStart(xt, Ce), ct.setEnd(xt, Re + 1);
      var lt = document.createElement("span");
      ct.surroundContents(lt);
      var bt = lt.getBoundingClientRect(), Et = _t.getBoundingClientRect(), oe = Et.height, He = Et.width, at = 100 * (bt.left - Et.left) / He, St = 100 * (bt.top - Et.top) / oe, yt = 100 * bt.height / oe, dt = 100 * bt.width / He;
      return S(lt), {
        keyword: it,
        keywordStr: st,
        numPages: T,
        pageIndex: y,
        left: at,
        top: St,
        height: yt,
        width: dt,
        pageHeight: oe,
        pageWidth: He
      };
    }, Be = function(st) {
      var it = ye.current;
      if (it.length === 0)
        return [];
      var _t = [], tt = [].slice.call(st.querySelectorAll(".rpv-core__text-layer-text")), Xe = it.map(function(ct) {
        return ct.char;
      }).join("");
      return ge.forEach(function(ct) {
        var xt = ct.keyword;
        if (xt.trim()) {
          for (var We = ct.regExp.flags.indexOf("g") === -1 ? new RegExp(ct.regExp, "".concat(ct.regExp.flags, "g")) : ct.regExp, Ce, Re = []; (Ce = We.exec(Xe)) !== null; )
            Re.push({
              keyword: We,
              startIndex: Ce.index,
              endIndex: We.lastIndex
            });
          Re.map(function(lt) {
            return {
              keyword: lt.keyword,
              indexes: it.slice(lt.startIndex, lt.endIndex)
            };
          }).forEach(function(lt) {
            var bt = lt.indexes.reduce(function(Et, oe) {
              return Et[oe.spanIndex] = (Et[oe.spanIndex] || []).concat([oe]), Et;
            }, {});
            Object.values(bt).forEach(function(Et) {
              if (Et.length !== 1 || Et[0].char.trim() !== "") {
                var oe = ct.wholeWords ? Et.slice(1, -1) : Et, He = _e(xt, lt.keyword, st, tt[oe[0].spanIndex], oe);
                He && _t.push(He);
              }
            });
          });
        }
      }), _t.sort(r);
    }, ke = function(st) {
      st && st.length > 0 && be(st);
    }, de = function(st) {
      return $(st);
    }, $e = function(st) {
      if (st.has(y)) {
        var it = st.get(y);
        it && Ae({
          ele: it.ele,
          pageIndex: y,
          scale: it.scale,
          status: it.status
        });
      }
    }, Ge = function() {
      return ge.length === 0 || ge.length === 1 && ge[0].keyword.trim() === "";
    };
    return n.useEffect(function() {
      if (!(Ge() || fe.status !== e.LayerRenderStatus.DidRender || ye.current.length)) {
        var st = fe.ele, it = [].slice.call(st.querySelectorAll(".rpv-core__text-layer-text")), _t = it.map(function(tt) {
          return tt.textContent;
        }).reduce(function(tt, Xe, ct) {
          return tt.concat(Xe.split("").map(function(xt, We) {
            return {
              char: xt,
              charIndexInSpan: We,
              spanIndex: ct
            };
          }));
        }, [
          {
            char: "",
            charIndexInSpan: 0,
            spanIndex: 0
          }
        ]).slice(1);
        ye.current = _t;
      }
    }, [ge, fe.status]), n.useEffect(function() {
      if (!(Ge() || !fe.ele || fe.status !== e.LayerRenderStatus.DidRender || !me()({ pageIndex: y, numPages: T }))) {
        var st = fe.ele, it = Be(st);
        Z(it);
      }
    }, [ge, V, fe.status, ye.current]), n.useEffect(function() {
      Ge() && fe.ele && fe.status === e.LayerRenderStatus.DidRender && Z([]);
    }, [ge, fe.status]), n.useEffect(function() {
      if (q.length !== 0) {
        var st = d.current;
        if (!(V.pageIndex !== y || !st || fe.status !== e.LayerRenderStatus.DidRender)) {
          var it = st.querySelector('.rpv-search__highlight[data-index="'.concat(V.matchIndex, '"]'));
          if (it) {
            var _t = X(it, st), tt = _t.left, Xe = _t.top, ct = j.get("jumpToDestination");
            ct && (ct({
              pageIndex: y,
              bottomOffset: (st.getBoundingClientRect().height - Xe) / fe.scale,
              leftOffset: tt / fe.scale,
              scaleTo: fe.scale
            }), qe.current && qe.current.classList.remove("rpv-search__highlight--current"), qe.current = it, it.classList.add("rpv-search__highlight--current"));
          }
        }
      }
    }, [q, V]), n.useEffect(function() {
      return j.subscribe("keyword", ke), j.subscribe("matchPosition", de), j.subscribe("renderStatus", $e), function() {
        j.unsubscribe("keyword", ke), j.unsubscribe("matchPosition", de), j.unsubscribe("renderStatus", $e);
      };
    }, []), n.createElement("div", { className: "rpv-search__highlights", "data-testid": "search__highlights-".concat(y), ref: d }, F({
      getCssProperties: N,
      highlightAreas: q
    }));
  }, m = function(E) {
    return E.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }, s = function(E) {
    var T = E.wholeWords ? " ".concat(E.keyword, " ") : E.keyword, y = E.matchCase ? "g" : "gi";
    return {
      keyword: E.keyword,
      regExp: new RegExp(m(T), y),
      wholeWords: E.wholeWords || !1
    };
  }, w = function(E, T, y) {
    return E instanceof RegExp ? {
      keyword: E.source,
      regExp: E,
      wholeWords: y || !1
    } : typeof E == "string" ? E === "" ? G : s({
      keyword: E,
      matchCase: T || !1,
      wholeWords: y || !1
    }) : (typeof T < "u" && (E.matchCase = T), typeof y < "u" && (E.wholeWords = y), s(E));
  }, i = function(E) {
    var T = n.useRef(E.get("doc")), y = function(D) {
      T.current = D;
    };
    return n.useEffect(function() {
      return E.subscribe("doc", y), function() {
        E.unsubscribe("doc", y);
      };
    }, []), T;
  }, o = function(E) {
    var T = E.get("initialKeyword"), y = n.useMemo(function() {
      if (T && T.length === 1) {
        var Xe = w(T[0]);
        return {
          matchCase: Xe.regExp.flags.indexOf("i") === -1,
          wholeWords: Xe.wholeWords
        };
      } else
        return {
          matchCase: !1,
          wholeWords: !1
        };
    }, []), D = i(E), j = n.useState(T), A = j[0], d = j[1], _ = n.useState([]), F = _[0], U = _[1], V = n.useState(0), $ = V[0], re = V[1], ge = n.useState(y.matchCase), be = ge[0], le = ge[1], fe = n.useRef([]), Ae = n.useState(y.wholeWords), qe = Ae[0], ye = Ae[1], ce = function() {
      return !0;
    }, q = n.useCallback(function() {
      return E.get("targetPageFilter") || ce;
    }, [E.get("targetPageFilter")]), Z = function(Xe) {
      le(Xe), A.length > 0 && tt(A, Xe, qe);
    }, pe = function(Xe) {
      ye(Xe), A.length > 0 && tt(A, be, Xe);
    }, me = function(Xe) {
      var ct = F.length;
      if (A.length === 0 || ct === 0)
        return null;
      var xt = Xe === ct + 1 ? 1 : Math.max(1, Math.min(ct, Xe));
      return re(xt), it(F[xt - 1]);
    }, _e = function() {
      return me($ - 1);
    }, Be = function() {
      return me($ + 1);
    }, ke = function() {
      E.update("keyword", [G]), $e(""), re(0), U([]), le(!1), ye(!1);
    }, de = function() {
      return tt(A, be, qe);
    }, $e = function(Xe) {
      return d(Xe === "" ? [] : [Xe]);
    }, Ge = function(Xe) {
      E.update("targetPageFilter", Xe);
    }, st = function() {
      var Xe = D.current;
      if (!Xe)
        return Promise.resolve([]);
      var ct = Array(Xe.numPages).fill(0).map(function(xt, We) {
        return e.getPage(Xe, We).then(function(Ce) {
          return Ce.getTextContent();
        }).then(function(Ce) {
          var Re = Ce.items.map(function(lt) {
            return lt.str || "";
          }).join("");
          return Promise.resolve({
            pageContent: Re,
            pageIndex: We
          });
        });
      });
      return Promise.all(ct).then(function(xt) {
        return xt.sort(function(We, Ce) {
          return We.pageIndex - Ce.pageIndex;
        }), Promise.resolve(xt.map(function(We) {
          return We.pageContent;
        }));
      });
    }, it = function(Xe) {
      var ct = E.get("jumpToPage");
      return ct && ct(Xe.pageIndex), E.update("matchPosition", {
        matchIndex: Xe.matchIndex,
        pageIndex: Xe.pageIndex
      }), Xe;
    }, _t = function(Xe) {
      return Xe instanceof RegExp ? Xe.source : typeof Xe == "string" ? Xe : Xe.keyword;
    }, tt = function(Xe, ct, xt) {
      var We = D.current;
      if (!We)
        return Promise.resolve([]);
      var Ce = We.numPages, Re = Xe.map(function(lt) {
        return w(lt, ct, xt);
      });
      return E.update("keyword", Re), re(0), U([]), new Promise(function(lt, bt) {
        var Et = fe.current.length === 0 ? st().then(function(oe) {
          return fe.current = oe, Promise.resolve(oe);
        }) : Promise.resolve(fe.current);
        Et.then(function(oe) {
          var He = [];
          oe.forEach(function(at, St) {
            q()({ pageIndex: St, numPages: Ce }) && Re.forEach(function(yt) {
              for (var dt = 0, ie; (ie = yt.regExp.exec(at)) !== null; )
                He.push({
                  keyword: yt.regExp,
                  matchIndex: dt,
                  pageIndex: St,
                  pageText: at,
                  startIndex: ie.index,
                  endIndex: yt.regExp.lastIndex
                }), dt++;
            });
          }), U(He), He.length > 0 && (re(1), it(He[0])), lt(He);
        });
      });
    };
    return n.useEffect(function() {
      fe.current = [];
    }, [D.current]), {
      clearKeyword: ke,
      changeMatchCase: Z,
      changeWholeWords: pe,
      currentMatch: $,
      jumpToMatch: me,
      jumpToNextMatch: Be,
      jumpToPreviousMatch: _e,
      keywords: A,
      matchCase: be,
      numberOfMatches: F.length,
      wholeWords: qe,
      search: de,
      searchFor: tt,
      setKeywords: d,
      keyword: A.length === 0 ? "" : _t(A[0]),
      setKeyword: $e,
      setTargetPages: Ge
    };
  }, b = function(E) {
    var T = E.children, y = E.store, D = o(y), j = n.useState(!1), A = j[0], d = j[1], _ = function(F) {
      return d(!0);
    };
    return n.useEffect(function() {
      return y.subscribe("doc", _), function() {
        y.unsubscribe("doc", _);
      };
    }, []), T(Q(Q({}, D), { isDocumentLoaded: A }));
  }, g = function(E) {
    var T = E.containerRef, y = E.store, D = n.useRef(!1), j = function() {
      D.current = !0;
    }, A = function() {
      D.current = !1;
    }, d = function(_) {
      var F = T.current;
      if (F && !(_.shiftKey || _.altKey || _.key !== "f")) {
        var U = e.isMac() ? _.metaKey && !_.ctrlKey : _.ctrlKey;
        U && (D.current || document.activeElement && F.contains(document.activeElement)) && (_.preventDefault(), y.update("areShortcutsPressed", !0));
      }
    };
    return n.useEffect(function() {
      var _ = T.current;
      if (_)
        return document.addEventListener("keydown", d), _.addEventListener("mouseenter", j), _.addEventListener("mouseleave", A), function() {
          document.removeEventListener("keydown", d), _.removeEventListener("mouseenter", j), _.removeEventListener("mouseleave", A);
        };
    }, [T.current]), n.createElement(n.Fragment, null);
  }, c = { left: 0, top: 8 }, v = function(E) {
    var T = E.store, y = E.onToggle, D = n.useContext(e.LocalizationContext).l10n, j = n.useContext(e.ThemeContext).direction, A = n.useState(!1), d = A[0], _ = A[1], F = n.useState(!1), U = F[0], V = F[1], $ = j === e.TextDirection.RightToLeft, re = o(T), ge = re.clearKeyword, be = re.changeMatchCase, le = re.changeWholeWords, fe = re.currentMatch, Ae = re.jumpToNextMatch, qe = re.jumpToPreviousMatch, ye = re.keyword, ce = re.matchCase, q = re.numberOfMatches, Z = re.wholeWords, pe = re.search, me = re.setKeyword, _e = function(Xe) {
      _(!0), pe().then(function(ct) {
        _(!1), V(!0), Xe && Xe();
      });
    }, Be = function(Xe) {
      Xe.key === "Enter" && ye && (U ? Ae() : _e());
    }, ke = function(Xe) {
      V(!1), be(Xe.target.checked);
    }, de = function(Xe) {
      V(!1), le(Xe.target.checked);
    }, $e = function() {
      y(), ge();
    }, Ge = function(Xe) {
      V(!1), me(Xe);
    };
    n.useEffect(function() {
      var Xe = T.get("initialKeyword");
      Xe && Xe.length === 1 && ye && _e(function() {
        T.update("initialKeyword", []);
      });
    }, []);
    var st = D && D.search ? D.search.enterToSearch : "Enter to search", it = D && D.search ? D.search.previousMatch : "Previous match", _t = D && D.search ? D.search.nextMatch : "Next match", tt = D && D.search ? D.search.close : "Close";
    return n.createElement(
      "div",
      { className: "rpv-search__popover" },
      n.createElement(
        "div",
        { className: "rpv-search__popover-input-counter" },
        n.createElement(e.TextBox, { ariaLabel: st, autoFocus: !0, placeholder: st, type: "text", value: ye, onChange: Ge, onKeyDown: Be }),
        n.createElement(
          "div",
          { className: e.classNames({
            "rpv-search__popover-counter": !0,
            "rpv-search__popover-counter--ltr": !$,
            "rpv-search__popover-counter--rtl": $
          }) },
          d && n.createElement(e.Spinner, { testId: "search__popover-searching", size: "1rem" }),
          !d && n.createElement(
            "span",
            { "data-testid": "search__popover-num-matches" },
            fe,
            "/",
            q
          )
        )
      ),
      n.createElement(
        "label",
        { className: "rpv-search__popover-label" },
        n.createElement("input", { className: "rpv-search__popover-label-checkbox", "data-testid": "search__popover-match-case", checked: ce, type: "checkbox", onChange: ke }),
        " ",
        D && D.search ? D.search.matchCase : "Match case"
      ),
      n.createElement(
        "label",
        { className: "rpv-search__popover-label" },
        n.createElement("input", { className: "rpv-search__popover-label-checkbox", checked: Z, "data-testid": "search__popover-whole-words", type: "checkbox", onChange: de }),
        " ",
        D && D.search ? D.search.wholeWords : "Whole words"
      ),
      n.createElement(
        "div",
        { className: "rpv-search__popover-footer" },
        n.createElement(
          "div",
          { className: "rpv-search__popover-footer-item" },
          n.createElement(e.Tooltip, { ariaControlsSuffix: "search-previous-match", position: $ ? e.Position.BottomRight : e.Position.BottomCenter, target: n.createElement(
            e.MinimalButton,
            { ariaLabel: it, isDisabled: fe <= 1, onClick: qe },
            n.createElement(l, null)
          ), content: function() {
            return it;
          }, offset: c })
        ),
        n.createElement(
          "div",
          { className: "rpv-search__popover-footer-item" },
          n.createElement(e.Tooltip, { ariaControlsSuffix: "search-next-match", position: e.Position.BottomCenter, target: n.createElement(
            e.MinimalButton,
            { ariaLabel: _t, isDisabled: fe > q - 1, onClick: Ae },
            n.createElement(t, null)
          ), content: function() {
            return _t;
          }, offset: c })
        ),
        n.createElement(
          "div",
          { className: e.classNames({
            "rpv-search__popover-footer-button": !0,
            "rpv-search__popover-footer-button--ltr": !$,
            "rpv-search__popover-footer-button--rtl": $
          }) },
          n.createElement(e.Button, { onClick: $e }, tt)
        )
      )
    );
  }, k = function(E) {
    var T = E.children, y = E.onClick, D = n.useContext(e.LocalizationContext).l10n, j = D && D.search ? D.search.search : "Search", A = n.createElement(W, null);
    return T({ icon: A, label: j, onClick: y });
  }, a = { left: 0, top: 8 }, f = function(E) {
    var T = E.enableShortcuts, y = E.store, D = E.onClick, j = T ? e.isMac() ? "Meta+F" : "Ctrl+F" : "", A = function(d) {
      d && D();
    };
    return n.useEffect(function() {
      return y.subscribe("areShortcutsPressed", A), function() {
        y.unsubscribe("areShortcutsPressed", A);
      };
    }, []), n.createElement(k, { onClick: D }, function(d) {
      return n.createElement(e.Tooltip, { ariaControlsSuffix: "search-popover", position: e.Position.BottomCenter, target: n.createElement(e.MinimalButton, { ariaKeyShortcuts: j, ariaLabel: d.label, testId: "search__popover-button", onClick: D }, d.icon), content: function() {
        return d.label;
      }, offset: a });
    });
  }, C = { left: 0, top: 8 }, R = function(E) {
    var T = E.children, y = E.enableShortcuts, D = E.store, j = n.useContext(e.ThemeContext).direction, A = j === e.TextDirection.RightToLeft ? e.Position.BottomRight : e.Position.BottomLeft, d = function(F) {
      return n.createElement(f, Q({ enableShortcuts: y, store: D }, F));
    }, _ = T || d;
    return n.createElement(e.Popover, { ariaControlsSuffix: "search", lockScroll: !1, position: A, target: function(F) {
      return _({
        onClick: F
      });
    }, content: function(F) {
      return n.createElement(v, { store: D, onToggle: F });
    }, offset: C, closeOnClickOutside: !1, closeOnEscape: !0 });
  }, M = function(E) {
    return Array.isArray(E) ? E.map(function(T) {
      return w(T);
    }) : [w(E)];
  }, I = function(E) {
    var T = n.useMemo(function() {
      return Object.assign({}, { enableShortcuts: !0, onHighlightKeyword: function() {
      } }, E);
    }, []), y = n.useMemo(function() {
      return e.createStore({
        initialKeyword: E && E.keyword ? Array.isArray(E.keyword) ? E.keyword : [E.keyword] : [],
        keyword: E && E.keyword ? M(E.keyword) : [G],
        matchPosition: {
          matchIndex: -1,
          pageIndex: -1
        },
        renderStatus: /* @__PURE__ */ new Map()
      });
    }, []), D = o(y), j = D.clearKeyword, A = D.jumpToMatch, d = D.jumpToNextMatch, _ = D.jumpToPreviousMatch, F = D.searchFor, U = D.setKeywords, V = D.setTargetPages, $ = function(fe) {
      return n.createElement(b, Q({}, fe, { store: y }));
    }, re = function(fe) {
      return n.createElement(R, Q({ enableShortcuts: T.enableShortcuts }, fe, { store: y }));
    }, ge = function() {
      return n.createElement(re, null, function(fe) {
        return n.createElement(f, Q({ enableShortcuts: T.enableShortcuts, store: y }, fe));
      });
    }, be = function(fe) {
      var Ae = fe.slot;
      return Ae.subSlot && (Ae.subSlot.children = n.createElement(
        n.Fragment,
        null,
        T.enableShortcuts && n.createElement(g, { containerRef: fe.containerRef, store: y }),
        Ae.subSlot.children
      )), Ae;
    }, le = function(fe) {
      return n.createElement(u, { key: fe.pageIndex, numPages: fe.doc.numPages, pageIndex: fe.pageIndex, renderHighlights: E == null ? void 0 : E.renderHighlights, store: y, onHighlightKeyword: T.onHighlightKeyword });
    };
    return {
      install: function(fe) {
        var Ae = E && E.keyword ? Array.isArray(E.keyword) ? E.keyword : [E.keyword] : [], qe = E && E.keyword ? M(E.keyword) : [G];
        y.update("initialKeyword", Ae), y.update("jumpToDestination", fe.jumpToDestination), y.update("jumpToPage", fe.jumpToPage), y.update("keyword", qe);
      },
      renderPageLayer: le,
      renderViewer: be,
      uninstall: function(fe) {
        var Ae = y.get("renderStatus");
        Ae && Ae.clear();
      },
      onDocumentLoad: function(fe) {
        y.update("doc", fe.doc);
      },
      onTextLayerRender: function(fe) {
        var Ae = y.get("renderStatus");
        Ae && (Ae = Ae.set(fe.pageIndex, fe), y.update("renderStatus", Ae));
      },
      Search: $,
      ShowSearchPopover: re,
      ShowSearchPopoverButton: ge,
      clearHighlights: function() {
        j();
      },
      highlight: function(fe) {
        var Ae = Array.isArray(fe) ? fe : [fe];
        return U(Ae), F(Ae);
      },
      jumpToMatch: A,
      jumpToNextMatch: d,
      jumpToPreviousMatch: _,
      setTargetPages: V
    };
  };
  return search.NextIcon = t, search.PreviousIcon = l, search.SearchIcon = W, search.searchPlugin = I, search;
}
var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4) return lib$2.exports;
  hasRequiredLib$4 = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$2.exports = requireSearch_min() : lib$2.exports = requireSearch(), lib$2.exports;
}
var lib$1 = { exports: {} }, theme_min = {}, hasRequiredTheme_min;
function requireTheme_min() {
  if (hasRequiredTheme_min) return theme_min;
  hasRequiredTheme_min = 1;
  var e = requireLib$h();
  function L(N) {
    var H = /* @__PURE__ */ Object.create(null);
    return N && Object.keys(N).forEach(function(B) {
      if (B !== "default") {
        var P = Object.getOwnPropertyDescriptor(N, B);
        Object.defineProperty(H, B, P.get ? P : { enumerable: !0, get: function() {
          return N[B];
        } });
      }
    }), H.default = N, Object.freeze(H);
  }
  var p = L(requireReact()), n = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: "M19.5,15.106l2.4-2.4a1,1,0,0,0,0-1.414l-2.4-2.4V5.5a1,1,0,0,0-1-1H15.106l-2.4-2.4a1,1,0,0,0-1.414,0l-2.4,2.4H5.5a1,1,0,0,0-1,1V8.894l-2.4,2.4a1,1,0,0,0,0,1.414l2.4,2.4V18.5a1,1,0,0,0,1,1H8.894l2.4,2.4a1,1,0,0,0,1.414,0l2.4-2.4H18.5a1,1,0,0,0,1-1Z" }), p.createElement("path", { d: "M10,6.349a6,6,0,0,1,0,11.3,6,6,0,1,0,0-11.3Z" }));
  }, t = function() {
    return p.createElement(e.Icon, { size: 16 }, p.createElement("path", { d: "M19.491,15.106l2.4-2.4a1,1,0,0,0,0-1.414l-2.4-2.4V5.5a1,1,0,0,0-1-1H15.1L12.7,2.1a1,1,0,0,0-1.414,0l-2.4,2.4H5.491a1,1,0,0,0-1,1V8.894l-2.4,2.4a1,1,0,0,0,0,1.414l2.4,2.4V18.5a1,1,0,0,0,1,1H8.885l2.4,2.4a1,1,0,0,0,1.414,0l2.4-2.4h3.394a1,1,0,0,0,1-1Z" }), p.createElement("path", { d: "M11.491,6c4,0,6,2.686,6,6s-2,6-6,6Z" }));
  }, l = function() {
    return l = Object.assign || function(N) {
      for (var H, B = 1, P = arguments.length; B < P; B++) for (var S in H = arguments[B]) Object.prototype.hasOwnProperty.call(H, S) && (N[S] = H[S]);
      return N;
    }, l.apply(this, arguments);
  }, W = { left: 0, top: 8 }, Q = function(N) {
    var H = N.onClick, B = p.useContext(e.ThemeContext), P = p.useContext(e.LocalizationContext).l10n, S = B.currentTheme === "dark", r = P && P.theme ? S ? P.theme.switchLightTheme : P.theme.switchDarkTheme : S ? "Switch to the light theme" : "Switch to the dark theme";
    return p.createElement(e.Tooltip, { ariaControlsSuffix: "theme-switch", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaLabel: r, testId: "theme__switch-button", onClick: H }, S ? p.createElement(t, null) : p.createElement(n, null)), content: function() {
      return r;
    }, offset: W });
  }, G = function(N) {
    var H = N.children, B = p.useContext(e.ThemeContext);
    return (H || function(P) {
      return p.createElement(Q, { onClick: P.onClick });
    })({ onClick: function() {
      return B.setCurrentTheme(B.currentTheme === "dark" ? "light" : "dark");
    } });
  }, X = function(N) {
    var H = N.onClick, B = p.useContext(e.ThemeContext), P = p.useContext(e.LocalizationContext).l10n, S = B.currentTheme === "dark", r = P && P.theme ? S ? P.theme.switchLightTheme : P.theme.switchDarkTheme : S ? "Switch to the light theme" : "Switch to the dark theme";
    return p.createElement(e.MenuItem, { icon: S ? p.createElement(t, null) : p.createElement(n, null), testId: "theme__switch-menu", onClick: H }, r);
  };
  return theme_min.DarkIcon = n, theme_min.LightIcon = t, theme_min.themePlugin = function() {
    var N = function(H) {
      return p.createElement(G, l({}, H));
    };
    return { SwitchTheme: N, SwitchThemeButton: function() {
      return p.createElement(N, null, function(H) {
        return p.createElement(Q, l({}, H));
      });
    }, SwitchThemeMenuItem: function(H) {
      return p.createElement(N, null, function(B) {
        return p.createElement(X, { onClick: function() {
          B.onClick(), H.onClick();
        } });
      });
    } };
  }, theme_min;
}
var theme = {}, hasRequiredTheme;
function requireTheme() {
  if (hasRequiredTheme) return theme;
  hasRequiredTheme = 1;
  var e = requireLib$h(), L = requireReact();
  function p(B) {
    var P = /* @__PURE__ */ Object.create(null);
    return B && Object.keys(B).forEach(function(S) {
      if (S !== "default") {
        var r = Object.getOwnPropertyDescriptor(B, S);
        Object.defineProperty(P, S, r.get ? r : {
          enumerable: !0,
          get: function() {
            return B[S];
          }
        });
      }
    }), P.default = B, Object.freeze(P);
  }
  var n = /* @__PURE__ */ p(L), t = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: "M19.5,15.106l2.4-2.4a1,1,0,0,0,0-1.414l-2.4-2.4V5.5a1,1,0,0,0-1-1H15.106l-2.4-2.4a1,1,0,0,0-1.414,0l-2.4,2.4H5.5a1,1,0,0,0-1,1V8.894l-2.4,2.4a1,1,0,0,0,0,1.414l2.4,2.4V18.5a1,1,0,0,0,1,1H8.894l2.4,2.4a1,1,0,0,0,1.414,0l2.4-2.4H18.5a1,1,0,0,0,1-1Z" }),
      n.createElement("path", { d: "M10,6.349a6,6,0,0,1,0,11.3,6,6,0,1,0,0-11.3Z" })
    );
  }, l = function() {
    return n.createElement(
      e.Icon,
      { size: 16 },
      n.createElement("path", { d: "M19.491,15.106l2.4-2.4a1,1,0,0,0,0-1.414l-2.4-2.4V5.5a1,1,0,0,0-1-1H15.1L12.7,2.1a1,1,0,0,0-1.414,0l-2.4,2.4H5.491a1,1,0,0,0-1,1V8.894l-2.4,2.4a1,1,0,0,0,0,1.414l2.4,2.4V18.5a1,1,0,0,0,1,1H8.885l2.4,2.4a1,1,0,0,0,1.414,0l2.4-2.4h3.394a1,1,0,0,0,1-1Z" }),
      n.createElement("path", { d: "M11.491,6c4,0,6,2.686,6,6s-2,6-6,6Z" })
    );
  }, W = function() {
    return W = Object.assign || function(P) {
      for (var S, r = 1, u = arguments.length; r < u; r++) {
        S = arguments[r];
        for (var m in S) Object.prototype.hasOwnProperty.call(S, m) && (P[m] = S[m]);
      }
      return P;
    }, W.apply(this, arguments);
  }, Q = { left: 0, top: 8 }, G = function(B) {
    var P = B.onClick, S = n.useContext(e.ThemeContext), r = n.useContext(e.LocalizationContext).l10n, u = S.currentTheme === "dark", m = r && r.theme ? u ? r.theme.switchLightTheme : r.theme.switchDarkTheme : u ? "Switch to the light theme" : "Switch to the dark theme";
    return n.createElement(e.Tooltip, { ariaControlsSuffix: "theme-switch", position: e.Position.BottomCenter, target: n.createElement(e.MinimalButton, { ariaLabel: m, testId: "theme__switch-button", onClick: P }, u ? n.createElement(l, null) : n.createElement(t, null)), content: function() {
      return m;
    }, offset: Q });
  }, X = function(B) {
    var P = B.children, S = n.useContext(e.ThemeContext), r = function(m) {
      return n.createElement(G, { onClick: m.onClick });
    }, u = P || r;
    return u({
      onClick: function() {
        return S.setCurrentTheme(S.currentTheme === "dark" ? "light" : "dark");
      }
    });
  }, N = function(B) {
    var P = B.onClick, S = n.useContext(e.ThemeContext), r = n.useContext(e.LocalizationContext).l10n, u = S.currentTheme === "dark", m = r && r.theme ? u ? r.theme.switchLightTheme : r.theme.switchDarkTheme : u ? "Switch to the light theme" : "Switch to the dark theme";
    return n.createElement(e.MenuItem, { icon: u ? n.createElement(l, null) : n.createElement(t, null), testId: "theme__switch-menu", onClick: P }, m);
  }, H = function() {
    var B = function(r) {
      return n.createElement(X, W({}, r));
    }, P = function() {
      return n.createElement(B, null, function(r) {
        return n.createElement(G, W({}, r));
      });
    }, S = function(r) {
      return n.createElement(B, null, function(u) {
        return n.createElement(N, { onClick: function() {
          u.onClick(), r.onClick();
        } });
      });
    };
    return {
      SwitchTheme: B,
      SwitchThemeButton: P,
      SwitchThemeMenuItem: S
    };
  };
  return theme.DarkIcon = t, theme.LightIcon = l, theme.themePlugin = H, theme;
}
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$1.exports;
  hasRequiredLib$3 = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$1.exports = requireTheme_min() : lib$1.exports = requireTheme(), lib$1.exports;
}
var lib = { exports: {} }, zoom_min = {}, hasRequiredZoom_min;
function requireZoom_min() {
  if (hasRequiredZoom_min) return zoom_min;
  hasRequiredZoom_min = 1;
  var e = requireLib$h();
  function L(a) {
    var f = /* @__PURE__ */ Object.create(null);
    return a && Object.keys(a).forEach(function(C) {
      if (C !== "default") {
        var R = Object.getOwnPropertyDescriptor(a, C);
        Object.defineProperty(f, C, R.get ? R : { enumerable: !0, get: function() {
          return a[C];
        } });
      }
    }), f.default = a, Object.freeze(f);
  }
  var p = L(requireReact()), n = function() {
    return p.createElement(e.Icon, { ignoreDirection: !0, size: 16 }, p.createElement("path", { d: `M10.5,0.499c5.523,0,10,4.477,10,10s-4.477,10-10,10s-10-4.477-10-10S4.977,0.499,10.5,0.499z
            M23.5,23.499
            l-5.929-5.929
            M5.5,10.499h10
            M10.5,5.499v10` }));
  }, t = function() {
    return p.createElement(e.Icon, { ignoreDirection: !0, size: 16 }, p.createElement("path", { d: `M10.5,0.499c5.523,0,10,4.477,10,10s-4.477,10-10,10s-10-4.477-10-10S4.977,0.499,10.5,0.499z
            M23.5,23.499
            l-5.929-5.929
            M5.5,10.499h10` }));
  }, l = function() {
    return l = Object.assign || function(a) {
      for (var f, C = 1, R = arguments.length; C < R; C++) for (var M in f = arguments[C]) Object.prototype.hasOwnProperty.call(f, M) && (a[M] = f[M]);
      return a;
    }, l.apply(this, arguments);
  }, W = function(a) {
    var f = p.useState(a.get("scale") || 0), C = f[0], R = f[1], M = function(I) {
      R(I);
    };
    return p.useEffect(function() {
      return a.subscribe("scale", M), function() {
        a.unsubscribe("scale", M);
      };
    }, []), { scale: C };
  }, Q = function(a) {
    var f = a.children, C = a.store;
    return (f || function(R) {
      return p.createElement(p.Fragment, null, "".concat(Math.round(100 * R.scale), "%"));
    })({ scale: W(C).scale });
  }, G = { passive: !1 }, X = null, N = function(a) {
    var f = a.pagesContainerRef, C = a.store, R = e.useDebounceCallback(function(I) {
      var E = C.get("zoom");
      E && E(I);
    }, 40), M = function(I) {
      if (I.ctrlKey) {
        I.preventDefault();
        var E = I.target.getBoundingClientRect(), T = 1 - I.deltaY / 100, y = I.clientX - E.left, D = I.clientY - E.top, j = C.get("scale"), A = (X || (X = document.createElementNS("http://www.w3.org/2000/svg", "svg"))).createSVGMatrix().translate(y, D).scale(T).translate(-y, -D).scale(j);
        R(A.a);
      }
    };
    return e.useIsomorphicLayoutEffect(function() {
      var I = f.current;
      if (I) return I.addEventListener("wheel", M, G), function() {
        I.removeEventListener("wheel", M);
      };
    }, []), p.createElement(p.Fragment, null);
  }, H = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.3, 1.5, 1.7, 1.9, 2.1, 2.4, 2.7, 3, 3.3, 3.7, 4.1, 4.6, 5.1, 5.7, 6.3, 7, 7.7, 8.5, 9.4, 10], B = function(a) {
    return H.find(function(f) {
      return f > a;
    }) || a;
  }, P = function(a) {
    var f = H.findIndex(function(C) {
      return C >= a;
    });
    return f === -1 || f === 0 ? a : H[f - 1];
  }, S = function(a) {
    var f = a.containerRef, C = a.store, R = function(M) {
      if (!M.shiftKey && !M.altKey && (e.isMac() ? M.metaKey : M.ctrlKey)) {
        var I = f.current;
        if (I && document.activeElement && I.contains(document.activeElement)) {
          var E = C.get("zoom");
          if (E) {
            var T = C.get("scale") || 1, y = 1;
            switch (M.key) {
              case "-":
                y = P(T);
                break;
              case "=":
                y = B(T);
                break;
              case "0":
                y = 1;
                break;
              default:
                y = T;
            }
            y !== T && (M.preventDefault(), E(y));
          }
        }
      }
    };
    return p.useEffect(function() {
      if (f.current) return document.addEventListener("keydown", R), function() {
        document.removeEventListener("keydown", R);
      };
    }, [f.current]), p.createElement(p.Fragment, null);
  }, r = [0.5, 0.75, 1, 1.25, 1.5, 2, 3, 4], u = { left: 0, top: 8 }, m = function(a) {
    var f = a.levels, C = f === void 0 ? r : f, R = a.scale, M = a.onZoom, I = p.useContext(e.LocalizationContext).l10n, E = p.useContext(e.ThemeContext).direction === e.TextDirection.RightToLeft, T = I && I.zoom ? I.zoom.zoomDocument : "Zoom document";
    return p.createElement(e.Popover, { ariaControlsSuffix: "zoom", ariaHasPopup: "menu", position: e.Position.BottomCenter, target: function(y) {
      return p.createElement(e.MinimalButton, { ariaLabel: T, testId: "zoom__popover-target", onClick: function() {
        y();
      } }, p.createElement("span", { className: "rpv-zoom__popover-target" }, p.createElement("span", { "data-testid": "zoom__popover-target-scale", className: e.classNames({ "rpv-zoom__popover-target-scale": !0, "rpv-zoom__popover-target-scale--ltr": !E, "rpv-zoom__popover-target-scale--rtl": E }) }, Math.round(100 * R), "%"), p.createElement("span", { className: "rpv-zoom__popover-target-arrow" })));
    }, content: function(y) {
      return p.createElement(e.Menu, null, Object.keys(e.SpecialZoomLevel).map(function(D) {
        var j = D;
        return p.createElement(e.MenuItem, { key: j, onClick: function() {
          y(), M(j);
        } }, function(A) {
          switch (A) {
            case e.SpecialZoomLevel.ActualSize:
              return I && I.zoom ? I.zoom.actualSize : "Actual size";
            case e.SpecialZoomLevel.PageFit:
              return I && I.zoom ? I.zoom.pageFit : "Page fit";
            case e.SpecialZoomLevel.PageWidth:
              return I && I.zoom ? I.zoom.pageWidth : "Page width";
          }
        }(j));
      }), p.createElement(e.MenuDivider, null), C.map(function(D) {
        return p.createElement(e.MenuItem, { key: D, onClick: function() {
          y(), M(D);
        } }, "".concat(Math.round(100 * D), "%"));
      }));
    }, offset: u, closeOnClickOutside: !0, closeOnEscape: !0 });
  }, s = function(a) {
    var f = a.children, C = a.levels, R = a.store;
    return (f || function(M) {
      return p.createElement(m, { levels: C, scale: M.scale, onZoom: M.onZoom });
    })({ scale: W(R).scale, onZoom: function(M) {
      var I = R.get("zoom");
      I && I(M);
    } });
  }, w = { left: 0, top: 8 }, i = function(a) {
    var f = a.enableShortcuts, C = a.onClick, R = p.useContext(e.LocalizationContext).l10n, M = R && R.zoom ? R.zoom.zoomIn : "Zoom in", I = f ? e.isMac() ? "Meta+=" : "Ctrl+=" : "";
    return p.createElement(e.Tooltip, { ariaControlsSuffix: "zoom-in", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaKeyShortcuts: I, ariaLabel: M, testId: "zoom__in-button", onClick: C }, p.createElement(n, null)), content: function() {
      return M;
    }, offset: w });
  }, o = function(a) {
    var f = a.children, C = a.enableShortcuts, R = a.store, M = W(R).scale;
    return (f || i)({ enableShortcuts: C, onClick: function() {
      var I = R.get("zoom");
      I && I(B(M));
    } });
  }, b = function(a) {
    var f = a.onClick, C = p.useContext(e.LocalizationContext).l10n, R = C && C.zoom ? C.zoom.zoomIn : "Zoom in";
    return p.createElement(e.MenuItem, { icon: p.createElement(n, null), testId: "zoom__in-menu", onClick: f }, R);
  }, g = { left: 0, top: 8 }, c = function(a) {
    var f = a.enableShortcuts, C = a.onClick, R = p.useContext(e.LocalizationContext).l10n, M = R && R.zoom ? R.zoom.zoomOut : "Zoom out", I = f ? e.isMac() ? "Meta+-" : "Ctrl+-" : "";
    return p.createElement(e.Tooltip, { ariaControlsSuffix: "zoom-out", position: e.Position.BottomCenter, target: p.createElement(e.MinimalButton, { ariaKeyShortcuts: I, ariaLabel: M, testId: "zoom__out-button", onClick: C }, p.createElement(t, null)), content: function() {
      return M;
    }, offset: g });
  }, v = function(a) {
    var f = a.children, C = a.enableShortcuts, R = a.store, M = W(R).scale;
    return (f || c)({ enableShortcuts: C, onClick: function() {
      var I = R.get("zoom");
      I && I(P(M));
    } });
  }, k = function(a) {
    var f = a.onClick, C = p.useContext(e.LocalizationContext).l10n, R = C && C.zoom ? C.zoom.zoomOut : "Zoom out";
    return p.createElement(e.MenuItem, { icon: p.createElement(t, null), testId: "zoom__out-menu", onClick: f }, R);
  };
  return zoom_min.ZoomInIcon = n, zoom_min.ZoomOutIcon = t, zoom_min.zoomPlugin = function(a) {
    var f = p.useMemo(function() {
      return Object.assign({}, { enableShortcuts: !0 }, a);
    }, []), C = p.useMemo(function() {
      return e.createStore({});
    }, []), R = function(E) {
      return p.createElement(o, l({ enableShortcuts: f.enableShortcuts }, E, { store: C }));
    }, M = function(E) {
      return p.createElement(v, l({ enableShortcuts: f.enableShortcuts }, E, { store: C }));
    }, I = function(E) {
      return p.createElement(s, l({}, E, { store: C }));
    };
    return { renderViewer: function(E) {
      var T = E.slot;
      if (!f.enableShortcuts) return T;
      var y = { children: p.createElement(p.Fragment, null, p.createElement(S, { containerRef: E.containerRef, store: C }), p.createElement(N, { pagesContainerRef: E.pagesContainerRef, store: C }), T.children) };
      return l(l({}, T), y);
    }, install: function(E) {
      C.update("zoom", E.zoom);
    }, onViewerStateChange: function(E) {
      return C.update("scale", E.scale), E;
    }, zoomTo: function(E) {
      var T = C.get("zoom");
      T && T(E);
    }, CurrentScale: function(E) {
      return p.createElement(Q, l({}, E, { store: C }));
    }, ZoomIn: R, ZoomInButton: function() {
      return p.createElement(R, null, function(E) {
        return p.createElement(i, l({}, E));
      });
    }, ZoomInMenuItem: function(E) {
      return p.createElement(R, null, function(T) {
        return p.createElement(b, { onClick: function() {
          T.onClick(), E.onClick();
        } });
      });
    }, ZoomOut: M, ZoomOutButton: function() {
      return p.createElement(M, null, function(E) {
        return p.createElement(c, l({}, E));
      });
    }, ZoomOutMenuItem: function(E) {
      return p.createElement(M, null, function(T) {
        return p.createElement(k, { onClick: function() {
          T.onClick(), E.onClick();
        } });
      });
    }, Zoom: I, ZoomPopover: function(E) {
      return p.createElement(I, null, function(T) {
        return p.createElement(m, l({ levels: E == null ? void 0 : E.levels }, T));
      });
    } };
  }, zoom_min;
}
var zoom = {}, hasRequiredZoom;
function requireZoom() {
  if (hasRequiredZoom) return zoom;
  hasRequiredZoom = 1;
  var e = requireLib$h(), L = requireReact();
  function p(R) {
    var M = /* @__PURE__ */ Object.create(null);
    return R && Object.keys(R).forEach(function(I) {
      if (I !== "default") {
        var E = Object.getOwnPropertyDescriptor(R, I);
        Object.defineProperty(M, I, E.get ? E : {
          enumerable: !0,
          get: function() {
            return R[I];
          }
        });
      }
    }), M.default = R, Object.freeze(M);
  }
  var n = /* @__PURE__ */ p(L), t = function() {
    return n.createElement(
      e.Icon,
      { ignoreDirection: !0, size: 16 },
      n.createElement("path", { d: `M10.5,0.499c5.523,0,10,4.477,10,10s-4.477,10-10,10s-10-4.477-10-10S4.977,0.499,10.5,0.499z
            M23.5,23.499
            l-5.929-5.929
            M5.5,10.499h10
            M10.5,5.499v10` })
    );
  }, l = function() {
    return n.createElement(
      e.Icon,
      { ignoreDirection: !0, size: 16 },
      n.createElement("path", { d: `M10.5,0.499c5.523,0,10,4.477,10,10s-4.477,10-10,10s-10-4.477-10-10S4.977,0.499,10.5,0.499z
            M23.5,23.499
            l-5.929-5.929
            M5.5,10.499h10` })
    );
  }, W = function() {
    return W = Object.assign || function(M) {
      for (var I, E = 1, T = arguments.length; E < T; E++) {
        I = arguments[E];
        for (var y in I) Object.prototype.hasOwnProperty.call(I, y) && (M[y] = I[y]);
      }
      return M;
    }, W.apply(this, arguments);
  }, Q = function(R) {
    var M = n.useState(R.get("scale") || 0), I = M[0], E = M[1], T = function(y) {
      E(y);
    };
    return n.useEffect(function() {
      return R.subscribe("scale", T), function() {
        R.unsubscribe("scale", T);
      };
    }, []), { scale: I };
  }, G = function(R) {
    var M = R.children, I = R.store, E = Q(I).scale, T = function(D) {
      return n.createElement(n.Fragment, null, "".concat(Math.round(D.scale * 100), "%"));
    }, y = M || T;
    return y({ scale: E });
  }, X = {
    passive: !1
  }, N = null, H = function() {
    return N || (N = document.createElementNS("http://www.w3.org/2000/svg", "svg"));
  }, B = function(R) {
    var M = R.pagesContainerRef, I = R.store, E = e.useDebounceCallback(function(y) {
      var D = I.get("zoom");
      D && D(y);
    }, 40), T = function(y) {
      if (y.ctrlKey) {
        y.preventDefault();
        var D = y.target, j = D.getBoundingClientRect(), A = 1 - y.deltaY / 100, d = y.clientX - j.left, _ = y.clientY - j.top, F = I.get("scale"), U = H().createSVGMatrix().translate(d, _).scale(A).translate(-d, -_).scale(F);
        E(U.a);
      }
    };
    return e.useIsomorphicLayoutEffect(function() {
      var y = M.current;
      if (y)
        return y.addEventListener("wheel", T, X), function() {
          y.removeEventListener("wheel", T);
        };
    }, []), n.createElement(n.Fragment, null);
  }, P = [
    0.1,
    0.2,
    0.3,
    0.4,
    0.5,
    0.6,
    0.7,
    0.8,
    0.9,
    1,
    1.1,
    1.3,
    1.5,
    1.7,
    1.9,
    2.1,
    2.4,
    2.7,
    3,
    3.3,
    3.7,
    4.1,
    4.6,
    5.1,
    5.7,
    6.3,
    7,
    7.7,
    8.5,
    9.4,
    10
  ], S = function(R) {
    var M = P.find(function(I) {
      return I > R;
    });
    return M || R;
  }, r = function(R) {
    var M = P.findIndex(function(I) {
      return I >= R;
    });
    return M === -1 || M === 0 ? R : P[M - 1];
  }, u = function(R) {
    var M = R.containerRef, I = R.store, E = function(T) {
      if (!(T.shiftKey || T.altKey)) {
        var y = e.isMac() ? T.metaKey : T.ctrlKey;
        if (y) {
          var D = M.current;
          if (!(!D || !document.activeElement || !D.contains(document.activeElement))) {
            var j = I.get("zoom");
            if (j) {
              var A = I.get("scale") || 1, d = 1;
              switch (T.key) {
                case "-":
                  d = r(A);
                  break;
                case "=":
                  d = S(A);
                  break;
                case "0":
                  d = 1;
                  break;
                default:
                  d = A;
                  break;
              }
              d !== A && (T.preventDefault(), j(d));
            }
          }
        }
      }
    };
    return n.useEffect(function() {
      var T = M.current;
      if (T)
        return document.addEventListener("keydown", E), function() {
          document.removeEventListener("keydown", E);
        };
    }, [M.current]), n.createElement(n.Fragment, null);
  }, m = [0.5, 0.75, 1, 1.25, 1.5, 2, 3, 4], s = { left: 0, top: 8 }, w = function(R) {
    var M = R.levels, I = M === void 0 ? m : M, E = R.scale, T = R.onZoom, y = n.useContext(e.LocalizationContext).l10n, D = n.useContext(e.ThemeContext).direction, j = D === e.TextDirection.RightToLeft, A = function(U) {
      switch (U) {
        case e.SpecialZoomLevel.ActualSize:
          return y && y.zoom ? y.zoom.actualSize : "Actual size";
        case e.SpecialZoomLevel.PageFit:
          return y && y.zoom ? y.zoom.pageFit : "Page fit";
        case e.SpecialZoomLevel.PageWidth:
          return y && y.zoom ? y.zoom.pageWidth : "Page width";
      }
    }, d = y && y.zoom ? y.zoom.zoomDocument : "Zoom document", _ = function(U) {
      var V = function() {
        U();
      };
      return n.createElement(
        e.MinimalButton,
        { ariaLabel: d, testId: "zoom__popover-target", onClick: V },
        n.createElement(
          "span",
          { className: "rpv-zoom__popover-target" },
          n.createElement(
            "span",
            { "data-testid": "zoom__popover-target-scale", className: e.classNames({
              "rpv-zoom__popover-target-scale": !0,
              "rpv-zoom__popover-target-scale--ltr": !j,
              "rpv-zoom__popover-target-scale--rtl": j
            }) },
            Math.round(E * 100),
            "%"
          ),
          n.createElement("span", { className: "rpv-zoom__popover-target-arrow" })
        )
      );
    }, F = function(U) {
      return n.createElement(
        e.Menu,
        null,
        Object.keys(e.SpecialZoomLevel).map(function(V) {
          var $ = V, re = function() {
            U(), T($);
          };
          return n.createElement(e.MenuItem, { key: $, onClick: re }, A($));
        }),
        n.createElement(e.MenuDivider, null),
        I.map(function(V) {
          var $ = function() {
            U(), T(V);
          };
          return n.createElement(e.MenuItem, { key: V, onClick: $ }, "".concat(Math.round(V * 100), "%"));
        })
      );
    };
    return n.createElement(e.Popover, { ariaControlsSuffix: "zoom", ariaHasPopup: "menu", position: e.Position.BottomCenter, target: _, content: F, offset: s, closeOnClickOutside: !0, closeOnEscape: !0 });
  }, i = function(R) {
    var M = R.children, I = R.levels, E = R.store, T = Q(E).scale, y = function(A) {
      var d = E.get("zoom");
      d && d(A);
    }, D = function(A) {
      return n.createElement(w, { levels: I, scale: A.scale, onZoom: A.onZoom });
    }, j = M || D;
    return j({
      scale: T,
      onZoom: y
    });
  }, o = { left: 0, top: 8 }, b = function(R) {
    var M = R.enableShortcuts, I = R.onClick, E = n.useContext(e.LocalizationContext).l10n, T = E && E.zoom ? E.zoom.zoomIn : "Zoom in", y = M ? e.isMac() ? "Meta+=" : "Ctrl+=" : "";
    return n.createElement(e.Tooltip, { ariaControlsSuffix: "zoom-in", position: e.Position.BottomCenter, target: n.createElement(
      e.MinimalButton,
      { ariaKeyShortcuts: y, ariaLabel: T, testId: "zoom__in-button", onClick: I },
      n.createElement(t, null)
    ), content: function() {
      return T;
    }, offset: o });
  }, g = function(R) {
    var M = R.children, I = R.enableShortcuts, E = R.store, T = Q(E).scale, y = function() {
      var j = E.get("zoom");
      if (j) {
        var A = S(T);
        j(A);
      }
    }, D = M || b;
    return D({
      enableShortcuts: I,
      onClick: y
    });
  }, c = function(R) {
    var M = R.onClick, I = n.useContext(e.LocalizationContext).l10n, E = I && I.zoom ? I.zoom.zoomIn : "Zoom in";
    return n.createElement(e.MenuItem, { icon: n.createElement(t, null), testId: "zoom__in-menu", onClick: M }, E);
  }, v = { left: 0, top: 8 }, k = function(R) {
    var M = R.enableShortcuts, I = R.onClick, E = n.useContext(e.LocalizationContext).l10n, T = E && E.zoom ? E.zoom.zoomOut : "Zoom out", y = M ? e.isMac() ? "Meta+-" : "Ctrl+-" : "";
    return n.createElement(e.Tooltip, { ariaControlsSuffix: "zoom-out", position: e.Position.BottomCenter, target: n.createElement(
      e.MinimalButton,
      { ariaKeyShortcuts: y, ariaLabel: T, testId: "zoom__out-button", onClick: I },
      n.createElement(l, null)
    ), content: function() {
      return T;
    }, offset: v });
  }, a = function(R) {
    var M = R.children, I = R.enableShortcuts, E = R.store, T = Q(E).scale, y = function() {
      var j = E.get("zoom");
      if (j) {
        var A = r(T);
        j(A);
      }
    }, D = M || k;
    return D({
      enableShortcuts: I,
      onClick: y
    });
  }, f = function(R) {
    var M = R.onClick, I = n.useContext(e.LocalizationContext).l10n, E = I && I.zoom ? I.zoom.zoomOut : "Zoom out";
    return n.createElement(e.MenuItem, { icon: n.createElement(l, null), testId: "zoom__out-menu", onClick: M }, E);
  }, C = function(R) {
    var M = n.useMemo(function() {
      return Object.assign({}, { enableShortcuts: !0 }, R);
    }, []), I = n.useMemo(function() {
      return e.createStore({});
    }, []), E = function(V) {
      return n.createElement(G, W({}, V, { store: I }));
    }, T = function(V) {
      return n.createElement(g, W({ enableShortcuts: M.enableShortcuts }, V, { store: I }));
    }, y = function() {
      return n.createElement(T, null, function(V) {
        return n.createElement(b, W({}, V));
      });
    }, D = function(V) {
      return n.createElement(T, null, function($) {
        return n.createElement(c, { onClick: function() {
          $.onClick(), V.onClick();
        } });
      });
    }, j = function(V) {
      return n.createElement(a, W({ enableShortcuts: M.enableShortcuts }, V, { store: I }));
    }, A = function() {
      return n.createElement(j, null, function(V) {
        return n.createElement(k, W({}, V));
      });
    }, d = function(V) {
      return n.createElement(j, null, function($) {
        return n.createElement(f, { onClick: function() {
          $.onClick(), V.onClick();
        } });
      });
    }, _ = function(V) {
      return n.createElement(i, W({}, V, { store: I }));
    }, F = function(V) {
      return n.createElement(_, null, function($) {
        return n.createElement(w, W({ levels: V == null ? void 0 : V.levels }, $));
      });
    }, U = function(V) {
      var $ = V.slot;
      if (!M.enableShortcuts)
        return $;
      var re = {
        children: n.createElement(
          n.Fragment,
          null,
          n.createElement(u, { containerRef: V.containerRef, store: I }),
          n.createElement(B, { pagesContainerRef: V.pagesContainerRef, store: I }),
          $.children
        )
      };
      return W(W({}, $), re);
    };
    return {
      renderViewer: U,
      install: function(V) {
        I.update("zoom", V.zoom);
      },
      onViewerStateChange: function(V) {
        return I.update("scale", V.scale), V;
      },
      zoomTo: function(V) {
        var $ = I.get("zoom");
        $ && $(V);
      },
      CurrentScale: E,
      ZoomIn: T,
      ZoomInButton: y,
      ZoomInMenuItem: D,
      ZoomOut: j,
      ZoomOutButton: A,
      ZoomOutMenuItem: d,
      Zoom: _,
      ZoomPopover: F
    };
  };
  return zoom.ZoomInIcon = t, zoom.ZoomOutIcon = l, zoom.zoomPlugin = C, zoom;
}
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib.exports;
  hasRequiredLib$2 = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib.exports = requireZoom_min() : lib.exports = requireZoom(), lib.exports;
}
var hasRequiredToolbar_min;
function requireToolbar_min() {
  if (hasRequiredToolbar_min) return toolbar_min;
  hasRequiredToolbar_min = 1;
  var e = requireLib$h(), L = requireLib$d(), p = requireReact(), n = requireLib$c(), t = requireLib$b(), l = requireLib$a(), W = requireLib$9(), Q = requireLib$8(), G = requireLib$7(), X = requireLib$6(), N = requireLib$5(), H = requireLib$4(), B = requireLib$3(), P = requireLib$2();
  function S(c) {
    var v = /* @__PURE__ */ Object.create(null);
    return c && Object.keys(c).forEach(function(k) {
      if (k !== "default") {
        var a = Object.getOwnPropertyDescriptor(c, k);
        Object.defineProperty(v, k, a.get ? a : { enumerable: !0, get: function() {
          return c[k];
        } });
      }
    }), v.default = c, Object.freeze(v);
  }
  var r = S(p), u = function() {
    return r.createElement(e.Icon, { size: 16 }, r.createElement("path", { d: `M12,0.5c1.381,0,2.5,1.119,2.5,2.5S13.381,5.5,12,5.5S9.5,4.381,9.5,3S10.619,0.5,12,0.5z
            M12,9.5
            c1.381,0,2.5,1.119,2.5,2.5s-1.119,2.5-2.5,2.5S9.5,13.381,9.5,12S10.619,9.5,12,9.5z
            M12,18.5c1.381,0,2.5,1.119,2.5,2.5
            s-1.119,2.5-2.5,2.5S9.5,22.381,9.5,21S10.619,18.5,12,18.5z` }));
  }, m = { left: 0, top: 8 }, s = function(c) {
    var v = c.toolbarSlot, k = r.useContext(e.LocalizationContext).l10n, a = r.useContext(e.ThemeContext).direction === e.TextDirection.RightToLeft ? e.Position.BottomLeft : e.Position.BottomRight, f = v.DownloadMenuItem, C = v.EnterFullScreenMenuItem, R = v.GoToFirstPageMenuItem, M = v.GoToLastPageMenuItem, I = v.GoToNextPageMenuItem, E = v.GoToPreviousPageMenuItem, T = v.OpenMenuItem, y = v.PrintMenuItem, D = v.RotateBackwardMenuItem, j = v.RotateForwardMenuItem, A = v.ShowPropertiesMenuItem, d = v.SwitchScrollModeMenuItem, _ = v.SwitchSelectionModeMenuItem, F = v.SwitchViewModeMenuItem, U = v.SwitchThemeMenuItem;
    return r.createElement(e.Popover, { ariaControlsSuffix: "toolbar-more-actions", ariaHasPopup: "menu", position: a, target: function(V, $) {
      var re = k && k.toolbar ? k.toolbar.moreActions : "More actions";
      return r.createElement(e.Tooltip, { ariaControlsSuffix: "toolbar-more-actions", position: a, target: r.createElement(e.MinimalButton, { ariaLabel: re, isSelected: $, testId: "toolbar__more-actions-popover-target", onClick: V }, r.createElement(u, null)), content: function() {
        return re;
      }, offset: m });
    }, content: function(V) {
      return r.createElement(e.Menu, null, r.createElement("div", { className: "rpv-core__display--block rpv-core__display--hidden-medium" }, r.createElement(U, { onClick: V })), r.createElement("div", { className: "rpv-core__display--block rpv-core__display--hidden-medium" }, r.createElement(C, { onClick: V })), r.createElement("div", { className: "rpv-core__display--block rpv-core__display--hidden-medium" }, r.createElement(T, null)), r.createElement("div", { className: "rpv-core__display--block rpv-core__display--hidden-medium" }, r.createElement(y, { onClick: V })), r.createElement("div", { className: "rpv-core__display--block rpv-core__display--hidden-medium" }, r.createElement(f, { onClick: V })), r.createElement("div", { className: "rpv-core__display--block rpv-core__display--hidden-medium" }, r.createElement(e.MenuDivider, null)), r.createElement(R, { onClick: V }), r.createElement("div", { className: "rpv-core__display--block rpv-core__display--hidden-medium" }, r.createElement(E, { onClick: V })), r.createElement("div", { className: "rpv-core__display--block rpv-core__display--hidden-medium" }, r.createElement(I, { onClick: V })), r.createElement(M, { onClick: V }), r.createElement(e.MenuDivider, null), r.createElement(j, { onClick: V }), r.createElement(D, { onClick: V }), r.createElement(e.MenuDivider, null), r.createElement(_, { mode: L.SelectionMode.Text, onClick: V }), r.createElement(_, { mode: L.SelectionMode.Hand, onClick: V }), r.createElement(e.MenuDivider, null), r.createElement(d, { mode: e.ScrollMode.Page, onClick: V }), r.createElement(d, { mode: e.ScrollMode.Vertical, onClick: V }), r.createElement(d, { mode: e.ScrollMode.Horizontal, onClick: V }), r.createElement(d, { mode: e.ScrollMode.Wrapped, onClick: V }), r.createElement(e.MenuDivider, null), r.createElement("div", { className: "rpv-core__display--hidden rpv-core__display--block-small" }, r.createElement(F, { mode: e.ViewMode.SinglePage, onClick: V })), r.createElement("div", { className: "rpv-core__display--hidden rpv-core__display--block-small" }, r.createElement(F, { mode: e.ViewMode.DualPage, onClick: V })), r.createElement("div", { className: "rpv-core__display--hidden rpv-core__display--block-small" }, r.createElement(F, { mode: e.ViewMode.DualPageWithCover, onClick: V })), r.createElement("div", { className: "rpv-core__display--hidden rpv-core__display--block-small" }, r.createElement(e.MenuDivider, null)), r.createElement(A, { onClick: V }));
    }, offset: m, closeOnClickOutside: !0, closeOnEscape: !0 });
  }, w = function() {
    return w = Object.assign || function(c) {
      for (var v, k = 1, a = arguments.length; k < a; k++) for (var f in v = arguments[k]) Object.prototype.hasOwnProperty.call(v, f) && (c[f] = v[f]);
      return c;
    }, w.apply(this, arguments);
  }, i = function(c) {
    return function(v) {
      var k = r.useMemo(function() {
        return c(v);
      }, []), a = r.useContext(e.ThemeContext).direction === e.TextDirection.RightToLeft, f = k.CurrentPageInput, C = k.Download, R = k.EnterFullScreen, M = k.GoToNextPage, I = k.GoToPreviousPage, E = k.NumberOfPages, T = k.Open, y = k.Print, D = k.ShowSearchPopover, j = k.SwitchTheme, A = k.Zoom, d = k.ZoomIn, _ = k.ZoomOut;
      return r.createElement("div", { "data-testid": "toolbar", className: e.classNames({ "rpv-toolbar": !0, "rpv-toolbar--rtl": a }), role: "toolbar", "aria-orientation": "horizontal" }, r.createElement("div", { className: "rpv-toolbar__left" }, r.createElement("div", { className: "rpv-toolbar__item" }, r.createElement(D, null)), r.createElement("div", { className: "rpv-core__display--hidden rpv-core__display--block-small" }, r.createElement("div", { className: "rpv-toolbar__item" }, r.createElement(I, null))), r.createElement("div", { className: "rpv-toolbar__item" }, r.createElement(f, null), r.createElement("span", { className: "rpv-toolbar__label" }, r.createElement(E, null))), r.createElement("div", { className: "rpv-core__display--hidden rpv-core__display--block-small" }, r.createElement("div", { className: "rpv-toolbar__item" }, r.createElement(M, null)))), r.createElement("div", { className: "rpv-toolbar__center" }, r.createElement("div", { className: "rpv-toolbar__item" }, r.createElement(_, null)), r.createElement("div", { className: "rpv-core__display--hidden rpv-core__display--block-small" }, r.createElement("div", { className: "rpv-toolbar__item" }, r.createElement(A, null))), r.createElement("div", { className: "rpv-toolbar__item" }, r.createElement(d, null))), r.createElement("div", { className: "rpv-toolbar__right" }, r.createElement("div", { className: "rpv-core__display--hidden rpv-core__display--block-medium" }, r.createElement("div", { className: "rpv-toolbar__item" }, r.createElement(j, null))), r.createElement("div", { className: "rpv-core__display--hidden rpv-core__display--block-medium" }, r.createElement("div", { className: "rpv-toolbar__item" }, r.createElement(R, null))), r.createElement("div", { className: "rpv-core__display--hidden rpv-core__display--block-medium" }, r.createElement("div", { className: "rpv-toolbar__item" }, r.createElement(T, null))), r.createElement("div", { className: "rpv-core__display--hidden rpv-core__display--block-medium" }, r.createElement("div", { className: "rpv-toolbar__item" }, r.createElement(C, null))), r.createElement("div", { className: "rpv-core__display--hidden rpv-core__display--block-medium" }, r.createElement("div", { className: "rpv-toolbar__item" }, r.createElement(y, null))), r.createElement("div", { className: "rpv-toolbar__item" }, r.createElement(s, { toolbarSlot: k }))));
    };
  }, o = function(c) {
    var v = c.NumberOfPages;
    return Object.assign({}, c, { NumberOfPages: function() {
      return r.createElement(r.Fragment, null, "/ ", r.createElement(v, null));
    } });
  }, b = function(c) {
    return i(o)(c);
  }, g = function(c) {
    var v = c.children, k = c.slot;
    return (v || b)(k);
  };
  return toolbar_min.MoreActionsPopover = s, toolbar_min.MoreIcon = u, toolbar_min.toolbarPlugin = function(c) {
    var v = n.fullScreenPlugin(c ? c.fullScreenPlugin : {}), k = t.getFilePlugin(c ? c.getFilePlugin : {}), a = l.openPlugin(c ? c.openPlugin : {}), f = W.pageNavigationPlugin(c ? c.pageNavigationPlugin : {}), C = Q.printPlugin(c ? c.printPlugin : {}), R = G.propertiesPlugin(), M = X.rotatePlugin(), I = N.scrollModePlugin(), E = H.searchPlugin(c ? c.searchPlugin : {}), T = L.selectionModePlugin(c ? c.selectionModePlugin : {}), y = B.themePlugin(), D = P.zoomPlugin(c ? c.zoomPlugin : {}), j = [v, k, a, f, C, R, M, I, E, T, y, D], A = r.useCallback(function(d) {
      var _ = v.EnterFullScreen, F = v.EnterFullScreenMenuItem, U = k.Download, V = k.DownloadMenuItem, $ = a.Open, re = a.OpenMenuItem, ge = f.CurrentPageInput, be = f.CurrentPageLabel, le = f.GoToFirstPage, fe = f.GoToFirstPageMenuItem, Ae = f.GoToLastPage, qe = f.GoToLastPageMenuItem, ye = f.GoToNextPage, ce = f.GoToNextPageMenuItem, q = f.GoToPreviousPage, Z = f.GoToPreviousPageMenuItem, pe = f.NumberOfPages, me = C.Print, _e = C.PrintMenuItem, Be = R.ShowProperties, ke = R.ShowPropertiesMenuItem, de = M.Rotate, $e = M.RotateBackwardMenuItem, Ge = M.RotateForwardMenuItem, st = I.SwitchScrollMode, it = I.SwitchScrollModeMenuItem, _t = I.SwitchViewMode, tt = I.SwitchViewModeMenuItem, Xe = E.Search, ct = E.ShowSearchPopover, xt = T.SwitchSelectionMode, We = T.SwitchSelectionModeMenuItem, Ce = y.SwitchTheme, Re = y.SwitchThemeMenuItem, lt = D.CurrentScale, bt = D.Zoom, Et = D.ZoomIn, oe = D.ZoomInMenuItem, He = D.ZoomOut, at = D.ZoomOutMenuItem;
      return r.createElement(g, w({}, d, { slot: { CurrentPageInput: ge, CurrentPageLabel: be, CurrentScale: lt, Download: U, DownloadMenuItem: V, EnterFullScreen: _, EnterFullScreenMenuItem: F, GoToFirstPage: le, GoToFirstPageMenuItem: fe, GoToLastPage: Ae, GoToLastPageMenuItem: qe, GoToNextPage: ye, GoToNextPageMenuItem: ce, GoToPreviousPage: q, GoToPreviousPageMenuItem: Z, NumberOfPages: pe, Open: $, OpenMenuItem: re, Print: me, PrintMenuItem: _e, Rotate: de, RotateBackwardMenuItem: $e, RotateForwardMenuItem: Ge, Search: Xe, ShowProperties: Be, ShowPropertiesMenuItem: ke, ShowSearchPopover: ct, SwitchScrollMode: st, SwitchScrollModeMenuItem: it, SwitchSelectionMode: xt, SwitchSelectionModeMenuItem: We, SwitchViewMode: _t, SwitchViewModeMenuItem: tt, SwitchTheme: Ce, SwitchThemeMenuItem: Re, Zoom: bt, ZoomIn: Et, ZoomInMenuItem: oe, ZoomOut: He, ZoomOutMenuItem: at } }));
    }, []);
    return { fullScreenPluginInstance: v, getFilePluginInstance: k, openPluginInstance: a, pageNavigationPluginInstance: f, printPluginInstance: C, propertiesPluginInstance: R, rotatePluginInstance: M, scrollModePluginInstance: I, searchPluginInstance: E, selectionModePluginInstance: T, themePluginInstance: y, zoomPluginInstance: D, install: function(d) {
      j.forEach(function(_) {
        _.install && _.install(d);
      });
    }, renderPageLayer: function(d) {
      return r.createElement(r.Fragment, null, j.map(function(_, F) {
        return _.renderPageLayer ? r.createElement(r.Fragment, { key: F }, _.renderPageLayer(d)) : r.createElement(r.Fragment, { key: F });
      }));
    }, renderViewer: function(d) {
      var _ = d.slot;
      return j.forEach(function(F) {
        F.renderViewer && (_ = F.renderViewer(w(w({}, d), { slot: _ })));
      }), _;
    }, uninstall: function(d) {
      j.forEach(function(_) {
        _.uninstall && _.uninstall(d);
      });
    }, onDocumentLoad: function(d) {
      j.forEach(function(_) {
        _.onDocumentLoad && _.onDocumentLoad(d);
      });
    }, onAnnotationLayerRender: function(d) {
      j.forEach(function(_) {
        _.onAnnotationLayerRender && _.onAnnotationLayerRender(d);
      });
    }, onTextLayerRender: function(d) {
      j.forEach(function(_) {
        _.onTextLayerRender && _.onTextLayerRender(d);
      });
    }, onViewerStateChange: function(d) {
      var _ = d;
      return j.forEach(function(F) {
        F.onViewerStateChange && (_ = F.onViewerStateChange(_));
      }), _;
    }, renderDefaultToolbar: i, Toolbar: A };
  }, toolbar_min;
}
var toolbar = {}, hasRequiredToolbar;
function requireToolbar() {
  if (hasRequiredToolbar) return toolbar;
  hasRequiredToolbar = 1;
  var e = requireLib$h(), L = requireLib$d(), p = requireReact(), n = requireLib$c(), t = requireLib$b(), l = requireLib$a(), W = requireLib$9(), Q = requireLib$8(), G = requireLib$7(), X = requireLib$6(), N = requireLib$5(), H = requireLib$4(), B = requireLib$3(), P = requireLib$2();
  function S(v) {
    var k = /* @__PURE__ */ Object.create(null);
    return v && Object.keys(v).forEach(function(a) {
      if (a !== "default") {
        var f = Object.getOwnPropertyDescriptor(v, a);
        Object.defineProperty(k, a, f.get ? f : {
          enumerable: !0,
          get: function() {
            return v[a];
          }
        });
      }
    }), k.default = v, Object.freeze(k);
  }
  var r = /* @__PURE__ */ S(p), u = function() {
    return r.createElement(
      e.Icon,
      { size: 16 },
      r.createElement("path", { d: `M12,0.5c1.381,0,2.5,1.119,2.5,2.5S13.381,5.5,12,5.5S9.5,4.381,9.5,3S10.619,0.5,12,0.5z
            M12,9.5
            c1.381,0,2.5,1.119,2.5,2.5s-1.119,2.5-2.5,2.5S9.5,13.381,9.5,12S10.619,9.5,12,9.5z
            M12,18.5c1.381,0,2.5,1.119,2.5,2.5
            s-1.119,2.5-2.5,2.5S9.5,22.381,9.5,21S10.619,18.5,12,18.5z` })
    );
  }, m = { left: 0, top: 8 }, s = function(v) {
    var k = v.toolbarSlot, a = r.useContext(e.LocalizationContext).l10n, f = r.useContext(e.ThemeContext).direction, C = f === e.TextDirection.RightToLeft ? e.Position.BottomLeft : e.Position.BottomRight, R = k.DownloadMenuItem, M = k.EnterFullScreenMenuItem, I = k.GoToFirstPageMenuItem, E = k.GoToLastPageMenuItem, T = k.GoToNextPageMenuItem, y = k.GoToPreviousPageMenuItem, D = k.OpenMenuItem, j = k.PrintMenuItem, A = k.RotateBackwardMenuItem, d = k.RotateForwardMenuItem, _ = k.ShowPropertiesMenuItem, F = k.SwitchScrollModeMenuItem, U = k.SwitchSelectionModeMenuItem, V = k.SwitchViewModeMenuItem, $ = k.SwitchThemeMenuItem, re = function(be, le) {
      var fe = a && a.toolbar ? a.toolbar.moreActions : "More actions";
      return r.createElement(e.Tooltip, { ariaControlsSuffix: "toolbar-more-actions", position: C, target: r.createElement(
        e.MinimalButton,
        { ariaLabel: fe, isSelected: le, testId: "toolbar__more-actions-popover-target", onClick: be },
        r.createElement(u, null)
      ), content: function() {
        return fe;
      }, offset: m });
    }, ge = function(be) {
      return r.createElement(
        e.Menu,
        null,
        r.createElement(
          "div",
          { className: "rpv-core__display--block rpv-core__display--hidden-medium" },
          r.createElement($, { onClick: be })
        ),
        r.createElement(
          "div",
          { className: "rpv-core__display--block rpv-core__display--hidden-medium" },
          r.createElement(M, { onClick: be })
        ),
        r.createElement(
          "div",
          { className: "rpv-core__display--block rpv-core__display--hidden-medium" },
          r.createElement(D, null)
        ),
        r.createElement(
          "div",
          { className: "rpv-core__display--block rpv-core__display--hidden-medium" },
          r.createElement(j, { onClick: be })
        ),
        r.createElement(
          "div",
          { className: "rpv-core__display--block rpv-core__display--hidden-medium" },
          r.createElement(R, { onClick: be })
        ),
        r.createElement(
          "div",
          { className: "rpv-core__display--block rpv-core__display--hidden-medium" },
          r.createElement(e.MenuDivider, null)
        ),
        r.createElement(I, { onClick: be }),
        r.createElement(
          "div",
          { className: "rpv-core__display--block rpv-core__display--hidden-medium" },
          r.createElement(y, { onClick: be })
        ),
        r.createElement(
          "div",
          { className: "rpv-core__display--block rpv-core__display--hidden-medium" },
          r.createElement(T, { onClick: be })
        ),
        r.createElement(E, { onClick: be }),
        r.createElement(e.MenuDivider, null),
        r.createElement(d, { onClick: be }),
        r.createElement(A, { onClick: be }),
        r.createElement(e.MenuDivider, null),
        r.createElement(U, { mode: L.SelectionMode.Text, onClick: be }),
        r.createElement(U, { mode: L.SelectionMode.Hand, onClick: be }),
        r.createElement(e.MenuDivider, null),
        r.createElement(F, { mode: e.ScrollMode.Page, onClick: be }),
        r.createElement(F, { mode: e.ScrollMode.Vertical, onClick: be }),
        r.createElement(F, { mode: e.ScrollMode.Horizontal, onClick: be }),
        r.createElement(F, { mode: e.ScrollMode.Wrapped, onClick: be }),
        r.createElement(e.MenuDivider, null),
        r.createElement(
          "div",
          { className: "rpv-core__display--hidden rpv-core__display--block-small" },
          r.createElement(V, { mode: e.ViewMode.SinglePage, onClick: be })
        ),
        r.createElement(
          "div",
          { className: "rpv-core__display--hidden rpv-core__display--block-small" },
          r.createElement(V, { mode: e.ViewMode.DualPage, onClick: be })
        ),
        r.createElement(
          "div",
          { className: "rpv-core__display--hidden rpv-core__display--block-small" },
          r.createElement(V, { mode: e.ViewMode.DualPageWithCover, onClick: be })
        ),
        r.createElement(
          "div",
          { className: "rpv-core__display--hidden rpv-core__display--block-small" },
          r.createElement(e.MenuDivider, null)
        ),
        r.createElement(_, { onClick: be })
      );
    };
    return r.createElement(e.Popover, { ariaControlsSuffix: "toolbar-more-actions", ariaHasPopup: "menu", position: C, target: re, content: ge, offset: m, closeOnClickOutside: !0, closeOnEscape: !0 });
  }, w = function() {
    return w = Object.assign || function(k) {
      for (var a, f = 1, C = arguments.length; f < C; f++) {
        a = arguments[f];
        for (var R in a) Object.prototype.hasOwnProperty.call(a, R) && (k[R] = a[R]);
      }
      return k;
    }, w.apply(this, arguments);
  }, i = function(v) {
    return function(k) {
      var a = r.useMemo(function() {
        return v(k);
      }, []), f = r.useContext(e.ThemeContext).direction, C = f === e.TextDirection.RightToLeft, R = a.CurrentPageInput, M = a.Download, I = a.EnterFullScreen, E = a.GoToNextPage, T = a.GoToPreviousPage, y = a.NumberOfPages, D = a.Open, j = a.Print, A = a.ShowSearchPopover, d = a.SwitchTheme, _ = a.Zoom, F = a.ZoomIn, U = a.ZoomOut;
      return r.createElement(
        "div",
        { "data-testid": "toolbar", className: e.classNames({
          "rpv-toolbar": !0,
          "rpv-toolbar--rtl": C
        }), role: "toolbar", "aria-orientation": "horizontal" },
        r.createElement(
          "div",
          { className: "rpv-toolbar__left" },
          r.createElement(
            "div",
            { className: "rpv-toolbar__item" },
            r.createElement(A, null)
          ),
          r.createElement(
            "div",
            { className: "rpv-core__display--hidden rpv-core__display--block-small" },
            r.createElement(
              "div",
              { className: "rpv-toolbar__item" },
              r.createElement(T, null)
            )
          ),
          r.createElement(
            "div",
            { className: "rpv-toolbar__item" },
            r.createElement(R, null),
            r.createElement(
              "span",
              { className: "rpv-toolbar__label" },
              r.createElement(y, null)
            )
          ),
          r.createElement(
            "div",
            { className: "rpv-core__display--hidden rpv-core__display--block-small" },
            r.createElement(
              "div",
              { className: "rpv-toolbar__item" },
              r.createElement(E, null)
            )
          )
        ),
        r.createElement(
          "div",
          { className: "rpv-toolbar__center" },
          r.createElement(
            "div",
            { className: "rpv-toolbar__item" },
            r.createElement(U, null)
          ),
          r.createElement(
            "div",
            { className: "rpv-core__display--hidden rpv-core__display--block-small" },
            r.createElement(
              "div",
              { className: "rpv-toolbar__item" },
              r.createElement(_, null)
            )
          ),
          r.createElement(
            "div",
            { className: "rpv-toolbar__item" },
            r.createElement(F, null)
          )
        ),
        r.createElement(
          "div",
          { className: "rpv-toolbar__right" },
          r.createElement(
            "div",
            { className: "rpv-core__display--hidden rpv-core__display--block-medium" },
            r.createElement(
              "div",
              { className: "rpv-toolbar__item" },
              r.createElement(d, null)
            )
          ),
          r.createElement(
            "div",
            { className: "rpv-core__display--hidden rpv-core__display--block-medium" },
            r.createElement(
              "div",
              { className: "rpv-toolbar__item" },
              r.createElement(I, null)
            )
          ),
          r.createElement(
            "div",
            { className: "rpv-core__display--hidden rpv-core__display--block-medium" },
            r.createElement(
              "div",
              { className: "rpv-toolbar__item" },
              r.createElement(D, null)
            )
          ),
          r.createElement(
            "div",
            { className: "rpv-core__display--hidden rpv-core__display--block-medium" },
            r.createElement(
              "div",
              { className: "rpv-toolbar__item" },
              r.createElement(M, null)
            )
          ),
          r.createElement(
            "div",
            { className: "rpv-core__display--hidden rpv-core__display--block-medium" },
            r.createElement(
              "div",
              { className: "rpv-toolbar__item" },
              r.createElement(j, null)
            )
          ),
          r.createElement(
            "div",
            { className: "rpv-toolbar__item" },
            r.createElement(s, { toolbarSlot: a })
          )
        )
      );
    };
  }, o = function(v) {
    var k = v.NumberOfPages;
    return Object.assign({}, v, {
      NumberOfPages: function() {
        return r.createElement(
          r.Fragment,
          null,
          "/ ",
          r.createElement(k, null)
        );
      }
    });
  }, b = function(v) {
    return i(o)(v);
  }, g = function(v) {
    var k = v.children, a = v.slot, f = k || b;
    return f(a);
  }, c = function(v) {
    var k = n.fullScreenPlugin(v ? v.fullScreenPlugin : {}), a = t.getFilePlugin(v ? v.getFilePlugin : {}), f = l.openPlugin(v ? v.openPlugin : {}), C = W.pageNavigationPlugin(v ? v.pageNavigationPlugin : {}), R = Q.printPlugin(v ? v.printPlugin : {}), M = G.propertiesPlugin(), I = X.rotatePlugin(), E = N.scrollModePlugin(), T = H.searchPlugin(v ? v.searchPlugin : {}), y = L.selectionModePlugin(v ? v.selectionModePlugin : {}), D = B.themePlugin(), j = P.zoomPlugin(v ? v.zoomPlugin : {}), A = [
      k,
      a,
      f,
      C,
      R,
      M,
      I,
      E,
      T,
      y,
      D,
      j
    ], d = r.useCallback(function(_) {
      var F = k.EnterFullScreen, U = k.EnterFullScreenMenuItem, V = a.Download, $ = a.DownloadMenuItem, re = f.Open, ge = f.OpenMenuItem, be = C.CurrentPageInput, le = C.CurrentPageLabel, fe = C.GoToFirstPage, Ae = C.GoToFirstPageMenuItem, qe = C.GoToLastPage, ye = C.GoToLastPageMenuItem, ce = C.GoToNextPage, q = C.GoToNextPageMenuItem, Z = C.GoToPreviousPage, pe = C.GoToPreviousPageMenuItem, me = C.NumberOfPages, _e = R.Print, Be = R.PrintMenuItem, ke = M.ShowProperties, de = M.ShowPropertiesMenuItem, $e = I.Rotate, Ge = I.RotateBackwardMenuItem, st = I.RotateForwardMenuItem, it = E.SwitchScrollMode, _t = E.SwitchScrollModeMenuItem, tt = E.SwitchViewMode, Xe = E.SwitchViewModeMenuItem, ct = T.Search, xt = T.ShowSearchPopover, We = y.SwitchSelectionMode, Ce = y.SwitchSelectionModeMenuItem, Re = D.SwitchTheme, lt = D.SwitchThemeMenuItem, bt = j.CurrentScale, Et = j.Zoom, oe = j.ZoomIn, He = j.ZoomInMenuItem, at = j.ZoomOut, St = j.ZoomOutMenuItem;
      return r.createElement(g, w({}, _, { slot: {
        CurrentPageInput: be,
        CurrentPageLabel: le,
        CurrentScale: bt,
        Download: V,
        DownloadMenuItem: $,
        EnterFullScreen: F,
        EnterFullScreenMenuItem: U,
        GoToFirstPage: fe,
        GoToFirstPageMenuItem: Ae,
        GoToLastPage: qe,
        GoToLastPageMenuItem: ye,
        GoToNextPage: ce,
        GoToNextPageMenuItem: q,
        GoToPreviousPage: Z,
        GoToPreviousPageMenuItem: pe,
        NumberOfPages: me,
        Open: re,
        OpenMenuItem: ge,
        Print: _e,
        PrintMenuItem: Be,
        Rotate: $e,
        RotateBackwardMenuItem: Ge,
        RotateForwardMenuItem: st,
        Search: ct,
        ShowProperties: ke,
        ShowPropertiesMenuItem: de,
        ShowSearchPopover: xt,
        SwitchScrollMode: it,
        SwitchScrollModeMenuItem: _t,
        SwitchSelectionMode: We,
        SwitchSelectionModeMenuItem: Ce,
        SwitchViewMode: tt,
        SwitchViewModeMenuItem: Xe,
        SwitchTheme: Re,
        SwitchThemeMenuItem: lt,
        Zoom: Et,
        ZoomIn: oe,
        ZoomInMenuItem: He,
        ZoomOut: at,
        ZoomOutMenuItem: St
      } }));
    }, []);
    return {
      fullScreenPluginInstance: k,
      getFilePluginInstance: a,
      openPluginInstance: f,
      pageNavigationPluginInstance: C,
      printPluginInstance: R,
      propertiesPluginInstance: M,
      rotatePluginInstance: I,
      scrollModePluginInstance: E,
      searchPluginInstance: T,
      selectionModePluginInstance: y,
      themePluginInstance: D,
      zoomPluginInstance: j,
      install: function(_) {
        A.forEach(function(F) {
          F.install && F.install(_);
        });
      },
      renderPageLayer: function(_) {
        return r.createElement(r.Fragment, null, A.map(function(F, U) {
          return F.renderPageLayer ? r.createElement(r.Fragment, { key: U }, F.renderPageLayer(_)) : r.createElement(r.Fragment, { key: U });
        }));
      },
      renderViewer: function(_) {
        var F = _.slot;
        return A.forEach(function(U) {
          U.renderViewer && (F = U.renderViewer(w(w({}, _), { slot: F })));
        }), F;
      },
      uninstall: function(_) {
        A.forEach(function(F) {
          F.uninstall && F.uninstall(_);
        });
      },
      onDocumentLoad: function(_) {
        A.forEach(function(F) {
          F.onDocumentLoad && F.onDocumentLoad(_);
        });
      },
      onAnnotationLayerRender: function(_) {
        A.forEach(function(F) {
          F.onAnnotationLayerRender && F.onAnnotationLayerRender(_);
        });
      },
      onTextLayerRender: function(_) {
        A.forEach(function(F) {
          F.onTextLayerRender && F.onTextLayerRender(_);
        });
      },
      onViewerStateChange: function(_) {
        var F = _;
        return A.forEach(function(U) {
          U.onViewerStateChange && (F = U.onViewerStateChange(F));
        }), F;
      },
      renderDefaultToolbar: i,
      Toolbar: d
    };
  };
  return toolbar.MoreActionsPopover = s, toolbar.MoreIcon = u, toolbar.toolbarPlugin = c, toolbar;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$c.exports;
  hasRequiredLib$1 = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$c.exports = requireToolbar_min() : lib$c.exports = requireToolbar(), lib$c.exports;
}
var hasRequiredDefaultLayout_min;
function requireDefaultLayout_min() {
  if (hasRequiredDefaultLayout_min) return defaultLayout_min;
  hasRequiredDefaultLayout_min = 1;
  var e = requireLib$h(), L = requireReact(), p = requireLib$g(), n = requireLib$f(), t = requireLib$e(), l = requireLib$1();
  function W(r) {
    var u = /* @__PURE__ */ Object.create(null);
    return r && Object.keys(r).forEach(function(m) {
      if (m !== "default") {
        var s = Object.getOwnPropertyDescriptor(r, m);
        Object.defineProperty(u, m, s.get ? s : { enumerable: !0, get: function() {
          return r[m];
        } });
      }
    }), u.default = r, Object.freeze(u);
  }
  var Q = W(L), G = function() {
    return Q.createElement(e.Icon, { size: 16 }, Q.createElement("path", { d: `M11.5,1.5h11c0.552,0,1,0.448,1,1v20c0,0.552-0.448,1-1,1h-21c-0.552,0-1-0.448-1-1v-20c0-0.552,0.448-1,1-1h3
            M11.5,10.5c0,0.55-0.3,0.661-0.659,0.248L8,7.5l-2.844,3.246c-0.363,0.414-0.659,0.3-0.659-0.247v-9c0-0.552,0.448-1,1-1h5
            c0.552,0,1,0.448,1,1L11.5,10.5z
            M14.5,6.499h6
            M14.5,10.499h6
            M3.5,14.499h17
            M3.5,18.499h16.497` }));
  }, X = function() {
    return X = Object.assign || function(r) {
      for (var u, m = 1, s = arguments.length; m < s; m++) for (var w in u = arguments[m]) Object.prototype.hasOwnProperty.call(u, w) && (r[w] = u[w]);
      return r;
    }, X.apply(this, arguments);
  }, N = function() {
    return Q.createElement(e.Icon, { size: 16 }, Q.createElement("path", { d: `M7.618,15.345l8.666-8.666c0.78-0.812,2.071-0.838,2.883-0.058s0.838,2.071,0.058,2.883
            c-0.019,0.02-0.038,0.039-0.058,0.058L7.461,21.305c-1.593,1.593-4.175,1.592-5.767,0s-1.592-4.175,0-5.767c0,0,0,0,0,0
            L13.928,3.305c2.189-2.19,5.739-2.19,7.929-0.001s2.19,5.739,0,7.929l0,0L13.192,19.9` }));
  }, H = function() {
    return Q.createElement(e.Icon, { size: 16 }, Q.createElement("path", { d: `M10.5,9.5c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V9.5z
            M23.5,9.5c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V9.5z
            M10.5,22.5 c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V22.5z
            M23.5,22.5c0,0.552-0.448,1-1,1 h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V22.5z` }));
  }, B = { left: 8, top: 0 }, P = { left: -8, top: 0 }, S = function(r) {
    var u = r.attachmentTabContent, m = r.bookmarkTabContent, s = r.store, w = r.thumbnailTabContent, i = r.tabs, o = Q.useRef(), b = Q.useContext(e.LocalizationContext).l10n, g = Q.useState(s.get("isCurrentTabOpened") || !1), c = g[0], v = g[1], k = Q.useState(Math.max(s.get("currentTab") || 0, 0)), a = k[0], f = k[1], C = Q.useContext(e.ThemeContext).direction === e.TextDirection.RightToLeft, R = [{ content: w, icon: Q.createElement(H, null), title: b && b.defaultLayout ? b.defaultLayout.thumbnail : "Thumbnail" }, { content: m, icon: Q.createElement(G, null), title: b && b.defaultLayout ? b.defaultLayout.bookmark : "Bookmark" }, { content: u, icon: Q.createElement(N, null), title: b && b.defaultLayout ? b.defaultLayout.attachment : "Attachment" }], M = i ? i(R) : R, I = function(T) {
      T >= 0 && T <= M.length - 1 && (s.update("isCurrentTabOpened", !0), f(T));
    }, E = function(T) {
      v(T);
    };
    return Q.useEffect(function() {
      return s.subscribe("currentTab", I), s.subscribe("isCurrentTabOpened", E), function() {
        s.unsubscribe("currentTab", I), s.unsubscribe("isCurrentTabOpened", E);
      };
    }, []), M.length === 0 ? Q.createElement(Q.Fragment, null) : Q.createElement(Q.Fragment, null, Q.createElement("div", { "data-testid": "default-layout__sidebar", className: e.classNames({ "rpv-default-layout__sidebar": !0, "rpv-default-layout__sidebar--opened": c, "rpv-default-layout__sidebar--ltr": !C, "rpv-default-layout__sidebar--rtl": C }), ref: o }, Q.createElement("div", { className: "rpv-default-layout__sidebar-tabs" }, Q.createElement("div", { className: "rpv-default-layout__sidebar-headers", role: "tablist", "aria-orientation": "vertical" }, M.map(function(T, y) {
      return Q.createElement("div", { "aria-controls": "rpv-default-layout__sidebar-content", "aria-selected": a === y, key: y, className: "rpv-default-layout__sidebar-header", id: "rpv-default-layout__sidebar-tab-".concat(y), role: "tab" }, Q.createElement(e.Tooltip, { ariaControlsSuffix: "default-layout-sidebar-tab-".concat(y), position: C ? e.Position.LeftCenter : e.Position.RightCenter, target: Q.createElement(e.MinimalButton, { ariaLabel: T.title, isSelected: a === y, onClick: function() {
        return function(D) {
          if (a === D) {
            s.update("isCurrentTabOpened", !s.get("isCurrentTabOpened"));
            var j = o.current;
            j && j.style.width && j.style.removeProperty("width");
          } else s.update("currentTab", D);
        }(y);
      } }, T.icon), content: function() {
        return T.title;
      }, offset: C ? P : B }));
    })), Q.createElement("div", { "aria-labelledby": "rpv-default-layout__sidebar-tab-".concat(a), id: "rpv-default-layout__sidebar-content", className: e.classNames({ "rpv-default-layout__sidebar-content": !0, "rpv-default-layout__sidebar-content--opened": c, "rpv-default-layout__sidebar-content--ltr": !C, "rpv-default-layout__sidebar-content--rtl": C }), role: "tabpanel", tabIndex: -1 }, M[a].content))), c && Q.createElement(e.Splitter, { constrain: function(T) {
      return T.firstHalfPercentage >= 20 && T.firstHalfPercentage <= 80;
    } }));
  };
  return defaultLayout_min.BookmarkIcon = G, defaultLayout_min.FileIcon = N, defaultLayout_min.ThumbnailIcon = H, defaultLayout_min.defaultLayoutPlugin = function(r) {
    var u = Q.useMemo(function() {
      return e.createStore({ isCurrentTabOpened: !1, currentTab: 0 });
    }, []), m = p.attachmentPlugin(), s = n.bookmarkPlugin(), w = t.thumbnailPlugin(r ? r.thumbnailPlugin : {}), i = l.toolbarPlugin(r ? r.toolbarPlugin : {}), o = m.Attachments, b = s.Bookmarks, g = w.Thumbnails, c = i.Toolbar, v = r ? r.sidebarTabs : function(a) {
      return a;
    }, k = [m, s, w, i];
    return { attachmentPluginInstance: m, bookmarkPluginInstance: s, thumbnailPluginInstance: w, toolbarPluginInstance: i, activateTab: function(a) {
      u.update("currentTab", a);
    }, toggleTab: function(a) {
      var f = u.get("currentTab");
      u.update("isCurrentTabOpened", !u.get("isCurrentTabOpened")), f !== a && u.update("currentTab", a);
    }, install: function(a) {
      k.forEach(function(f) {
        f.install && f.install(a);
      });
    }, renderPageLayer: function(a) {
      return Q.createElement(Q.Fragment, null, k.map(function(f, C) {
        return f.renderPageLayer ? Q.createElement(Q.Fragment, { key: C }, f.renderPageLayer(a)) : Q.createElement(Q.Fragment, { key: C }, Q.createElement(Q.Fragment, null));
      }));
    }, renderViewer: function(a) {
      var f = a.slot;
      k.forEach(function(R) {
        R.renderViewer && (f = R.renderViewer(X(X({}, a), { slot: f })));
      });
      var C = f.subSlot && f.subSlot.attrs ? { className: f.subSlot.attrs.className, "data-testid": f.subSlot.attrs["data-testid"], ref: f.subSlot.attrs.ref, style: f.subSlot.attrs.style } : {};
      return f.children = Q.createElement("div", { className: "rpv-default-layout__container" }, Q.createElement("div", { "data-testid": "default-layout__main", className: e.classNames({ "rpv-default-layout__main": !0, "rpv-default-layout__main--rtl": a.themeContext.direction === e.TextDirection.RightToLeft }) }, Q.createElement(S, { attachmentTabContent: Q.createElement(o, null), bookmarkTabContent: Q.createElement(b, null), store: u, thumbnailTabContent: Q.createElement(g, null), tabs: v }), Q.createElement("div", { className: "rpv-default-layout__body", "data-testid": "default-layout__body" }, Q.createElement("div", { className: "rpv-default-layout__toolbar" }, r && r.renderToolbar ? r.renderToolbar(c) : Q.createElement(c, null)), Q.createElement("div", X({}, C), f.subSlot.children))), f.children), f.subSlot.attrs = {}, f.subSlot.children = Q.createElement(Q.Fragment, null), f;
    }, uninstall: function(a) {
      k.forEach(function(f) {
        f.uninstall && f.uninstall(a);
      });
    }, onDocumentLoad: function(a) {
      k.forEach(function(f) {
        f.onDocumentLoad && f.onDocumentLoad(a);
      }), r && r.setInitialTab && r.setInitialTab(a.doc).then(function(f) {
        u.update("currentTab", f), u.update("isCurrentTabOpened", !0);
      });
    }, onAnnotationLayerRender: function(a) {
      k.forEach(function(f) {
        f.onAnnotationLayerRender && f.onAnnotationLayerRender(a);
      });
    }, onTextLayerRender: function(a) {
      k.forEach(function(f) {
        f.onTextLayerRender && f.onTextLayerRender(a);
      });
    }, onViewerStateChange: function(a) {
      var f = a;
      return k.forEach(function(C) {
        C.onViewerStateChange && (f = C.onViewerStateChange(f));
      }), f;
    } };
  }, defaultLayout_min.setInitialTabFromPageMode = function(r) {
    return new Promise(function(u, m) {
      r.getPageMode().then(function(s) {
        if (s) switch (s) {
          case e.PageMode.Attachments:
            u(2);
            break;
          case e.PageMode.Bookmarks:
            u(1);
            break;
          case e.PageMode.Thumbnails:
            u(0);
            break;
          default:
            u(-1);
        }
        else u(-1);
      });
    });
  }, defaultLayout_min;
}
var defaultLayout = {}, hasRequiredDefaultLayout;
function requireDefaultLayout() {
  if (hasRequiredDefaultLayout) return defaultLayout;
  hasRequiredDefaultLayout = 1;
  var e = requireLib$h(), L = requireReact(), p = requireLib$g(), n = requireLib$f(), t = requireLib$e(), l = requireLib$1();
  function W(m) {
    var s = /* @__PURE__ */ Object.create(null);
    return m && Object.keys(m).forEach(function(w) {
      if (w !== "default") {
        var i = Object.getOwnPropertyDescriptor(m, w);
        Object.defineProperty(s, w, i.get ? i : {
          enumerable: !0,
          get: function() {
            return m[w];
          }
        });
      }
    }), s.default = m, Object.freeze(s);
  }
  var Q = /* @__PURE__ */ W(L), G = function() {
    return Q.createElement(
      e.Icon,
      { size: 16 },
      Q.createElement("path", { d: `M11.5,1.5h11c0.552,0,1,0.448,1,1v20c0,0.552-0.448,1-1,1h-21c-0.552,0-1-0.448-1-1v-20c0-0.552,0.448-1,1-1h3
            M11.5,10.5c0,0.55-0.3,0.661-0.659,0.248L8,7.5l-2.844,3.246c-0.363,0.414-0.659,0.3-0.659-0.247v-9c0-0.552,0.448-1,1-1h5
            c0.552,0,1,0.448,1,1L11.5,10.5z
            M14.5,6.499h6
            M14.5,10.499h6
            M3.5,14.499h17
            M3.5,18.499h16.497` })
    );
  }, X = function() {
    return X = Object.assign || function(s) {
      for (var w, i = 1, o = arguments.length; i < o; i++) {
        w = arguments[i];
        for (var b in w) Object.prototype.hasOwnProperty.call(w, b) && (s[b] = w[b]);
      }
      return s;
    }, X.apply(this, arguments);
  }, N = function() {
    return Q.createElement(
      e.Icon,
      { size: 16 },
      Q.createElement("path", { d: `M7.618,15.345l8.666-8.666c0.78-0.812,2.071-0.838,2.883-0.058s0.838,2.071,0.058,2.883
            c-0.019,0.02-0.038,0.039-0.058,0.058L7.461,21.305c-1.593,1.593-4.175,1.592-5.767,0s-1.592-4.175,0-5.767c0,0,0,0,0,0
            L13.928,3.305c2.189-2.19,5.739-2.19,7.929-0.001s2.19,5.739,0,7.929l0,0L13.192,19.9` })
    );
  }, H = function() {
    return Q.createElement(
      e.Icon,
      { size: 16 },
      Q.createElement("path", { d: `M10.5,9.5c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V9.5z
            M23.5,9.5c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V9.5z
            M10.5,22.5 c0,0.552-0.448,1-1,1h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V22.5z
            M23.5,22.5c0,0.552-0.448,1-1,1 h-8c-0.552,0-1-0.448-1-1v-8c0-0.552,0.448-1,1-1h8c0.552,0,1,0.448,1,1V22.5z` })
    );
  }, B = { left: 8, top: 0 }, P = { left: -8, top: 0 }, S = function(m) {
    var s = m.attachmentTabContent, w = m.bookmarkTabContent, i = m.store, o = m.thumbnailTabContent, b = m.tabs, g = Q.useRef(), c = Q.useContext(e.LocalizationContext).l10n, v = Q.useState(i.get("isCurrentTabOpened") || !1), k = v[0], a = v[1], f = Q.useState(Math.max(i.get("currentTab") || 0, 0)), C = f[0], R = f[1], M = Q.useContext(e.ThemeContext).direction, I = M === e.TextDirection.RightToLeft, E = function(d) {
      return d.firstHalfPercentage >= 20 && d.firstHalfPercentage <= 80;
    }, T = [
      {
        content: o,
        icon: Q.createElement(H, null),
        title: c && c.defaultLayout ? c.defaultLayout.thumbnail : "Thumbnail"
      },
      {
        content: w,
        icon: Q.createElement(G, null),
        title: c && c.defaultLayout ? c.defaultLayout.bookmark : "Bookmark"
      },
      {
        content: s,
        icon: Q.createElement(N, null),
        title: c && c.defaultLayout ? c.defaultLayout.attachment : "Attachment"
      }
    ], y = b ? b(T) : T, D = function(d) {
      if (C === d) {
        i.update("isCurrentTabOpened", !i.get("isCurrentTabOpened"));
        var _ = g.current;
        if (_) {
          var F = _.style.width;
          F && _.style.removeProperty("width");
        }
      } else
        i.update("currentTab", d);
    }, j = function(d) {
      d >= 0 && d <= y.length - 1 && (i.update("isCurrentTabOpened", !0), R(d));
    }, A = function(d) {
      a(d);
    };
    return Q.useEffect(function() {
      return i.subscribe("currentTab", j), i.subscribe("isCurrentTabOpened", A), function() {
        i.unsubscribe("currentTab", j), i.unsubscribe("isCurrentTabOpened", A);
      };
    }, []), y.length === 0 ? Q.createElement(Q.Fragment, null) : Q.createElement(
      Q.Fragment,
      null,
      Q.createElement(
        "div",
        { "data-testid": "default-layout__sidebar", className: e.classNames({
          "rpv-default-layout__sidebar": !0,
          "rpv-default-layout__sidebar--opened": k,
          "rpv-default-layout__sidebar--ltr": !I,
          "rpv-default-layout__sidebar--rtl": I
        }), ref: g },
        Q.createElement(
          "div",
          { className: "rpv-default-layout__sidebar-tabs" },
          Q.createElement("div", { className: "rpv-default-layout__sidebar-headers", role: "tablist", "aria-orientation": "vertical" }, y.map(function(d, _) {
            return Q.createElement(
              "div",
              { "aria-controls": "rpv-default-layout__sidebar-content", "aria-selected": C === _, key: _, className: "rpv-default-layout__sidebar-header", id: "rpv-default-layout__sidebar-tab-".concat(_), role: "tab" },
              Q.createElement(e.Tooltip, { ariaControlsSuffix: "default-layout-sidebar-tab-".concat(_), position: I ? e.Position.LeftCenter : e.Position.RightCenter, target: Q.createElement(e.MinimalButton, { ariaLabel: d.title, isSelected: C === _, onClick: function() {
                return D(_);
              } }, d.icon), content: function() {
                return d.title;
              }, offset: I ? P : B })
            );
          })),
          Q.createElement("div", { "aria-labelledby": "rpv-default-layout__sidebar-tab-".concat(C), id: "rpv-default-layout__sidebar-content", className: e.classNames({
            "rpv-default-layout__sidebar-content": !0,
            "rpv-default-layout__sidebar-content--opened": k,
            "rpv-default-layout__sidebar-content--ltr": !I,
            "rpv-default-layout__sidebar-content--rtl": I
          }), role: "tabpanel", tabIndex: -1 }, y[C].content)
        )
      ),
      k && Q.createElement(e.Splitter, { constrain: E })
    );
  }, r = function(m) {
    var s = Q.useMemo(function() {
      return e.createStore({
        isCurrentTabOpened: !1,
        currentTab: 0
      });
    }, []), w = p.attachmentPlugin(), i = n.bookmarkPlugin(), o = t.thumbnailPlugin(m ? m.thumbnailPlugin : {}), b = l.toolbarPlugin(m ? m.toolbarPlugin : {}), g = w.Attachments, c = i.Bookmarks, v = o.Thumbnails, k = b.Toolbar, a = m ? m.sidebarTabs : function(C) {
      return C;
    }, f = [w, i, o, b];
    return {
      attachmentPluginInstance: w,
      bookmarkPluginInstance: i,
      thumbnailPluginInstance: o,
      toolbarPluginInstance: b,
      activateTab: function(C) {
        s.update("currentTab", C);
      },
      toggleTab: function(C) {
        var R = s.get("currentTab");
        s.update("isCurrentTabOpened", !s.get("isCurrentTabOpened")), R !== C && s.update("currentTab", C);
      },
      install: function(C) {
        f.forEach(function(R) {
          R.install && R.install(C);
        });
      },
      renderPageLayer: function(C) {
        return Q.createElement(Q.Fragment, null, f.map(function(R, M) {
          return R.renderPageLayer ? Q.createElement(Q.Fragment, { key: M }, R.renderPageLayer(C)) : Q.createElement(
            Q.Fragment,
            { key: M },
            Q.createElement(Q.Fragment, null)
          );
        }));
      },
      renderViewer: function(C) {
        var R = C.slot;
        f.forEach(function(I) {
          I.renderViewer && (R = I.renderViewer(X(X({}, C), { slot: R })));
        });
        var M = R.subSlot && R.subSlot.attrs ? {
          className: R.subSlot.attrs.className,
          "data-testid": R.subSlot.attrs["data-testid"],
          ref: R.subSlot.attrs.ref,
          style: R.subSlot.attrs.style
        } : {};
        return R.children = Q.createElement(
          "div",
          { className: "rpv-default-layout__container" },
          Q.createElement(
            "div",
            { "data-testid": "default-layout__main", className: e.classNames({
              "rpv-default-layout__main": !0,
              "rpv-default-layout__main--rtl": C.themeContext.direction === e.TextDirection.RightToLeft
            }) },
            Q.createElement(S, { attachmentTabContent: Q.createElement(g, null), bookmarkTabContent: Q.createElement(c, null), store: s, thumbnailTabContent: Q.createElement(v, null), tabs: a }),
            Q.createElement(
              "div",
              { className: "rpv-default-layout__body", "data-testid": "default-layout__body" },
              Q.createElement("div", { className: "rpv-default-layout__toolbar" }, m && m.renderToolbar ? m.renderToolbar(k) : Q.createElement(k, null)),
              Q.createElement("div", X({}, M), R.subSlot.children)
            )
          ),
          R.children
        ), R.subSlot.attrs = {}, R.subSlot.children = Q.createElement(Q.Fragment, null), R;
      },
      uninstall: function(C) {
        f.forEach(function(R) {
          R.uninstall && R.uninstall(C);
        });
      },
      onDocumentLoad: function(C) {
        f.forEach(function(R) {
          R.onDocumentLoad && R.onDocumentLoad(C);
        }), m && m.setInitialTab && m.setInitialTab(C.doc).then(function(R) {
          s.update("currentTab", R), s.update("isCurrentTabOpened", !0);
        });
      },
      onAnnotationLayerRender: function(C) {
        f.forEach(function(R) {
          R.onAnnotationLayerRender && R.onAnnotationLayerRender(C);
        });
      },
      onTextLayerRender: function(C) {
        f.forEach(function(R) {
          R.onTextLayerRender && R.onTextLayerRender(C);
        });
      },
      onViewerStateChange: function(C) {
        var R = C;
        return f.forEach(function(M) {
          M.onViewerStateChange && (R = M.onViewerStateChange(R));
        }), R;
      }
    };
  }, u = function(m) {
    return new Promise(function(s, w) {
      m.getPageMode().then(function(i) {
        if (!i)
          s(-1);
        else
          switch (i) {
            case e.PageMode.Attachments:
              s(2);
              break;
            case e.PageMode.Bookmarks:
              s(1);
              break;
            case e.PageMode.Thumbnails:
              s(0);
              break;
            default:
              s(-1);
              break;
          }
      });
    });
  };
  return defaultLayout.BookmarkIcon = G, defaultLayout.FileIcon = N, defaultLayout.ThumbnailIcon = H, defaultLayout.defaultLayoutPlugin = r, defaultLayout.setInitialTabFromPageMode = u, defaultLayout;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$g.exports;
  hasRequiredLib = 1;
  var e = {};
  /**
   * A React component to view a PDF document
   *
   * @see https://react-pdf-viewer.dev
   * @license https://react-pdf-viewer.dev/license
   * @copyright 2019-2023 Nguyen Huu Phuoc <me@phuoc.ng>
   */
  return e.NODE_ENV === "production" ? lib$g.exports = requireDefaultLayout_min() : lib$g.exports = requireDefaultLayout(), lib$g.exports;
}
var libExports = requireLib();
const PdfViewer = () => {
  const e = libExports.defaultLayoutPlugin();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(libExports$1.Worker, { workerUrl: "https://static.testpress.in/static/learnlens/pdf.worker.min.js", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    libExports$1.Viewer,
    {
      fileUrl: "https://mozilla.github.io/pdf.js/web/compressed.tracemonkey-pldi-09.pdf",
      plugins: [e]
    }
  ) });
};
function mountPdfViewer(e) {
  const L = document.getElementById(e);
  if (!L)
    throw new Error(`Element with id '${e}' not found`);
  ReactDOM.createRoot(L).render(React.createElement(PdfViewer));
}
typeof window < "u" && (window.LearnLens = window.LearnLens || {}, window.LearnLens.mountPdfViewer = mountPdfViewer);
export {
  mountPdfViewer
};
